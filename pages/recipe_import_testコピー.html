<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ取得テスト — Recipe Box</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../assets/css/style.css?v=20250116ai">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- GitHub Pages用設定（直接埋め込み） -->
  <script>
    window.APP_CONFIG = {
      // Supabase設定（本番環境）
      SUPABASE_URL: 'https://nnbdzwrndqtsfzobknmj.supabase.co',
      SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q',
      
      // API設定
      API_BASE_URL: 'https://nnbdzwrndqtsfzobknmj.supabase.co/functions/v1',
      
      // アプリ設定
      APP_NAME: 'Recipe Keeper',
      VERSION: '1.0.0',
      
      // GitHub Pages用設定
      IS_GITHUB_PAGES: true,
      BASE_PATH: '/recipes'
    };
    
    console.log('✅ GitHub Pages設定ロード完了:', window.APP_CONFIG);
  </script>
  <script src="../assets/js/utils.js"></script>
  <script src="../assets/js/proxy-manager.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      /* ライトモード */
      --bg-primary: #f6f8fa;
      --bg-surface: #ffffff;
      --text-primary: #1f2933;
      --text-secondary: #64748b;
      --border-color: rgba(148, 163, 184, 0.25);
      --accent-primary: #6366f1;
      --success-color: #059669;
      --warning-color: #d97706;
      --error-color: #dc2626;
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        /* ダークモード */
        --bg-primary: #0f172a;
        --bg-surface: #1e293b;
        --text-primary: #f8fafc;
        --text-secondary: #94a3b8;
        --border-color: rgba(148, 163, 184, 0.2);
        --accent-primary: #818cf8;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }

    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    main {
      flex: 1;
      padding: 2rem 1.5rem 4rem;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
    }
    
    @media (max-width: 768px) {
      main {
        padding: 1.5rem 1rem 3rem;
      }
    }
    
    .import-card {
      background: var(--bg-surface);
      border-radius: 20px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.12);
      padding: clamp(2rem, 4vw, 3rem);
      border: 1px solid var(--border-color);
      margin-bottom: 3rem;
      transition: box-shadow 0.3s ease;
    }
    
    .import-card:hover {
      box-shadow: 0 25px 55px rgba(15, 23, 42, 0.15);
    }
    
    .import-card header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 2rem;
      text-align: center;
    }
    
    .import-card h1 {
      font-size: clamp(1.6rem, 4vw, 2.2rem);
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }
    
    .import-card h1 i {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .import-card p {
      margin: 0 auto;
      color: var(--text-secondary);
      line-height: 1.6;
      font-size: 1rem;
      max-width: 600px;
    }
    
    form {
      display: grid;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    label {
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.95rem;
    }
    
    input[type="url"] {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    
    input[type="url"]:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
    }
    
    .api-selector {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .api-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-surface);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .api-option:hover {
      border-color: var(--accent-primary);
    }
    
    .api-option input[type="radio"] {
      margin: 0;
    }
    
    .api-option.selected {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
    }
    
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.85rem 1.6rem;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }
    
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 15px 35px rgba(99, 102, 241, 0.25);
    }
    
    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .button-group button {
      flex: 1;
      min-width: 140px;
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #64748b, #475569);
      color: white;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, #475569, #334155);
      box-shadow: 0 15px 35px rgba(100, 116, 139, 0.25);
    }
    
    /* モーダルスタイル */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: var(--bg-surface);
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.3);
      max-width: 600px;
      width: 95%;
      max-height: 90vh;
      overflow-y: auto;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    .modal-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.25rem;
      border-radius: 4px;
      transition: color 0.2s ease;
    }
    
    .modal-close:hover {
      color: var(--text-primary);
    }
    
    .modal-body {
      padding: 1.5rem;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
    }
    
    .image-upload-section {
      text-align: center;
      padding: 2rem 1rem;
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      background: var(--bg-primary);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    .image-upload-section:hover {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.05);
    }
    
    .image-upload-section.drag-over {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
      border-style: solid;
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.15);
    }
    
    .image-upload-section.drag-over::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 10px;
      pointer-events: none;
    }
    
    .drag-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.9);
      border-radius: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      z-index: 10;
    }
    
    .image-upload-section.drag-over .drag-overlay {
      display: flex;
    }
    
    .btn.ghost {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }
    
    .btn.ghost:hover:not(:disabled) {
      background: var(--bg-primary);
      color: var(--text-primary);
      box-shadow: none;
    }
    
    .btn.primary {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      color: white;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 0.65rem;
      font-size: 0.95rem;
      color: var(--text-secondary);
      min-height: 1.2rem;
      margin: 1rem 0;
    }
    
    .status i {
      color: var(--accent-primary);
    }
    
    .status.success {
      color: var(--success-color);
    }
    
    .status.warning {
      color: var(--warning-color);
    }
    
    .status.error {
      color: var(--error-color);
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
      min-width: 0;
      overflow: hidden;
    }
    
    @media (max-width: 768px) {
      .results-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .result-section {
      background: var(--bg-surface);
      border-radius: 16px;
      border: 1px solid var(--border-color);
      padding: 2rem;
      min-width: 0;
      overflow: hidden;
      word-wrap: break-word;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
      transition: box-shadow 0.2s ease;
    }
    
    .result-section:hover {
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.12);
    }
    
    .result-section h3 {
      margin: 0 0 1.5rem 0;
      font-size: 1.25rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: var(--text-primary);
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 0.75rem;
    }
    
    .result-section h3 i {
      color: var(--accent-primary);
    }
    
    .recipe-preview {
      display: grid;
      gap: 1rem;
    }
    
    .recipe-field {
      display: grid;
      gap: 0.25rem;
    }
    
    .recipe-field label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 0;
    }
    
    .recipe-field .value {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-height: 1.2rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    .ingredients-list, .steps-list {
      display: grid;
      gap: 0.5rem;
    }
    
    .ingredient-item, .step-item {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.5rem;
      font-size: 0.9rem;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      white-space: normal;
      line-height: 1.4;
    }
    
    /* テーブルスタイル改善 */
    .table {
      width: 100%;
      max-width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border-spacing: 0;
      margin: 1rem 0;
      background: var(--bg-surface);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .table th,
    .table td {
      padding: 0.75rem 0.5rem;
      text-align: left;
      vertical-align: top;
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.4;
      border-bottom: 1px solid var(--border-color);
      max-width: 0;
    }
    
    .table th {
      background: var(--accent-primary);
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .table td {
      font-size: 0.9rem;
      color: var(--text-primary);
    }
    
    /* 列幅の調整 */
    .table th:nth-child(1),
    .table td:nth-child(1) {
      width: 8%;
      text-align: center;
    }
    
    .table th:nth-child(2),
    .table td:nth-child(2) {
      width: 45%;
    }
    
    .table th:nth-child(3),
    .table td:nth-child(3) {
      width: 25%;
      text-align: right;
    }
    
    .table th:nth-child(4),
    .table td:nth-child(4) {
      width: 22%;
      text-align: center;
    }
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .table th,
      .table td {
        padding: 0.5rem 0.25rem;
        font-size: 0.8rem;
      }
      
      .table th:nth-child(2),
      .table td:nth-child(2) {
        width: 40%;
      }
      
      .table th:nth-child(3),
      .table td:nth-child(3) {
        width: 30%;
      }
    }
    
    
    /* 文字列見切れ防止の包括的設定 */
    * {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      box-sizing: border-box !important;
    }
    
    p, span, div, label, button, input, textarea, select {
      word-wrap: break-word !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      line-height: 1.5 !important;
    }
    
    .example-urls {
      display: grid;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .example-url {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }
    
    .example-url:hover {
      border-color: var(--accent-primary);
    }
    
    .example-url .url {
      flex: 1;
      font-family: monospace;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .example-url .label {
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .translate-btn {
      appearance: none;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.6rem 1.2rem;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      width: 100%;
    }
    
    .translate-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(16, 185, 129, 0.25);
    }
    
    .translate-btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .translation-selector {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    .translation-selector label {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.9rem;
      min-width: max-content;
    }
    
    .language-select {
      appearance: none;
      background: var(--bg-surface);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.9rem;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 0.5rem center;
      background-repeat: no-repeat;
      background-size: 1.5em 1.5em;
      min-width: 200px;
    }
    
    .language-select:hover {
      border-color: var(--accent-primary);
    }
    
    .language-select:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    @media (max-width: 768px) {
      .translation-selector {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
      }
      
      .language-select {
        min-width: unset;
        width: 100%;
      }
    }
    
    .results-grid.with-translation {
      grid-template-columns: 1fr 1fr 1fr;
    }
    
    @media (max-width: 1024px) {
      .results-grid.with-translation {
        grid-template-columns: 1fr;
      }
    }
    
    /* フレキシブルレシピ表示 */
    .recipe-section {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--bg-surface);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      word-wrap: break-word;
    }
    
    .recipe-section-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent-primary);
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      line-height: 1.3;
    }
    
    .recipe-section-weight {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-style: italic;
      margin-bottom: 0.5rem;
      word-wrap: break-word;
    }
    
    .recipe-ingredients-grid {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 0.5rem;
      align-items: start;
      margin-bottom: 0.75rem;
      min-width: 0;
    }
    
    .ingredient-name {
      font-weight: 500;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      min-width: 0;
      line-height: 1.4;
    }
    
    .ingredient-quantity {
      text-align: right;
      font-weight: 600;
      color: var(--accent-primary);
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .ingredient-unit {
      font-size: 0.9rem;
      color: var(--text-secondary);
      min-width: 40px;
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .recipe-instructions {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .recipe-instructions p {
      margin-bottom: 0.5rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
    }
    
    /* モバイル対応 */
    @media (max-width: 768px) {
      .recipe-ingredients-grid {
        grid-template-columns: 1fr;
        gap: 0.25rem;
        align-items: stretch;
      }
      
      .ingredient-name {
        font-weight: 600;
        margin-bottom: 0.25rem;
      }
      
      .ingredient-quantity,
      .ingredient-unit {
        text-align: left;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }
      
      .ingredient-quantity::after {
        content: " ";
      }
      
      .recipe-section-title {
        font-size: 1rem;
        line-height: 1.2;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="import-card">
      <header>
        <h1><i class="fa-solid fa-robot"></i> レシピ自動取得テスト</h1>
        <p>Recipe Keeper.appのレシピ取得システムをテストします。URLを入力すると、AI（Groq/ChatGPT）がWebサイトからレシピ情報を自動抽出します。</p>
      </header>

      <!-- 元ページプレビュー（抽出結果の参照・修正用） -->
      <section id="sourcePreviewSection" style="margin: 1rem 0;">
        <div style="display:flex; align-items:center; gap: .5rem; flex-wrap: wrap;">
          <input id="sourcePreviewUrl" type="text" placeholder="元ページURLを入力 (例: https://cookpad.com/...)" style="flex:1; min-width:240px; padding:.5rem .75rem; border:1px solid #ddd; border-radius:8px; box-sizing:border-box;">
          <button id="loadSourcePreviewBtn" type="button" class="btn secondary">
            <i class="fas fa-eye"></i>
            元ページを表示
          </button>
          <label style="display:flex; align-items:center; gap:.35rem; cursor:pointer;">
            <input id="dockPreviewRight" type="checkbox" checked>
            右にドック表示
          </label>
        </div>
        <div id="sourcePreviewPane" style="margin-top:.75rem; display:none; border:1px solid #e5e7eb; border-radius:10px; overflow:hidden;">
          <div style="padding:.5rem .75rem; background:#f8f9fa; border-bottom:1px solid #e5e7eb; display:flex; justify-content:space-between; align-items:center;">
            <strong style="font-size:.95rem;">元ページプレビュー</strong>
            <small id="sourcePreviewInfo" style="color:#666;">未読み込み</small>
          </div>
          <div id="sourcePreviewSplit" style="display:flex; flex-direction:row; gap:0;">
            <iframe id="sourcePreviewFrame" title="source preview" style="width:50%; min-height:60vh; border:0; background:white;"></iframe>
            <div id="sourcePreviewHelp" style="width:50%; min-height:60vh; padding:1rem; box-sizing:border-box; overflow:auto;">
              <p style="margin:0 0 .75rem 0; line-height:1.5; word-wrap:break-word; word-break:break-word; overflow-wrap:break-word; white-space:normal;">抽出した材料・手順を右側の編集欄と見比べながら修正できます。サイトがiframeを拒否する場合は、プロキシ経由でHTMLを読み込み、<code>srcdoc</code>で表示します。</p>
            </div>
          </div>
        </div>
      </section>

      <form id="importForm">
        <label>
          レシピサイトURL
          <input type="url" id="urlInput" name="url" placeholder="https://cookpad.com/recipe/123456" required>
          <small style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.25rem;">
            対応サイト: クックパッド、クラシル、Marmiton、DelishKitchen、料理王国など
          </small>
        </label>

        <label>
          AI API選択
          <div class="api-selector">
            <div class="api-option selected" data-api="groq">
              <input type="radio" name="api" value="groq" checked>
              <span>Groq (推奨)</span>
            </div>
            <div class="api-option" data-api="chatgpt">
              <input type="radio" name="api" value="chatgpt">
              <span>ChatGPT</span>
            </div>
            <div class="api-option" data-api="gemini">
              <input type="radio" name="api" value="gemini">
              <span>Gemini</span>
            </div>
          </div>
        </label>

        <div class="button-group">
          <button type="submit" id="importButton">
            <i class="fa-solid fa-download"></i> レシピを取得
          </button>
          <button type="button" id="imageImportBtn" class="btn secondary">
            <i class="fas fa-camera"></i> 画像解析
          </button>
        </div>
      </form>

      <div class="status" id="statusRow"></div>

      <div class="example-urls">
        <h3>テスト用URL例</h3>
        <div class="example-url" data-url="https://cookpad.com/recipe/2798655">
          <span class="label">クックパッド:</span>
          <span class="url">https://cookpad.com/recipe/2798655</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.kurashiru.com/recipes/c2b1c7c0-1234-5678-9abc-def012345678">
          <span class="label">クラシル:</span>
          <span class="url">https://www.kurashiru.com/recipes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
        <div class="example-url" data-url="https://www.marmiton.org/recettes/recette_quiche-lorraine_11242.aspx">
          <span class="label">Marmiton (仏):</span>
          <span class="url">https://www.marmiton.org/recettes/...</span>
          <i class="fa-solid fa-copy"></i>
        </div>
      </div>
    </section>

    <div class="results-grid" id="resultsGrid" hidden>
      <div class="result-section">
        <h3><i class="fa-solid fa-utensils"></i> 抽出されたレシピ（元言語）</h3>
        <div class="recipe-field" id="recipeImageContainer" style="display: none; margin-bottom: 1rem;">
          <label>抽出された画像</label>
          <img id="recipeImage" src="" alt="Recipe Image" style="max-width: 100%; border-radius: 12px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
          <input type="text" id="recipeImageUrlInput" placeholder="画像URLを編集・入力" style="width: 100%; margin-top: 0.75rem; padding: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color);">
        </div>
        <div class="recipe-preview" id="recipePreview">
          <div class="recipe-field">
            <label>タイトル</label>
            <div class="value" id="recipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>説明</label>
            <div class="value" id="recipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>人数</label>
            <div class="value" id="recipeServings">-</div>
          </div>
          <div class="recipe-field">
            <label>材料</label>
            <div id="flexibleIngredientsDisplay">
              <div class="ingredient-item">材料なし</div>
            </div>
            <div class="inline-actions" style="margin-top:.5rem; display:flex; justify-content:flex-end;">
              <button type="button" id="btnAddCategoryInline" class="btn secondary">カテゴリを追加</button>
              <button type="button" id="btnAddIngredientInline" class="btn secondary">材料を追加</button>
            </div>
          </div>
          <div class="recipe-field">
            <label>手順</label>
            <div class="steps-list" id="stepsList">
              <div class="step-item">手順なし</div>
            </div>
            <div class="inline-actions" style="margin-top:.5rem; display:flex; justify-content:flex-end;">
              <button type="button" id="btnAddStepInline" class="btn secondary">手順を追加</button>
            </div>
          </div>
        </div>
        
        <div class="translation-controls" id="translationControls" style="margin-top: 1rem; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
          <div class="translation-selector">
            <label for="targetLanguage">翻訳先言語:</label>
            <select id="targetLanguage" class="language-select">
              <option value="ja">🇯🇵 日本語 (Japanese)</option>
              <option value="en">🇺🇸 英語 (English)</option>
              <option value="fr">🇫🇷 フランス語 (Français)</option>
              <option value="it">🇮🇹 イタリア語 (Italiano)</option>
              <option value="de">🇩🇪 ドイツ語 (Deutsch)</option>
              <option value="es">🇪🇸 スペイン語 (Español)</option>
              <option value="ko">🇰🇷 韓国語 (한국어)</option>
              <option value="zh">🇨🇳 中国語 (中文)</option>
            </select>
          </div>
          <button type="button" id="translateButton" class="translate-btn">
            <i class="fa-solid fa-language"></i> <span id="translateButtonText">翻訳する</span>
          </button>
          <button type="button" id="btnApplyOriginalEdits" class="btn">
            編集内容を適用
          </button>
        </div>
      </div>

      

      <div class="result-section" id="translationSection" style="display: none;">
        <h3><i class="fa-solid fa-language"></i> <span id="translationSectionTitle">翻訳結果</span></h3>
        <div class="recipe-field" id="translatedRecipeImageContainer" style="display: none; margin-bottom: 1rem;">
          <label>画像</label>
          <img id="translatedRecipeImage" src="" alt="Translated Recipe Image" style="max-width: 100%; border-radius: 12px; margin-top: 0.5rem; border: 1px solid var(--border-color);">
        </div>
        <div class="recipe-preview" id="translatedRecipePreview">
          <div class="recipe-field">
            <label>タイトル</label>
            <div class="value" id="translatedRecipeTitle">-</div>
          </div>
          <div class="recipe-field">
            <label>説明</label>
            <div class="value" id="translatedRecipeDescription">-</div>
          </div>
          <div class="recipe-field">
            <label>人数</label>
            <div class="value" id="translatedRecipeServings">-</div>
          </div>
          <div class="recipe-field">
        <label>材料</label>
            <div id="flexibleTranslatedIngredientsDisplay">
              <div class="ingredient-item">翻訳なし</div>
            </div>
          </div>
          <div class="recipe-field">
            <label>手順</label>
            <div class="steps-list" id="translatedStepsList">
              <div class="step-item">翻訳なし</div>
            </div>
          </div>
        </div>
      </div>

      <!-- 保存モード選択＆保存エリア（iframe主体のテーブルUI） -->
      <div class="result-section" id="saveSection" style="display: none;">
        <h3><i class="fa-solid fa-save"></i> レシピを保存</h3>
        <table class="save-preview-table" style="width:100%; border-collapse:collapse; background: var(--bg-surface);">
          <thead>
            <tr>
              <th style="text-align:left; padding:.5rem; border-bottom:1px solid var(--border-color);">元ページプレビュー（右のフォームで即時修正→保存）</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="padding:.5rem;">
                <div style="display:flex; gap:.5rem; align-items:center;">
                  <input id="savePaneUrl" type="text" placeholder="URL (空なら上のURL欄を使用)" style="flex:1; min-width:220px; padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <button id="savePaneLoadBtn" type="button" class="btn">表示</button>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.25rem;">
                <iframe id="savePaneFrame" title="save pane preview" style="width:100%; height:420px; border:1px solid var(--border-color); display:block; background:white;"></iframe>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem;">
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.5rem;">
                  <input id="quickTitle" type="text" placeholder="タイトルを修正" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickServings" type="text" placeholder="人数（例: 4）" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickNotes" type="text" placeholder="メモ（任意）" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                </div>
                <div style="display:grid; grid-template-columns: 2fr 1fr 1fr auto; gap:.5rem; align-items:center; margin-top:.5rem;">
                  <input id="quickIngName" type="text" placeholder="材料名" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickIngQty" type="text" placeholder="分量" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <input id="quickIngUnit" type="text" placeholder="単位" style="padding:.4rem .6rem; border:1px solid var(--border-color); border-radius:8px;">
                  <button id="quickAddIng" type="button" class="btn">材料を追加</button>
                </div>
                <div style="margin-top:.5rem;">
                  <table id="quickIngTable" style="width:100%; border-collapse:collapse;">
                    <thead>
                      <tr>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">材料名</th>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">分量</th>
                        <th style="text-align:left; padding:.4rem; border-bottom:1px solid var(--border-color);">単位</th>
                        <th style="width:72px; padding:.4rem; border-bottom:1px solid var(--border-color);"></th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem;">
                <div id="saveModeGroup" style="display:flex; gap:.5rem; flex-wrap:wrap;">
                  <label style="display:flex; align-items:center; gap:.35rem; cursor:pointer;">
                    <input type="radio" name="saveMode" value="original" checked>
                    <span>原語のみ</span>
                  </label>
                  <label id="saveModeBothLabel" style="display:flex; align-items:center; gap:.35rem; opacity:.7; cursor:pointer;">
                    <input type="radio" name="saveMode" value="both" disabled>
                    <span>原語＋翻訳（両方）</span>
                  </label>
                  <label id="saveModeTranslatedLabel" style="display:flex; align-items:center; gap:.35rem; opacity:.7; cursor:pointer;">
                    <input type="radio" name="saveMode" value="translated" disabled>
                    <span>翻訳のみ</span>
                  </label>
                </div>
              </td>
            </tr>
            <tr>
              <td style="padding:.5rem; text-align:right;">
                <button type="button" id="saveByModeButton" class="btn primary">
                  <i class="fa-solid fa-circle-check"></i> 選択して保存
                </button>
              </td>
            </tr>
          </tbody>
        </table>
        <div style="margin-top:.5rem; color: var(--text-secondary); font-size:.9rem;">
          <span id="saveModeHint">保存モードを選択して「選択して保存」を押してください。</span>
        </div>
      </div>

    </div>
  </main>

  <!-- 画像解析モーダル -->
  <div id="image-import-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">画像からレシピを抽出</h2>
        <button id="image-import-modal-close-btn" class="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div class="image-upload-section" id="uploadArea">
          <div class="drag-overlay">
            <div>
              <i class="fas fa-download" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
              <div>画像をドロップしてください</div>
            </div>
          </div>
          <i class="fas fa-cloud-upload-alt" style="font-size: 3rem; color: #666; margin-bottom: 1rem;"></i>
          <p style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%;">レシピ画像をアップロードしてください</p>
          <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 1.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word; white-space: normal; max-width: 100%; line-height: 1.5;">
            画像をここにドラッグ&ドロップするか、下のボタンから選択してください
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
            <button type="button" id="fileSelectBtn" class="btn primary">
              <i class="fas fa-folder-open"></i> ファイルから選択
            </button>
            <button type="button" id="cameraBtn" class="btn secondary">
              <i class="fas fa-camera"></i> カメラで撮影
            </button>
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display: none;">
          <input type="file" id="cameraInput" accept="image/*" capture="user" style="display: none;">
        </div>
        
        <div id="previewArea" style="display: none; text-align: center; margin-top: 1rem;">
          <img id="previewImage" class="image-preview" alt="プレビュー" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
          <div style="margin-top: 1rem;">
            <button type="button" id="analyzeButton" class="btn" type="button">
              <i class="fas fa-search"></i> 解析してレシピを抽出
            </button>
            <button type="button" id="clearImageButton" class="btn ghost">
              <i class="fas fa-trash"></i> クリア
            </button>
          </div>
        </div>
        
        <div id="imageMessageArea" style="margin-top: 1rem;"></div>
      </div>
      <div class="modal-footer">
        <button id="imageImportCancelBtn" class="btn ghost" type="button">閉じる</button>
      </div>
    </div>
  </div>

  <script>
    const statusRow = document.getElementById('statusRow');
    const resultsGrid = document.getElementById('resultsGrid');
    const importButton = document.getElementById('importButton');
    const urlInput = document.getElementById('urlInput');
    const translateButton = document.getElementById('translateButton');
    const translationSection = document.getElementById('translationSection');
    const translationControls = document.getElementById('translationControls');
    const targetLanguageSelect = document.getElementById('targetLanguage');
    const translateButtonText = document.getElementById('translateButtonText');
    const translationSectionTitle = document.getElementById('translationSectionTitle');

    const LANGUAGE_METADATA = {
      ja: { label: '日本語', prompt: 'Japanese' },
      en: { label: '英語', prompt: 'English' },
      fr: { label: 'フランス語', prompt: 'French' },
      it: { label: 'イタリア語', prompt: 'Italian' },
      de: { label: 'ドイツ語', prompt: 'German' },
      es: { label: 'スペイン語', prompt: 'Spanish' },
      ko: { label: '韓国語', prompt: 'Korean' },
      zh: { label: '中国語', prompt: 'Chinese' }
    };

    const DEFAULT_TRANSLATION_LANGUAGE = 'en';

    const getLanguageLabel = (code) => LANGUAGE_METADATA[code]?.label || '選択言語';
    const getLanguagePromptName = (code) => LANGUAGE_METADATA[code]?.prompt || code;
    
    // 画像解析用の変数
    let currentFile = null;
    const imageImportBtn = document.getElementById('imageImportBtn');
    const imageModal = document.getElementById('image-import-modal');
    const imageModalCloseBtn = document.getElementById('image-import-modal-close-btn');
    const imageImportCancelBtn = document.getElementById('imageImportCancelBtn');
    const fileSelectBtn = document.getElementById('fileSelectBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const imageInput = document.getElementById('imageInput');
    const cameraInput = document.getElementById('cameraInput');
    const previewArea = document.getElementById('previewArea');
    const previewImage = document.getElementById('previewImage');
    const analyzeButton = document.getElementById('analyzeButton');
    const clearImageButton = document.getElementById('clearImageButton');
    const imageMessageArea = document.getElementById('imageMessageArea');
    
    let currentRecipeData = null;
    let isJapaneseContent = false;
    
    let sb;
    
    // Supabaseクライアントを初期化
    const initSupabase = () => {
      try {
        if (typeof supabase !== 'undefined' && window.APP_CONFIG) {
          sb = supabase.createClient(
            window.APP_CONFIG.SUPABASE_URL,
            window.APP_CONFIG.SUPABASE_ANON_KEY
          );
          console.log('✅ Supabaseクライアント初期化成功');
          return true;
        } else {
          console.error('❌ Supabase または APP_CONFIG が利用できません');
          return false;
        }
      } catch (error) {
        console.error('❌ Supabaseクライアント初期化エラー:', error);
        return false;
      }
    };

    function extractMainImageUrl(html, baseUrl) {
      try {
          const doc = new DOMParser().parseFromString(html, 'text/html');

          // 1. Check for Open Graph image
          const ogImage = doc.querySelector('meta[property="og:image"]');
          if (ogImage && ogImage.content) {
              return new URL(ogImage.content, baseUrl).href;
          }

          // 2. Check for Twitter Card image
          const twitterImage = doc.querySelector('meta[name="twitter:image"]');
          if (twitterImage && twitterImage.content) {
              return new URL(twitterImage.content, baseUrl).href;
          }

          // 3. Check for JSON-LD Recipe schema
          const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
          for (const script of jsonLdScripts) {
              try {
                  const jsonData = JSON.parse(script.textContent);
                  const findImage = (node) => {
                      if (node && (node['@type'] === 'Recipe' || (Array.isArray(node['@type']) && node['@type'].includes('Recipe')))) {
                          if (node.image) {
                              const image = Array.isArray(node.image) ? node.image[0] : node.image;
                              if (typeof image === 'string') return image;
                              if (image && image.url) return image.url;
                          }
                      }
                      return null;
                  };

                  let imageUrl = findImage(jsonData);
                  if (imageUrl) return new URL(imageUrl, baseUrl).href;

                  if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                      for (const node of jsonData['@graph']) {
                          imageUrl = findImage(node);
                          if (imageUrl) return new URL(imageUrl, baseUrl).href;
                      }
                  }
              } catch (e) {
                  console.warn('Error parsing JSON-LD', e);
              }
          }

          // 4. Fallback: Find the largest image in the body (heuristic)
          let largestImage = null;
          let maxDim = 0;
          const images = doc.body.getElementsByTagName('img');
          for (const img of images) {
              const width = parseInt(img.width || img.getAttribute('width') || '0', 10);
              const height = parseInt(img.height || img.getAttribute('height') || '0', 10);
              const dim = width * height;
              if (dim > maxDim) {
                  maxDim = dim;
                  largestImage = img;
              }
          }
          if (largestImage && largestImage.src) {
              // Ignore tiny images
              if (maxDim > 20000) { // e.g., > 200x100
                    return new URL(largestImage.src, baseUrl).href;
              }
          }

      } catch (error) {
          console.error('Error extracting main image:', error);
      }

      return null;
    }

    const setStatus = (message, type = 'info', icon = 'fa-spinner fa-spin') => {
      if (!message) {
        statusRow.textContent = '';
        statusRow.className = 'status';
        return;
      }
      
      statusRow.className = `status ${type}`;
      statusRow.innerHTML = `<i class="fa-solid ${icon}"></i><span>${message}</span>`;
    };

    // API選択の処理
    document.querySelectorAll('.api-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.api-option').forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        option.querySelector('input[type="radio"]').checked = true;
      });
    });

    // 例URL選択の処理
    document.querySelectorAll('.example-url').forEach(example => {
      example.addEventListener('click', () => {
        const url = example.dataset.url;
        urlInput.value = url;
        urlInput.focus();
      });
    });

    // ページ読み込み時にSupabaseを初期化
    window.addEventListener('load', () => {
      if (!initSupabase()) {
        setStatus('Supabaseクライアントの初期化に失敗しました', 'error', 'fa-triangle-exclamation');
      }
    });

    // 画像解析モーダルのイベントリスナー
    imageImportBtn.addEventListener('click', () => {
      imageModal.style.display = 'flex';
    });

    imageModalCloseBtn.addEventListener('click', closeImageModal);
    imageImportCancelBtn.addEventListener('click', closeImageModal);

    imageModal.addEventListener('click', (e) => {
      if (e.target === imageModal) {
        closeImageModal();
      }
    });

    fileSelectBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleNewInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleNewInputChange);
      newInput.addEventListener('input', handleNewInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    cameraBtn.addEventListener('click', () => {
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.accept = 'image/*';
      newInput.setAttribute('capture', 'user');
      newInput.style.position = 'absolute';
      newInput.style.left = '-9999px';
      newInput.style.top = '-9999px';
      newInput.style.opacity = '0';

      const handleCameraInputChange = (event) => {
        if (event.target.files && event.target.files.length > 0) {
          const file = event.target.files[0];
          handleFile(file);
        }
        setTimeout(() => {
          if (document.body.contains(newInput)) {
            document.body.removeChild(newInput);
          }
        }, 100);
      };

      newInput.addEventListener('change', handleCameraInputChange);
      newInput.addEventListener('input', handleCameraInputChange);

      document.body.appendChild(newInput);
      setTimeout(() => {
        newInput.click();
      }, 10);
    });

    analyzeButton.addEventListener('click', analyzeImage);
    clearImageButton.addEventListener('click', clearImage);

    // 言語選択の変更イベント
    targetLanguageSelect.addEventListener('change', updateTranslationUI);

    // ページ全体でのドラッグ&ドロップを防止
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    
    document.addEventListener('drop', (e) => {
      e.preventDefault();
    });

    // ドラッグ&ドロップイベントリスナー
    const uploadArea = document.getElementById('uploadArea');
    
    // ドラッグ&ドロップイベントの設定
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('dragenter', handleDragEnter);
    uploadArea.addEventListener('dragleave', handleDragLeave);
    uploadArea.addEventListener('drop', handleDrop);
    
    // クリックでファイル選択
    uploadArea.addEventListener('click', (e) => {
      // ボタンクリック時は除外
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
      }
      fileSelectBtn.click();
    });

    // ドラッグ&ドロップハンドラー関数
    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function handleDragEnter(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // 子要素から出た場合は無視
      if (!uploadArea.contains(e.relatedTarget)) {
        uploadArea.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      uploadArea.classList.remove('drag-over');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        
        // 画像ファイルかチェック
        if (file.type.startsWith('image/')) {
          handleFile(file);
        } else {
          showImageMessage('画像ファイルをドロップしてください', 'error');
        }
      }
    }

    function updateTranslationUI() {
      const selectedLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
      const languageName = getLanguageLabel(selectedLanguage);
      if (translateButtonText) {
        if (translateButton && !translateButton.contains(translateButtonText)) {
          translateButton.innerHTML = '<i class="fa-solid fa-language"></i> ';
          translateButton.appendChild(translateButtonText);
        }
        translateButtonText.textContent = `${languageName}に翻訳`;
      }
      translationSectionTitle.textContent = `${languageName}翻訳`;
    }

    function closeImageModal() {
      imageModal.style.display = 'none';
    }

    function handleFile(file) {
      if (!file || !file.type.startsWith('image/')) {
        showImageMessage('画像ファイルを選択してください', 'error');
        return;
      }

      currentFile = file;
      window.__ocrCurrentFile = file;
      window.currentImageFiles = [file];

      // プレビュー表示
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewArea.style.display = 'block';
        document.getElementById('uploadArea').style.display = 'none';
        analyzeButton.disabled = false;
      };
      reader.readAsDataURL(file);

      showImageMessage('画像が選択されました。「解析してレシピを抽出」ボタンをクリックしてください。', 'success');
    }

    function clearImage() {
      currentFile = null;
      window.__ocrCurrentFile = null;
      window.currentImageFiles = [];
      previewImage.src = '';
      previewArea.style.display = 'none';
      document.getElementById('uploadArea').style.display = 'block';
      analyzeButton.disabled = true;
      showImageMessage('', '');
    }

    function showImageMessage(message, type) {
      if (!message) {
        imageMessageArea.innerHTML = '';
        return;
      }

      const icons = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-triangle',
        info: 'fa-info-circle',
        loading: 'fa-spinner fa-spin'
      };

      const colors = {
        success: 'var(--success-color)',
        error: 'var(--error-color)',
        info: 'var(--accent-primary)',
        loading: 'var(--accent-primary)'
      };

      imageMessageArea.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; border-radius: 8px; background: ${colors[type] || colors.info}15; color: ${colors[type] || colors.info}; border: 1px solid ${colors[type] || colors.info}25;">
          <i class="fas ${icons[type] || icons.info}"></i>
          <span>${message}</span>
        </div>
      `;
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
        reader.readAsDataURL(file);
      });
    }

    function getActiveOcrFile() {
      if (currentFile instanceof File) {
        return currentFile;
      }
      if (window.__ocrCurrentFile instanceof File) {
        return window.__ocrCurrentFile;
      }
      if (Array.isArray(window.currentImageFiles) && window.currentImageFiles.length > 0) {
        const candidate = window.currentImageFiles.find(f => f instanceof File);
        if (candidate) {
          window.__ocrCurrentFile = candidate;
          currentFile = candidate;
          return candidate;
        }
      }
      return null;
    }

    async function analyzeWithAzureDocumentIntelligence(base64Payload, selectedProvider, providerInfo) {
      console.log('🛰️ Azure Document Intelligence呼び出し準備', { selectedProvider });

      const { data: docResult, error: docError } = await sb.functions.invoke('call-document-intelligence', {
        body: {
          image: base64Payload,
          processorType: 'RECIPE_PROCESSOR',
          aiProvider: selectedProvider
        }
      });

      if (docError) {
        console.error('❌ call-document-intelligence error:', docError);
        throw new Error(docError.message || docError.error || 'Azure Document Intelligence呼び出しに失敗しました');
      }

      if (!docResult?.success) {
        console.error('❌ call-document-intelligence response error:', docResult);
        throw new Error(docResult?.error || '画像解析に失敗しました');
      }

      const recipeData = docResult.data;
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('レシピデータが取得できませんでした');
      }

      recipeData.aiProvider = selectedProvider;
      recipeData.aiProviderModel = providerInfo?.model || null;

      console.log('📄 Azure + AI解析結果:', recipeData);
      return recipeData;
    }

    async function analyzeWithVisionFallback(base64Payload, fileType, selectedProvider, providerInfo) {
      const mimeType = fileType || 'image/png';
      console.log('🛰️ Gemini Visionフォールバック開始', { selectedProvider, mimeType });

      const { data: visionResult, error: visionError } = await sb.functions.invoke('call-vision-api', {
        body: {
          contents: [{
            parts: [
              {
                text: 'Extract all text from this recipe image. Preserve Japanese characters, numbers, and line breaks as they appear.'
              },
              {
                inline_data: {
                  mime_type: mimeType,
                  data: base64Payload
                }
              }
            ]
          }]
        }
      });

      if (visionError) {
        console.error('❌ call-vision-api error:', visionError);
        throw new Error(visionError.message || visionError.error || 'Gemini Vision呼び出しに失敗しました');
      }

      const extractedTextParts = visionResult?.candidates?.[0]?.content?.parts || [];
      const extractedText = extractedTextParts
        .map(part => part?.text || '')
        .filter(Boolean)
        .join('\n')
        .trim();

      if (!extractedText) {
        console.error('❌ Gemini Visionから有効なテキストが取得できませんでした:', visionResult);
        throw new Error('Gemini Visionからテキストを取得できませんでした');
      }

      console.log('📝 Gemini Vision抽出テキスト(冒頭):', extractedText.substring(0, 200));

      // 抽出したテキストをAI解析システムに送る
      const selectedApi = document.querySelector('input[name="api"]:checked').value;
      const recipeData = await analyzeRecipeWithAI(extractedText, null, selectedApi);
      
      if (!recipeData || typeof recipeData !== 'object') {
        throw new Error('AI解析結果が無効です');
      }
      
      recipeData.aiProvider = recipeData.aiProvider || selectedProvider;
      recipeData.aiProviderModel = recipeData.aiProviderModel || providerInfo?.model || null;
      
      console.log('✅ Gemini Vision + AI解析成功:', {
        provider: recipeData.aiProvider,
        ingredients: recipeData.ingredients?.length || 0,
        steps: recipeData.steps?.length || 0
      });
      
      return recipeData;
    }

    async function analyzeImage() {
      console.log('🔍 analyzeImage function called');
      const activeFile = getActiveOcrFile();
      
      if (!activeFile) {
        console.error('❌ No currentFile available');
        showImageMessage('画像を選択してください', 'error');
        return;
      }

      showImageMessage('AzureでOCR解析を開始しました...', 'loading');
      analyzeButton.disabled = true;

      try {
        const base64 = await fileToBase64(activeFile);
        console.log('✅ Base64 conversion completed, size:', base64.length);
        const base64Payload = base64.includes(',') ? base64.split(',')[1] : base64;

        const selectedApi = document.querySelector('input[name="api"]:checked').value;
        const providerInfo = { key: selectedApi };
        console.log('🤖 Selected AI provider:', selectedApi);

        let recipeData = null;
        let analysisSource = '';

        try {
          showImageMessage(`AzureでOCR後、${selectedApi.toUpperCase()}で解析中...`, 'loading');
          recipeData = await analyzeWithAzureDocumentIntelligence(base64Payload, selectedApi, providerInfo);
          analysisSource = `Azure Document Intelligence + ${selectedApi.toUpperCase()}`;
        } catch (azureError) {
          console.warn('⚠️ Azure Document Intelligence解析に失敗しました。Gemini Visionフォールバックを試みます。', azureError);
          showImageMessage('Azure解析に失敗したため、Gemini Visionに切り替えています...', 'info');

          try {
            recipeData = await analyzeWithVisionFallback(base64Payload, activeFile.type, selectedApi, providerInfo);
            analysisSource = `Gemini Vision + ${selectedApi.toUpperCase()}`;
          } catch (fallbackError) {
            console.error('❌ Gemini Visionフォールバックも失敗しました', fallbackError);
            throw fallbackError;
          }
        }

        if (!recipeData || typeof recipeData !== 'object') {
          throw new Error('レシピデータが取得できませんでした');
        }

        console.log(`📄 解析結果 (${analysisSource}):`, recipeData);
        
        // 結果を表示
        displayRecipeResults(recipeData, analysisSource);
        showImageMessage('画像解析が完了しました！', 'success');
        closeImageModal();

      } catch (error) {
        console.error('❌ 画像解析エラー:', error);
        showImageMessage('画像解析に失敗しました: ' + (error.message || error), 'error');
      } finally {
        analyzeButton.disabled = !currentFile;
      }
    }

    // 翻訳に不要な一時フィールドを取り除き、APIが期待する形に整える
    function sanitizeRecipeForTranslation(data) {
      const src = data || {};
      const out = {
        title: src.title || '',
        description: src.description || '',
        servings: src.servings || '',
        image_url: src.image_url || '',
        ingredients: Array.isArray(src.ingredients) ? src.ingredients
          .filter(i => i && (i.item || i.name || i.quantity || i.unit))
          .map(i => {
            const sectionScoped = i?.sectionTitle || i?.section_title;
            const normalizedSection = sectionScoped ? sectionScoped.toString().trim() : '';
            return {
              item: (i.item || i.name || '').toString().trim(),
              quantity: (i.quantity || i.amount || '').toString().trim(),
              unit: (i.unit || i.measure || '').toString().trim(),
              ...(normalizedSection ? { sectionTitle: normalizedSection } : {})
            };
          }) : [],
        steps: Array.isArray(src.steps) ? src.steps.map(s =>
          typeof s === 'string' ? s : (s.step || s.instruction || s.text || '')
        ) : []
      };
      return out;
    }

    function normalizeSectionTitleValue(value) {
      if (value === undefined || value === null) return '';
      if (typeof value === 'string') return value.trim();
      return String(value).trim();
    }

    function ensureIngredientSectionTitles(sourceIngredients, translatedIngredients) {
      if (!Array.isArray(translatedIngredients)) return [];
      const sourceSections = Array.isArray(sourceIngredients)
        ? sourceIngredients.map(src => normalizeSectionTitleValue(src?.sectionTitle))
        : [];
      return translatedIngredients.map((ing, index) => {
        let out = ing;
        if (!out || typeof out !== 'object') {
          out = { item: typeof ing === 'string' ? ing : '' };
        } else {
          out = { ...out };
        }
        const translatedSection = normalizeSectionTitleValue(out.sectionTitle || out.section_title);
        const sourceSection = sourceSections[index] || '';
        const finalSection = translatedSection || sourceSection;
        if (finalSection) {
          out.sectionTitle = finalSection;
        } else if (out.sectionTitle) {
          out.sectionTitle = normalizeSectionTitleValue(out.sectionTitle);
        }
        if ('section_title' in out) {
          delete out.section_title;
        }
        return out;
      });
    }

    function extractTranslatedIngredients() {
      const rows = document.querySelectorAll('#flexibleTranslatedIngredientsDisplay table tbody tr');
      if (rows.length === 0) {
        const sectionBlocks = document.querySelectorAll('#flexibleTranslatedIngredientsDisplay .recipe-section');
        if (sectionBlocks.length > 0) {
          const list = [];
          sectionBlocks.forEach(section => {
            const sectionTitle = (section.querySelector('.recipe-section-title')?.textContent || '').trim();
            const grids = section.querySelectorAll('.recipe-ingredients-grid');
            grids.forEach(grid => {
              const item = (grid.querySelector('.ingredient-name')?.textContent || '').trim();
              const quantity = (grid.querySelector('.ingredient-quantity')?.textContent || '').trim();
              const unit = (grid.querySelector('.ingredient-unit')?.textContent || '').trim();
              if (!item && !quantity && !unit) return;
              list.push({ item, quantity, unit, sectionTitle });
            });
          });
          return list;
        }
      }

      return Array.from(rows).map(row => {
        const tds = row.querySelectorAll('td');
        if (tds.length >= 4) {
          return {
            item: tds[1].textContent.trim(),
            quantity: tds[2].textContent.trim(),
            unit: tds[3].textContent.trim()
          };
        }
        return null;
      }).filter(v => v && v.item && v.item !== '翻訳なし');
    }

    function extractTranslatedSteps() {
      const translatedStepsElements = document.querySelectorAll('#translatedStepsList .step-text, #translatedStepsList .step-item');
      return Array.from(translatedStepsElements)
        .map(el => el.textContent.replace(/^\d+\.?\s*/, '').trim())
        .filter(step => step && step !== '翻訳なし' && step !== '手順なし');
    }

    // 翻訳ボタンのイベントリスナー
    translateButton.addEventListener('click', async () => {
      // 直前の編集を同期
      try { syncCurrentRecipeFromDOM({ showAlert: false }); } catch (_) {}
      if (!currentRecipeData) {
        setStatus('翻訳するレシピデータがありません', 'error', 'fa-triangle-exclamation');
        return;
      }

      translateButton.disabled = true;
      translateButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> 翻訳中...';

      try {
        const payload = sanitizeRecipeForTranslation(currentRecipeData);
        console.log('🌐 翻訳開始（サニタイズ後）:', payload);
        const activeLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
        console.log('🌐 選択された言語:', activeLanguage);
        console.log('🌐 現在のレシピデータ構造:', {
          hasTitle: !!payload?.title,
          hasDescription: !!payload?.description,
          hasIngredients: !!payload?.ingredients,
          hasSteps: !!payload?.steps,
          ingredientsCount: payload?.ingredients?.length || 0,
          stepsCount: payload?.steps?.length || 0
        });
        
        const translatedData = await translateRecipeData(payload);
        console.log('✅ 翻訳完了:', translatedData);
        console.log('✅ 翻訳データの型:', typeof translatedData);
        console.log('✅ 翻訳データのキー:', Object.keys(translatedData || {}));
        
        console.log('🖼️ 翻訳結果表示開始...');
        displayTranslatedResults(translatedData);
        console.log('🖼️ 翻訳結果表示完了');
        
        // レイアウトを3カラムに変更
        console.log('🎨 レイアウト変更開始...');
        resultsGrid.classList.add('with-translation');
        translationSection.style.display = 'block';
        // 翻訳後に保存モードを有効化
        try { showSaveButtons(); } catch (e) { console.debug('showSaveButtons not ready'); }
        console.log('🎨 レイアウト変更完了');
        
        const selectedLanguage = activeLanguage;
        const languageName = getLanguageLabel(selectedLanguage);
        translateButton.innerHTML = `<i class="fa-solid fa-check"></i> ${languageName}翻訳完了`;
        console.log('✅ 翻訳処理全体完了');
        
      } catch (error) {
        console.error('❌ 翻訳エラー:', error);
        setStatus(`翻訳エラー: ${error.message}`, 'error', 'fa-triangle-exclamation');
        updateTranslationUI();
      } finally {
        translateButton.disabled = false;
      }
    });

    // レシピ取得フォームの処理
    document.getElementById('importForm').addEventListener('submit', async (event) => {
      event.preventDefault();

      if (!sb) {
        if (!initSupabase()) {
          setStatus('Supabaseクライアントが利用できません', 'error', 'fa-triangle-exclamation');
          return;
        }
      }

      const url = urlInput.value.trim();
      const selectedApi = document.querySelector('input[name="api"]:checked').value;

      if (!url) {
        setStatus('URLを入力してください', 'error', 'fa-circle-exclamation');
        return;
      }

      // URLの妥当性をチェック
      try {
        new URL(url);
      } catch (urlError) {
        setStatus('有効なURLを入力してください', 'error', 'fa-circle-exclamation');
        return;
      }

      resultsGrid.hidden = true;
      setStatus('HTMLを取得中です...', 'info', 'fa-spinner fa-spin');
      importButton.disabled = true;

      try {
        const startTime = Date.now();
        console.log('🚀 レシピ取得開始:', { url, selectedApi });
        
        // ステップ1: HTMLを取得
        setStatus('Webサイトからコンテンツを取得中...', 'info', 'fa-spinner fa-spin');
        const htmlData = await fetchHtmlFromUrl(url);
        
        if (!htmlData || !htmlData.html) {
          throw new Error('Webサイトのコンテンツを取得できませんでした');
        }
        
        console.log('✅ HTML取得完了:', htmlData.html.length, '文字');

        const imageUrl = extractMainImageUrl(htmlData.html, url);
        console.log('🖼️ Extracted image URL:', imageUrl);
        
        // ステップ2: AI解析
        setStatus(`${selectedApi.toUpperCase()} APIでレシピを解析中...`, 'info', 'fa-spinner fa-spin');
        const recipeData = await analyzeRecipeWithAI(htmlData.html, url, selectedApi);

        if (imageUrl) {
            recipeData.image_url = imageUrl;
        }
        
        console.log('✅ AI解析完了:', recipeData);
        
        // URLを記録（翻訳時に参照するため）
        window.lastProcessedUrl = url;
        
        // 結果を表示
        displayRecipeResults(recipeData, { 
          url, 
          selectedApi, 
          htmlLength: htmlData.html.length,
          processingTime: Date.now() - startTime
        });
        
        resultsGrid.hidden = false;
        setStatus('レシピの取得が完了しました！', 'success', 'fa-circle-check');
        
      } catch (err) {
        console.error('❌ レシピ取得エラー:', err);
        setStatus(`エラー: ${err.message}`, 'error', 'fa-triangle-exclamation');
        
        resultsGrid.hidden = false;
      } finally {
        importButton.disabled = false;
      }
    });

    // HTMLを取得する関数
    async function fetchHtmlFromUrl(url) {
      const { data, error } = await sb.functions.invoke('fetch-url-content', {
        body: { url }
      });

      if (error) {
        throw new Error(`HTML取得エラー: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || 'HTML取得に失敗しました');
      }

      return data;
    }

    // AIでレシピを解析する関数
    async function analyzeRecipeWithAI(html, url, apiType) {
      // サイトの言語を判定
      const siteLanguage = detectSiteLanguage(html, url);
      console.log('🌐 サイト言語判定:', siteLanguage);
      
      let functionName;
      let requestBody;
      
      // クリーンアップされたHTMLを取得
      const cleanedHtml = cleanHtml(html, url);
      
      switch (apiType) {
        case 'groq':
          functionName = 'call-groq-api';
          requestBody = {
            text: generateRecipeExtractionPrompt(cleanedHtml, url, siteLanguage),
            mode: 'recipe_extraction',
            siteLanguage: siteLanguage.code,
            isJapaneseSite: siteLanguage.isJapanese
          };
          break;
        case 'chatgpt':
          functionName = 'call-chatgpt-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        case 'gemini':
          functionName = 'call-gemini-api';
          requestBody = {
            text: cleanHtml(html, url).substring(0, 8000),
            url: url
          };
          break;
        default:
          throw new Error(`未対応のAPI: ${apiType}`);
      }

      console.log(`🤖 ${apiType.toUpperCase()} API呼び出し開始:`, { functionName, bodyLength: JSON.stringify(requestBody).length });
      
      const { data, error } = await sb.functions.invoke(functionName, {
        body: requestBody
      });

      console.log(`📡 ${apiType.toUpperCase()} APIレスポンス:`, { data, error });

      if (error) {
        throw new Error(`AI解析エラー: ${error.message}`);
      }

      // Groq APIの場合のレスポンス処理
      if (apiType === 'groq') {
        if (!data.success) {
          throw new Error(data.error || 'Groq API呼び出しに失敗しました');
        }
        
        // Groq APIのcontentからJSONを抽出（改良版）
        const content = data.content || '';
        console.log('🔍 Groq APIコンテンツ（全体）:', content);
        console.log('🔍 Groq APIコンテンツ（プレビュー）:', content.substring(0, 500) + '...');
        
        try {
          // 複数のJSON抽出パターンを試行
          let recipeData = null;
          
          // パターン1: 完全なJSONオブジェクト
          try {
            const fullJsonMatch = content.match(/\{[\s\S]*\}/);
            if (fullJsonMatch) {
              console.log('🔍 パターン1: 完全JSON抽出試行');
              const jsonString = fullJsonMatch[0];
              console.log('📝 抽出されたJSON:', jsonString.substring(0, 300) + '...');
              
              // JSON修正を適用
              const fixedJson = fixMalformedJson(jsonString);
              recipeData = JSON.parse(fixedJson);
              console.log('✅ パターン1成功:', recipeData.title);
            }
          } catch (e) {
            console.log('❌ パターン1失敗:', e.message);
          }
          
          // パターン2: ```json```ブロック
          if (!recipeData) {
            try {
              const codeBlockMatch = content.match(/```json\s*([\s\S]*?)\s*```/i);
              if (codeBlockMatch) {
                console.log('🔍 パターン2: コードブロック抽出試行');
                const fixedJson = fixMalformedJson(codeBlockMatch[1]);
                recipeData = JSON.parse(fixedJson);
                console.log('✅ パターン2成功:', recipeData.title);
              }
            } catch (e) {
              console.log('❌ パターン2失敗:', e.message);
            }
          }
          
          // パターン3: 行ごとの解析
          if (!recipeData) {
            try {
              console.log('🔍 パターン3: 行ごと解析試行');
              const lines = content.split('\n');
              const jsonLines = lines.filter(line => 
                line.trim().startsWith('{') || 
                line.includes('"title"') || 
                line.includes('"ingredients"') ||
                line.includes('"steps"')
              );
              
              if (jsonLines.length > 0) {
                const jsonString = jsonLines.join('\n');
                const fixedJson = fixMalformedJson(jsonString);
                recipeData = JSON.parse(fixedJson);
                console.log('✅ パターン3成功:', recipeData.title);
              }
            } catch (e) {
              console.log('❌ パターン3失敗:', e.message);
            }
          }
          
          if (recipeData) {
            console.log('✅ レシピデータ解析成功:', recipeData);
            // Recipe Keeper.app風のデータ正規化
            return normalizeRecipeData(recipeData);
          } else {
            console.log('🔄 フォールバック解析を開始');
            return fallbackAnalysis(content, url);
          }
        } catch (parseError) {
          console.error('❌ JSON解析エラー:', parseError);
          console.log('📝 生のコンテンツ（全体）:', content);
          throw new Error(`レシピデータの解析に失敗しました: ${parseError.message}`);
        }
      }

      // ChatGPT/Gemini APIの場合
      if (data.ok && data.recipeData) {
        return data.recipeData;
      } else if (data.recipeData) {
        return data.recipeData;
      } else {
        throw new Error(data.error || 'AI解析に失敗しました');
      }
    }

    // レシピ抽出用のプロンプトを生成
    function generateRecipeExtractionPrompt(cleanedText, url) {
      const isJapaneseSite = url && (
        url.includes('.jp') ||
        url.includes('japanese') ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(url) ||
        /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText.substring(0, 1000))
      );

      const prompt = isJapaneseSite ? 
        `レシピ情報を抽出。ナビ・広告・SNS埋め込み・関連記事を無視し、本文のみ処理。

★★★CRITICAL: titleフィールドには元ページの料理名を一字一句そのままコピーしてください。絶対に翻訳、変更、解釈しないでください★★★

URL: ${url || '不明'}
テキスト: ${cleanedText.substring(0, 4000)}

JSON形式で返す:
{
  "title": "【ここに元ページの料理名をそのままコピペ】",
  "description": "レシピ説明",
  "servings": "人数（数字のみ）",
  "ingredients": [
    {"item": "材料名", "quantity": "分量（数字または適量・少々・ひとつまみ・お好みで等の曖昧な表現）", "unit": "単位（g、ml、個、枚、本、束、大さじ、小さじ、カップ等、曖昧な表現の場合は空文字）"}
  ],
  "steps": [
    {"step": "詳細な手順内容（工程名だけでなく、具体的な調理方法、温度、時間、注意点を含む完全な手順）"}
  ],
  "notes": "メモ",
  "image_url": "【レシピのメイン画像URL（wp-content/uploads等の実際の料理画像を優先、見つからない場合は空文字）】"
}

重要: 
1. 日本語コンテンツは翻訳せずそのまま抽出してください。
2. 手順は工程名だけでなく、具体的な調理方法、温度、時間、材料の使用量、注意点を含む完全な内容を抽出してください。
3. 複数の工程がある場合は、各工程の詳細な手順をすべて含めてください。
4. 「①白ネギのコンフィを作る」のようなタイトルだけでなく、「白ネギの青い部分を切り落とし、白い部分をよく洗う。オリーブオイル、ニンニク、タイム、ローリエ、塩2ｇと一緒に真空包装し、15分間スチームコンベクションオーブンのバプールモードで加熱する。」のような具体的な内容を抽出してください。

5. 材料の分量処理:
   - 曖昧な表現（「適量」「少々」「ひとつまみ」「お好みで」）→ quantityに入れ、unitは空文字
   - 数値付き単位（「大さじ3」「小さじ2」「1個」）→ 変換ルールに従って数値と単位を分離
   - 例: 「大さじ3」→ {"quantity": "45", "unit": "ml"} (液体の場合) または {"quantity": "45", "unit": "g"} (固体の場合)

変換ルール: 
- 大さじ1=15ml（液体）または15g（固体）
- 小さじ1=5ml（液体）または5g（固体）
- カップ1=200ml
- 液体材料（水、油、醤油、酒、酢、みりん、牛乳、だし、スープ、ソース、生クリーム等）=ml
- 固体材料（粉類、砂糖、塩、スパイス等）=g
- 「大さじ3」→「45」「ml」または「45」「g」に変換
- 「小さじ2」→「10」「ml」または「10」「g」に変換
- 数値と単位を必ず分離してください

JSONのみ返す。` :
        `Extract recipe information from this webpage content. Ignore navigation, ads, social media embeds, and related articles. Focus only on the main recipe content.

URL: ${url || 'Unknown'}
Text: ${cleanedText.substring(0, 4000)}

Return in JSON format:
{
  "title": "Recipe title (keep original language)",
  "description": "Recipe description",
  "servings": "Number of servings",
  "ingredients": [
    {"item": "Ingredient name", "quantity": "Amount (numbers or vague expressions like 'to taste', 'a pinch', 'as needed')", "unit": "Unit (g, ml, pieces, etc., empty string for vague expressions)"}
  ],
  "steps": [
    {"step": "Detailed cooking step (not just titles, but complete instructions including specific cooking methods, temperatures, times, ingredient amounts, and important notes)"}
  ],
  "notes": "Additional notes",
  "image_url": "Main recipe image URL"
}

Important:
1. Extract complete step instructions, not just titles or section names.
2. Include specific cooking methods, temperatures, times, ingredient amounts, and important notes for each step.
3. For complex recipes with multiple processes, include detailed instructions for each process.
4. Instead of just "① Make white leek confit", extract the full content like "Cut off the green parts of the white leeks and wash the white parts well. Vacuum pack with olive oil, garlic, thyme, bay leaves, and 2g salt, then heat in steam convection oven vapor mode for 15 minutes."
5. Ingredient quantity processing:
   - Vague expressions ("to taste", "a pinch", "as needed") → put in quantity field, leave unit empty
   - Numeric units ("3 tbsp", "2 tsp", "1 piece") → convert according to rules and separate numbers and units
   - Example: "3 tbsp" → {"quantity": "45", "unit": "ml"} (for liquids) or {"quantity": "45", "unit": "g"} (for solids)

Conversion rules:
- 1 tbsp = 15ml (liquid) or 15g (solid)
- 1 tsp = 5ml (liquid) or 5g (solid)  
- 1 cup = 200ml
- Liquid ingredients (water, oil, soy sauce, wine, vinegar, mirin, milk, broth, soup, sauce, cream, etc.) = ml
- Solid ingredients (flour, sugar, salt, spices, etc.) = g
- "3 tbsp" → "45" "ml" or "45" "g"
- "2 tsp" → "10" "ml" or "10" "g"
- Always separate numbers and units

Return only JSON.`;

      return prompt;
    }

    // HTMLをクリーニングする関数（日本語対応強化版）
    function cleanHtml(html, url) {
      console.log('🧹 HTMLクリーニング開始:', {
        originalLength: html.length,
        url: url,
        hasJapanese: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(html)
      });
      
      // 日本語サイトかどうかを判定
      const isJapaneseSite = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com') || 
        url.includes('delishkitchen.tv')
      );
      
      // HTMLタグを除去（日本語文字は保護）
      let text = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
      text = text.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
      text = text.replace(/<nav[^>]*>[\s\S]*?<\/nav>/gi, '');
      text = text.replace(/<header[^>]*>[\s\S]*?<\/header>/gi, '');
      text = text.replace(/<footer[^>]*>[\s\S]*?<\/footer>/gi, '');
      text = text.replace(/<aside[^>]*>[\s\S]*?<\/aside>/gi, '');
      text = text.replace(/<!--[\s\S]*?-->/g, '');
      
      // HTMLエンティティをデコード（日本語文字化け対策）
      text = text.replace(/&nbsp;/g, ' ');
      text = text.replace(/&amp;/g, '&');
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      text = text.replace(/&quot;/g, '"');
      text = text.replace(/&#39;/g, "'");
      text = text.replace(/&hellip;/g, '…');
      text = text.replace(/&yen;/g, '¥');
      
      // HTMLタグを除去
      text = text.replace(/<[^>]+>/g, ' ');
      
      // 日本語サイトの場合の特別処理
      if (isJapaneseSite) {
        console.log('🇯🇵 日本語サイト特別処理適用');
        // 日本語レシピサイト特有のパターンを整理
        text = text
          .replace(/材料\s*[:：]\s*/g, '\n材料：\n')
          .replace(/作り方\s*[:：]\s*/g, '\n作り方：\n')
          .replace(/手順\s*[:：]\s*/g, '\n手順：\n')
          .replace(/(\d+)\s*[．.]\s*/g, '\n$1. ');
      }
      
      // 複数の空白を整理（日本語の文字間は保護）
      text = text.replace(/[ \t]+/g, ' ');
      text = text.replace(/\n\s*\n/g, '\n');
      
      // 日本語文字を含む場合は文字フィルタリングを緩和
      if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)) {
        console.log('🇯🇵 日本語文字検出 - 文字フィルタリングを緩和');
        // 日本語文字、英数字、基本的な記号のみ許可
        text = text.replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F\u2000-\u206F\u2070-\u209F\u20A0-\u20CF\u2100-\u214F\u2150-\u218F\u2190-\u21FF\u2200-\u22FF\u2300-\u23FF\u2400-\u243F\u2440-\u245F\u2460-\u24FF\u2500-\u257F\u2580-\u259F\u25A0-\u25FF\u2600-\u26FF\u2700-\u27BF]/g, '');
      } else {
        // 英語サイトの場合は従来通り
        text = text.replace(/[^\w\s\u0020-\u007E\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/g, '');
      }
      
      const cleanedText = text.trim();
      
      console.log('🧹 HTMLクリーニング完了:', {
        originalLength: html.length,
        cleanedLength: cleanedText.length,
        isJapaneseSite: isJapaneseSite,
        hasJapaneseAfterCleaning: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(cleanedText),
        preview: cleanedText.substring(0, 200) + '...'
      });
      
      return cleanedText;
    }

    function renderSteps(container, steps, isEditable) {
      if (!container) return;
      container.innerHTML = '';
      if (steps && steps.length > 0) {
        steps.forEach((step, index) => {
          const item = document.createElement('div');
          item.className = 'step-item';
          const stepText = typeof step === 'string' ? step : (step.step || step.instruction || step.text || '');
          item.textContent = `${index + 1}. ${stepText}`;
          if (isEditable) {
            item.setAttribute('data-step-index', String(index));
            item.contentEditable = 'true';
            item.spellcheck = false;
          }
          container.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'step-item';
        item.textContent = '手順なし';
        container.appendChild(item);
      }
      if (isEditable) {
        enableInlineStepsEditing(container.id);
      }
    }

    // レシピ結果を表示する関数
    function displayRecipeResults(recipeData, context) {
      console.log('Displaying results:', { recipeData, context });
      resultsGrid.hidden = false;
      currentRecipeData = recipeData;

      // 画像の表示
      const imageContainer = document.getElementById('recipeImageContainer');
      const recipeImage = document.getElementById('recipeImage');
      const imageUrlInput = document.getElementById('recipeImageUrlInput');
      if (recipeData.image_url) {
        recipeImage.src = recipeData.image_url;
        imageUrlInput.value = recipeData.image_url;
        imageContainer.style.display = 'block';
      } else {
        imageContainer.style.display = 'none';
      }

      document.getElementById('recipeTitle').textContent = recipeData.title || '-';
      document.getElementById('recipeDescription').textContent = recipeData.description || '-';
      document.getElementById('recipeServings').textContent = recipeData.servings || '-';

      displayFlexibleIngredients(recipeData, 'flexibleIngredientsDisplay', context.url);
      renderSteps(document.getElementById('stepsList'), recipeData.steps || [], true);

      // 翻訳UIの表示制御
      const isJapanese = containsJapanese(JSON.stringify(recipeData));
      translationControls.style.display = isJapanese ? 'none' : 'flex';
      if (!isJapanese) {
        updateTranslationUI();
      }
      
      // 翻訳済みセクションを隠す
      translationSection.style.display = 'none';
      resultsGrid.classList.remove('with-translation');
    }

    // 日本語コンテンツかどうかを判定
    function detectJapaneseContent(recipeData, url) {
      // URLから判定
      if (url && (url.includes('.jp') || url.includes('japanese') || url.includes('japan'))) {
        return true;
      }
      
      // テキスト内容から判定
      const textToCheck = [
        recipeData.title || '',
        recipeData.description || '',
        ...(recipeData.ingredients || []).map(ing => ing.item || ''),
        ...(recipeData.steps || []).map(step => typeof step === 'object' ? step.step : step || '')
      ].join(' ');
      
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      return japaneseRegex.test(textToCheck);
    }

    // 単位を正規化する関数
    function normalizeUnit(unit) {
      if (!unit) return '';
      
      const unitStr = unit.toString().toLowerCase().trim();
      
      // 重複する単位を統一
      const unitMappings = {
        // グラム系
        'grammes': 'g',
        'gramme': 'g',
        'gram': 'g',
        'grams': 'g',
        'グラム': 'g',
        
        // ミリリットル系
        'millilitres': 'ml',
        'millilitre': 'ml',
        'milliliter': 'ml',
        'milliliters': 'ml',
        'ミリリットル': 'ml',
        
        // キログラム系
        'kilogrammes': 'kg',
        'kilogramme': 'kg',
        'kilogram': 'kg',
        'kilograms': 'kg',
        'キログラム': 'kg',
        
        // リットル系
        'litres': 'l',
        'litre': 'l',
        'liter': 'l',
        'liters': 'l',
        'リットル': 'l',
        
        // その他の単位
        'cuillères à soupe': 'tbsp',
        'cuillère à soupe': 'tbsp',
        'cuillères à café': 'tsp',
        'cuillère à café': 'tsp',
        'grandes cuillères': 'tbsp',
        'petites cuillères': 'tsp',
        '大さじ': 'tbsp',
        '小さじ': 'tsp',
        'カップ': 'cup',
        '個': '個',
        'pièce': '個',
        'pièces': '個',
        'pinch': 'つまみ',
        'pincée': 'つまみ',
        'une pincée': 'つまみ'
      };
      
      // マッピングがある場合は変換、ない場合はそのまま
      return unitMappings[unitStr] || unit;
    }

    // 不正なJSONを修正する関数
    function fixMalformedJson(jsonString) {
      try {
        // 基本的なクリーニング
        let fixed = jsonString.trim();
        
        console.log('🔧 JSON修正開始:', {
          original: fixed.substring(0, 200) + '...',
          length: fixed.length
        });
        
        // 不完全な文字列を修正
        // 例: "title": "Glissez cet ingrédient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique",+ → 修正
        fixed = fixed.replace(/",\+/g, '"');
        fixed = fixed.replace(/",\s*\+/g, '"');
        
        // 不正な文字列の終端パターンを修正
        // 例: "description":"L"... → "description":"L..."
        fixed = fixed.replace(/"([^"]*)"\.\.\.([^"}]*)/g, '"$1...$2"');
        
        // 不完全な文字列（引用符が閉じられていない）を修正
        // 例: "title":"Glissez cet ingrédient dans votre quiche lorraine si vous souhaitez obtenir la recette authentique → 修正
        const unclosedStringMatch = fixed.match(/"[^"]*":\s*"[^"]*$/);
        if (unclosedStringMatch) {
          fixed = fixed + '"';
          console.log('🔧 不完全な文字列を修正');
        }
        
        // 配列の修正を強化
        // 不完全な配列項目を修正: {"item": "name", "quantity": "123", "unit": "g → 完全な形に
        fixed = fixed.replace(/\{\s*"item"\s*:\s*"[^"]*"\s*,\s*"quantity"\s*:\s*"[^"]*"\s*,\s*"unit"\s*:\s*"[^"]*$/g, (match) => {
          console.log('🔧 不完全な配列項目を修正:', match);
          return match + '"}';
        });
        
        // 配列の終端修正: [..., → [...]
        fixed = fixed.replace(/,(\s*\])/g, '$1');
        
        // オブジェクトの終端修正: {..., → {...}
        fixed = fixed.replace(/,(\s*\})/g, '$1');
        
        // 不完全な配列を修正
        // "ingredients": [{"item": "name"}, {"item": "name2" → "ingredients": [{"item": "name"}, {"item": "name2"}]
        const incompleteArrayMatch = fixed.match(/"ingredients"\s*:\s*\[[^\]]*$/);
        if (incompleteArrayMatch) {
          console.log('🔧 不完全な配列を検出:', incompleteArrayMatch[0]);
          // 最後の完全なオブジェクトを見つけて配列を閉じる
          const lastCompleteObject = fixed.match(/.*\{[^}]*\}/);
          if (lastCompleteObject) {
            fixed = lastCompleteObject[0] + ']';
            console.log('🔧 配列を強制終了');
          }
        }
        
        // 不完全な手順配列を修正
        const incompleteStepsMatch = fixed.match(/"steps"\s*:\s*\[[^\]]*$/);
        if (incompleteStepsMatch) {
          console.log('🔧 不完全な手順配列を検出');
          // 最後の完全な文字列を見つけて配列を閉じる
          const lastCompleteStep = fixed.match(/.*"[^"]*"/);
          if (lastCompleteStep) {
            fixed = lastCompleteStep[0] + ']';
            console.log('🔧 手順配列を強制終了');
          }
        }
        
        // 不完全なオブジェクトの終端を修正
        if (!fixed.endsWith('}') && !fixed.endsWith(']')) {
          console.log('🔧 不完全なオブジェクト終端を検出');
          
          // 最後の完全なプロパティを見つける
          const patterns = [
            /"[^"]*":\s*"[^"]*"/, // "key": "value"
            /"[^"]*":\s*\[[^\]]*\]/, // "key": [array]
            /"[^"]*":\s*\{[^}]*\}/, // "key": {object}
            /"[^"]*":\s*\d+/, // "key": number
            /"[^"]*":\s*(true|false|null)/ // "key": boolean/null
          ];
          
          let lastCompleteMatch = null;
          for (const pattern of patterns) {
            const matches = fixed.match(new RegExp('.*' + pattern.source));
            if (matches && (!lastCompleteMatch || matches[0].length > lastCompleteMatch[0].length)) {
              lastCompleteMatch = matches;
            }
          }
          
          if (lastCompleteMatch) {
            fixed = lastCompleteMatch[0] + '}';
            console.log('🔧 オブジェクトを強制終了');
          } else {
            // 最低限のJSONオブジェクトを作成
            fixed = '{"title": "JSON解析エラー", "description": "不正なJSONのため解析に失敗しました", "ingredients": [], "steps": []}';
            console.log('🔧 最低限のJSONオブジェクトを作成');
          }
        }
        
        // 二重引用符の問題を修正
        fixed = fixed.replace(/""([^"]*)""/g, '"$1"');
        
        // 特殊文字のエスケープ問題を修正
        fixed = fixed.replace(/\\"/g, '"');
        
        // 最終的な構文チェック
        try {
          JSON.parse(fixed);
          console.log('✅ JSON修正成功');
        } catch (testError) {
          console.warn('⚠️ 修正後もJSON無効:', testError.message);
          // 最後の手段：基本的な構造を強制作成
          fixed = '{"title": "解析エラー", "description": "JSONの修正に失敗しました", "ingredients": [], "steps": []}';
        }
        
        console.log('🔧 JSON修正完了:', {
          fixed: fixed.substring(0, 200) + '...',
          originalLength: jsonString.length,
          fixedLength: fixed.length
        });
        
        return fixed;
      } catch (error) {
        console.error('❌ JSON修正処理エラー:', error);
        return '{"title": "修正エラー", "description": "JSON修正処理でエラーが発生しました", "ingredients": [], "steps": []}';
      }
    }

    // レシピデータを翻訳する関数
    async function translateRecipeData(recipeData) {
      const selectedLanguage = targetLanguageSelect.value || DEFAULT_TRANSLATION_LANGUAGE;
      const targetLanguageLabel = getLanguageLabel(selectedLanguage);
      const targetLanguageName = getLanguagePromptName(selectedLanguage);
      
      console.log('🌐 翻訳開始:', {
        selectedLanguage,
        targetLanguageLabel,
        targetLanguageName,
        recipeDataKeys: Object.keys(recipeData || {})
      });
      
      const hasIngredientSections = Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(ing => ing && ing.sectionTitle);
      const sectionInstruction = hasIngredientSections
        ? '\n- Maintain the original ingredient sections exactly as provided via the "sectionTitle" field. Include those sectionTitle values in the translated JSON.'
        : '';

      const { data, error } = await sb.functions.invoke('call-groq-api', {
        body: {
          mode: 'recipe_translation',
          recipeData: recipeData,
          targetLanguage: selectedLanguage,
          targetLanguageName: targetLanguageName,
          targetLanguageLabel,
          forceTranslate: true,
          noSummarize: true,
          keepAllItems: true,
          strictInstruction: `Translate ALL fields into ${targetLanguageName}. Do NOT summarize or omit any content.\n- Keep the number of ingredients and steps identical to the source (1:1).\n- Preserve step granularity; do not merge steps.${sectionInstruction}\n- Return JSON only.`
        }
      });

      if (error) {
        throw new Error(`翻訳API呼び出しエラー: ${error.message}`);
      }

      if (!data.success) {
        throw new Error(data.error || '翻訳に失敗しました');
      }

      // Groq APIのcontentからJSONを抽出
      const content = data.content || '';
      console.log('🔍 翻訳APIコンテンツ（全体）:', content);
      console.log('🔍 翻訳APIコンテンツ（タイプ）:', typeof content);
      console.log('🔍 翻訳APIコンテンツ（長さ）:', content.length);
      console.log('🔍 翻訳APIレスポンス（data全体）:', data);
      
      try {
        // 複数のJSON抽出パターンを試行
        let translatedData = null;

        if (data.data && typeof data.data === 'object') {
          translatedData = { ...data.data };
          if (Array.isArray(translatedData.ingredients)) {
            translatedData.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, translatedData.ingredients);
          }
        }

        // パターン1: 完全なJSONオブジェクト
        const jsonMatch1 = content.match(/\{[\s\S]*\}/);
        if (!translatedData && jsonMatch1) {
          try {
            let jsonString = jsonMatch1[0];
            console.log('🔍 パターン1 - 抽出されたJSON文字列:', jsonString);
            
            // JSON修正処理
            jsonString = fixMalformedJson(jsonString);
            console.log('🔧 パターン1 - 修正後のJSON文字列:', jsonString);
            
            translatedData = JSON.parse(jsonString);
            console.log('✅ パターン1でJSON解析成功:', translatedData);
          } catch (e) {
            console.log('❌ パターン1失敗:', e.message);
            console.log('❌ パターン1失敗 - 問題のJSON:', jsonMatch1[0].substring(0, 200));
          }
        }
        
        // パターン2: ```json ブロック内のJSON
        if (!translatedData) {
          const jsonMatch2 = content.match(/```json\s*([\s\S]*?)\s*```/);
          if (jsonMatch2) {
            try {
              let jsonString = jsonMatch2[1].trim();
              console.log('🔍 パターン2 - 抽出されたJSON文字列:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('✅ パターン2でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン2失敗:', e.message);
            }
          }
        }
        
        // パターン3: ``` ブロック内のJSON
        if (!translatedData) {
          const jsonMatch3 = content.match(/```\s*([\s\S]*?)\s*```/);
          if (jsonMatch3) {
            try {
              translatedData = JSON.parse(jsonMatch3[1]);
              console.log('✅ パターン3でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン3失敗:', e.message);
            }
          }
        }
        
        // パターン4: 最初と最後の{}を探す
        if (!translatedData) {
          const firstBrace = content.indexOf('{');
          const lastBrace = content.lastIndexOf('}');
          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            try {
              let jsonString = content.substring(firstBrace, lastBrace + 1);
              console.log('🔍 パターン4 - 抽出されたJSON文字列:', jsonString);
              
              jsonString = fixMalformedJson(jsonString);
              translatedData = JSON.parse(jsonString);
              console.log('✅ パターン4でJSON解析成功:', translatedData);
            } catch (e) {
              console.log('❌ パターン4失敗:', e.message);
            }
          }
        }
        
        // パターン5: 行ごとに{}を探す
        if (!translatedData) {
          const lines = content.split('\n');
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
              try {
                let jsonString = fixMalformedJson(trimmed);
                translatedData = JSON.parse(jsonString);
                console.log('✅ パターン5でJSON解析成功:', translatedData);
                break;
              } catch (e) {
                console.log('❌ パターン5失敗（行）:', e.message);
              }
            }
          }
        }
        
        const seemsSameLanguage = (payload) => {
          const text = [payload?.title, payload?.description, ...(payload?.ingredients||[]).map(i=>i.item), ...(payload?.steps||[])].filter(Boolean).join(' ');
          const hasJP = /[\u3040-\u30FF\u4E00-\u9FFF]/.test(text);
          if (selectedLanguage === 'en') return hasJP; // 英語要求なのに日本語が多い
          if (selectedLanguage === 'ja') return !hasJP; // 日本語要求なのに日本語が少ない
          return false;
        };

        if (translatedData) {
          const sourceIngredientCount = recipeData.ingredients?.length || 0;
          const translatedIngredientCount = translatedData.ingredients?.length || 0;
          const sourceStepCount = recipeData.steps?.length || 0;
          const translatedStepCount = translatedData.steps?.length || 0;

          if (translatedIngredientCount !== sourceIngredientCount || translatedStepCount !== sourceStepCount) {
            console.warn('⚠️ 翻訳結果の件数が原文と一致しません', {
              sourceIngredientCount,
              translatedIngredientCount,
              sourceStepCount,
              translatedStepCount
            });
            try {
              const countFallback = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
              if (countFallback) {
                console.log('✅ 件数不一致のためChatGPTフォールバック結果を採用');
                translatedData = countFallback;
              }
            } catch (fallbackErr) {
              console.warn('ChatGPTフォールバック失敗 (件数不一致):', fallbackErr);
            }
          }

          if (Array.isArray(translatedData.ingredients)) {
            translatedData.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, translatedData.ingredients);

            if ((translatedData.ingredients?.length || 0) !== sourceIngredientCount) {
              const filledIngredients = [];
              for (let i = 0; i < sourceIngredientCount; i++) {
                const origin = recipeData.ingredients?.[i] || {};
                const translatedIng = translatedData.ingredients?.[i];
                if (translatedIng) {
                  filledIngredients.push(ensureIngredientSectionTitles([origin], [translatedIng])[0]);
                } else {
                  filledIngredients.push({
                    item: origin.item || origin.name || '',
                    quantity: origin.quantity || '',
                    unit: origin.unit || '',
                    sectionTitle: origin.sectionTitle || ''
                  });
                }
              }
              translatedData.ingredients = filledIngredients;
            }
          }
          // 翻訳言語チェック → 不一致ならChatGPTへフォールバック
          if (seemsSameLanguage(translatedData)) {
            console.warn('⚠️ 期待言語に翻訳されていない可能性。ChatGPTにフォールバックします');
            try {
              const fallback = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
              if (fallback) return fallback;
            } catch (e) {
              console.warn('ChatGPTフォールバック失敗:', e);
            }
          }
          console.log('✅ 翻訳データ取得成功:', translatedData);
          console.log('🔍 翻訳データの構造:', {
            hasTitle: !!translatedData.title,
            hasDescription: !!translatedData.description,
            hasServings: !!translatedData.servings,
            hasIngredients: !!translatedData.ingredients,
            hasSteps: !!translatedData.steps,
            ingredientsLength: translatedData.ingredients?.length || 0,
            stepsLength: translatedData.steps?.length || 0
          });
          return translatedData;
        } else {
          // フォールバック: レスポンスが自然言語の場合、手動で構造化データを作成
          console.warn('⚠️ JSON解析に失敗、自然言語レスポンスから構造化データを作成します');
          console.warn('⚠️ レスポンス内容:', content.substring(0, 500));
          
          // 自然言語レスポンスから基本的な情報を抽出
          const fallbackData = {
            title: currentRecipeData?.title ? `${currentRecipeData.title} (${targetLanguageLabel}翻訳)` : `翻訳されたレシピ (${targetLanguageLabel})`,
            description: content.length > 0 ? content.substring(0, 200) + '...' : '翻訳情報が取得できませんでした',
            servings: currentRecipeData?.servings || '不明',
            ingredients: currentRecipeData?.ingredients || [],
            steps: currentRecipeData?.steps || []
          };
          
          console.log('📝 フォールバックデータ:', fallbackData);
          // フォールバックでも原文の可能性 → ChatGPTへ再試行
          try {
            const fb = await translateWithChatGPT(recipeData, selectedLanguage, targetLanguageName);
            if (fb) return fb;
          } catch (_) {}
          return fallbackData;
        }
        
      } catch (parseError) {
        console.error('❌ 翻訳JSON解析エラー:', parseError);
        throw new Error(`翻訳データの解析に失敗しました: ${parseError.message}`);
      }
    }

    // ChatGPTフォールバック翻訳
    async function translateWithChatGPT(recipeData, langKey, langName) {
      try {
        const hasSections = Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(ing => ing && ing.sectionTitle);
        const sectionNote = hasSections ? ' 材料にsectionTitleフィールドが含まれている場合は、その値を変更せずに保持し、翻訳結果でも同じフィールドを含めてください。' : '';
        const prompt = `次のレシピデータを${langName}に翻訳し、JSONだけで返してください。必ずすべてのテキストを${langName}に翻訳し、原文のまま残さないでください。${sectionNote}\n\n` +
          JSON.stringify({
            title: recipeData.title || '',
            description: recipeData.description || '',
            servings: recipeData.servings || '',
            ingredients: recipeData.ingredients || [],
            steps: recipeData.steps || []
          }, null, 2);
        const { data, error } = await sb.functions.invoke('call-openai-api', {
          body: {
            prompt,
            model: 'gpt-4o-mini',
            maxTokens: 4096,
            temperature: 0.2,
            responseFormat: { type: 'json_object' }
          }
        });
        if (error || !data?.success) throw new Error(error?.message || data?.error || 'API error');
        const content = typeof data.content === 'string' ? data.content : (data.raw?.choices?.[0]?.message?.content || '');
        const match = content.match(/\{[\s\S]*\}/);
        const json = match ? match[0] : content;
        const parsed = JSON.parse(json);
        if (Array.isArray(parsed.ingredients)) {
          parsed.ingredients = ensureIngredientSectionTitles(recipeData.ingredients, parsed.ingredients);
        }
        return parsed;
      } catch (e) {
        console.warn('translateWithChatGPT error:', e.message);
        return null;
      }
    }

    // 包括的なレシピ構造解析関数
    function parseComplexRecipeStructure(recipeData, url = '') {
      const r = recipeData || {};
      
      console.log('🔍 包括的レシピ構造解析開始');
      console.log('📊 入力データ:', r);
      console.log('📊 手順数:', r.steps?.length || 0);
      console.log('📊 材料数:', r.ingredients?.length || 0);
      console.log('📊 URL:', url);
      
      // サイト別特別処理の検出
      const siteDetection = {
        valrhona: url && url.includes('valrhona.com'),
        marmiton: url && url.includes('marmiton.org'),
        cookpad: url && url.includes('cookpad.com'),
        kurashiru: url && url.includes('kurashiru.com'),
        delishkitchen: url && url.includes('delishkitchen.tv'),
        gibier: url && url.includes('gibier.or.jp'),
        tsuji: url && url.includes('tsuji.ac.jp'),
        professional: url && (url.includes('chef') || url.includes('hotel') || url.includes('restaurant'))
      };
      
      console.log('🏷️ サイト検出結果:', siteDetection);
      
      // セクション構造を検出
      const sections = [];
      
      // Valrhonaサイトの場合は専用処理を優先
      if (siteDetection.valrhona && r.ingredients && r.ingredients.length > 0) {
        console.log('🏷️ Valrhona専用処理を実行');
        console.log('📊 入力材料リスト詳細:');
        r.ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${typeof ing === 'string' ? ing : `${ing.item || ing.name || '?'} - ${ing.quantity || '?'} ${ing.unit || '?'}`}`);
        });
        
        // Valrhonaの既知のセクション構造を使用
        const valrhonaSections = [
          { title: 'LIQUID STARCH', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', weight: '3000g' },
          { title: 'BABA DOUGH', weight: '599g' }
        ];
        
        const valrhonaMapping = createValrhonaIngredientMapping(r.ingredients);
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = valrhonaMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            sections.push({
              title: sectionInfo.title,
              totalWeight: sectionInfo.weight,
              ingredients: sectionIngredients,
              instructions: []
            });
            
            console.log(`✅ Valrhonaセクション作成: "${sectionInfo.title}" - 材料数: ${sectionIngredients.length}`);
          } else {
            console.log(`❌ 空のセクション: "${sectionInfo.title}" - 材料数: 0`);
          }
        });
        
        console.log('🏁 Valrhona専用処理完了 - セクション数:', sections.length);
        
        // 総材料数の確認
        const totalMapped = Object.values(valrhonaMapping).reduce((sum, sectionItems) => sum + sectionItems.length, 0);
        console.log(`📊 マッピング統計: 元材料${r.ingredients.length}個 → マッピング済み${totalMapped}個`);
        
        if (totalMapped < r.ingredients.length) {
          console.warn(`⚠️ 未マッピング材料あり: ${r.ingredients.length - totalMapped}個が抜けています`);
        }
      }
      
      // ジビエ・日本語プロレシピの場合は専用処理
      if (sections.length === 0 && (siteDetection.gibier || siteDetection.tsuji || siteDetection.professional)) {
        console.log('🏷️ 日本語プロレシピ専用処理を実行');
        const japaneseProfessionalSections = createJapaneseProfessionalSections(r, url);
        if (japaneseProfessionalSections.length > 0) {
          console.log('✅ 日本語プロレシピ処理成功:', japaneseProfessionalSections.length, '個');
          sections.push(...japaneseProfessionalSections);
        }
      }
      
      // Valrhona以外または専用処理が失敗した場合の一般的な処理
      if (sections.length === 0) {
        // 1. 手順からセクションを抽出する方法を試行
        console.log('🔍 方法1: 手順からセクション抽出を試行');
        const extractedSections = extractSectionsFromSteps(r, siteDetection);
        if (extractedSections.length > 0) {
          console.log('✅ 手順からセクション抽出成功:', extractedSections.length, '個');
          sections.push(...extractedSections);
        }
        
        // 2. 材料名から料理の工程を推測する方法
        if (sections.length === 0) {
          console.log('🔍 方法2: 材料からカテゴリ推測を試行');
          const inferredSections = inferSectionsFromIngredients(r);
          if (inferredSections.length > 0) {
            console.log('✅ 材料からセクション推測成功:', inferredSections.length, '個');
            sections.push(...inferredSections);
          }
        }
        
        // 3. レシピの複雑さに基づく自動分割
        if (sections.length === 0 && r.ingredients && r.ingredients.length > 8) {
          console.log('🔍 方法3: 複雑レシピの自動分割を試行');
          const autoSections = createAutoSections(r);
          if (autoSections.length > 0) {
            console.log('✅ 自動分割成功:', autoSections.length, '個');
            sections.push(...autoSections);
          }
        }
      }
      
      // 手順からセクションを抽出
      if (r.steps && r.steps.length > 0) {
        let currentSection = null;
        
        r.steps.forEach((step, index) => {
          const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
          console.log(`\n🔍 Step ${index + 1} 解析開始:`);
          console.log(`📝 ステップテキスト（全体）:`, stepText);
          console.log(`📝 ステップテキスト（最初の200文字）:`, stepText.substring(0, 200));
          
          // セクションタイトル検出パターンを複数試行
          let sectionMatch = null;
          let detectedTitle = null;
          
          // パターン1: Valrhona Step形式 "Step01 LIQUID STARCH" または "Step02 JIVARA 40% INTENSE WHIPPED GANACHE"
          const stepPattern = /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i;
          const stepMatch = stepText.match(stepPattern);
          if (stepMatch && stepMatch[2]) {
            detectedTitle = stepMatch[2].trim();
            sectionMatch = stepMatch;
            console.log('🎯 Step形式検出:', detectedTitle);
          } else {
            console.log('❌ Step形式マッチなし');
          }
          
          // パターン2: 大文字タイトル行 "LIQUID STARCH" または "JIVARA 40% INTENSE WHIPPED GANACHE"
          if (!sectionMatch) {
            const titlePattern = /^([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const titleMatch = stepText.match(titlePattern);
            if (titleMatch) {
              detectedTitle = titleMatch[1].trim();
              sectionMatch = titleMatch;
              console.log('🎯 大文字タイトル検出:', detectedTitle);
            } else {
              console.log('❌ 大文字タイトルマッチなし');
            }
          }
          
          // パターン3: 番号付きタイトル "1. LIQUID STARCH"
          if (!sectionMatch) {
            const numberedPattern = /^(\d+\.?\s*)([A-Z][A-Z\s&%0-9]{3,})(?:\n|$)/;
            const numberedMatch = stepText.match(numberedPattern);
            if (numberedMatch) {
              detectedTitle = numberedMatch[2].trim();
              sectionMatch = numberedMatch;
              console.log('🎯 番号付きタイトル検出:', detectedTitle);
            } else {
              console.log('❌ 番号付きタイトルマッチなし');
            }
          }
          
          // パターン4: 行内の大文字セクション（改行で区切られていない場合）
          if (!sectionMatch) {
            const inlinePattern = /([A-Z][A-Z\s&%0-9]{4,})/g;
            const inlineMatches = stepText.match(inlinePattern);
            if (inlineMatches && inlineMatches.length > 0) {
              // 最初の大文字セクションを使用
              detectedTitle = inlineMatches[0].trim();
              sectionMatch = { 0: detectedTitle };
              console.log('🎯 行内大文字セクション検出:', detectedTitle);
            } else {
              console.log('❌ 行内大文字セクションマッチなし');
            }
          }
          
          console.log(`🔍 最終検出結果: ${detectedTitle ? `"${detectedTitle}"` : 'なし'}`);
          
          if (sectionMatch && detectedTitle && detectedTitle.length >= 4) {
            // 新しいセクション開始
            if (currentSection) {
              console.log('📝 セクション完了:', currentSection.title, `材料数: ${currentSection.ingredients.length}`);
              sections.push(currentSection);
            }
            
            currentSection = {
              title: detectedTitle,
              ingredients: [],
              instructions: [],
              totalWeight: null
            };
            
            console.log('🆕 新セクション開始:', detectedTitle);
          } else {
            console.log('❌ セクション検出失敗 - 既存セクションに追加');
          }
          
          if (currentSection) {
            console.log('🔍 現在のセクション:', currentSection.title);
            
            // 重量情報を抽出（複数パターン対応）
            const weightPatterns = [
              /(\d+g)\s*Total weight/i,
              /Total weight[:\s]*(\d+g)/i,
              /^(\d+g)$/
            ];
            
            for (const pattern of weightPatterns) {
              const weightMatch = stepText.match(pattern);
              if (weightMatch) {
                currentSection.totalWeight = weightMatch[1];
                console.log('⚖️ 重量検出:', weightMatch[1]);
                break;
              }
            }
            
            // 材料を抽出（行ごとに処理）
            const lines = stepText.split('\n');
            console.log('📋 行数:', lines.length);
            
            lines.forEach((line, lineIndex) => {
              const trimmedLine = line.trim();
              if (!trimmedLine) return;
              
              console.log(`  📝 行 ${lineIndex + 1}: "${trimmedLine}"`);
              
              // Valrhona形式の材料パターン: "475g Liquid starch"
              const valrhonaIngredient = trimmedLine.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/);
              if (valrhonaIngredient) {
                const quantity = valrhonaIngredient[1];
                const unit = normalizeUnit(valrhonaIngredient[2]);
                const item = valrhonaIngredient[3].trim();
                
                console.log(`    🔍 Valrhona材料候補: "${item}" - ${quantity} ${unit}`);
                
                // セクションタイトルや重量情報でないことを確認
                if (!item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i) && item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    ✅ Valrhona材料追加:', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    ❌ Valrhona材料除外（タイトル/重量）:', item);
                }
                return;
              }
              
              // 一般形式の材料パターン: "Liquid starch - 475g"
              const generalIngredient = trimmedLine.match(/^(.+?)\s*[-–]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
              if (generalIngredient) {
                const item = generalIngredient[1].trim();
                const quantity = generalIngredient[2];
                const unit = normalizeUnit(generalIngredient[3]);
                
                console.log(`    🔍 一般材料候補: "${item}" - ${quantity} ${unit}`);
                
                if (item.length >= 2) {
                  currentSection.ingredients.push({
                    quantity: quantity,
                    unit: unit,
                    item: item
                  });
                  console.log('    ✅ 一般材料追加:', `${item} - ${quantity} ${unit}`);
                } else {
                  console.log('    ❌ 一般材料除外（短すぎ）:', item);
                }
                return;
              }
              
              // 新パターン: 手順内の材料抽出 "475g liquid starch", "320g JIVARA 40%"など
              const inlineIngredients = trimmedLine.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([a-zA-Z\s%0-9]+)/g);
              if (inlineIngredients) {
                console.log(`    🔍 手順内材料検出: ${inlineIngredients.length}個`);
                inlineIngredients.forEach((match, matchIndex) => {
                  const ingredientMatch = match.match(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)/);
                  if (ingredientMatch) {
                    const quantity = ingredientMatch[1];
                    const unit = normalizeUnit(ingredientMatch[2]);
                    const item = ingredientMatch[3].trim();
                    
                    console.log(`      🔍 手順内材料 ${matchIndex + 1}: "${item}" - ${quantity} ${unit}`);
                    
                    // 材料として適切かチェック（一般的な材料名）
                    const isValidIngredient = item.match(/^(liquid starch|jivara|gelatin|water|heavy cream|sugar|beer|flour|eggs|yeast|butter|milk|potato starch|glucose|candied|nuts|pistachios|hazelnuts|kasha)/i);
                    
                    if (isValidIngredient && item.length >= 3) {
                      currentSection.ingredients.push({
                        quantity: quantity,
                        unit: unit,
                        item: item
                      });
                      console.log(`      ✅ 手順内材料追加: ${item} - ${quantity} ${unit}`);
                    } else {
                      console.log(`      ❌ 手順内材料除外: ${item} (材料名として不適切)`);
                    }
                  }
                });
                return;
              }
              
              console.log('    ❌ 材料パターンマッチなし');
            });
            
            console.log(`🥄 現在の材料数: ${currentSection.ingredients.length}`);
            
            // 手順テキストを追加（セクションタイトルと材料を除く）
            let cleanInstruction = stepText
              .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
              .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
              .replace(/(\d+g)\s*Total weight/i, '')
              .trim();
            
            if (cleanInstruction && cleanInstruction.length > 10) {
              currentSection.instructions.push(cleanInstruction);
              console.log('📋 手順追加:', cleanInstruction.substring(0, 50) + '...');
            }
          } else {
            console.log('⚠️ currentSectionがnull - セクション未検出');
          }
        });
        
        // 最後のセクションを追加
        if (currentSection) {
          console.log('📝 最終セクション完了:', currentSection.title, `材料数: ${currentSection.ingredients.length}`);
          sections.push(currentSection);
        }
      } else {
        console.log('⚠️ 手順データなし');
      }
      
      console.log('🏁 解析完了 - 総セクション数:', sections.length);
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients.length}`);
      });
      
      // 最終的なフォールバック処理
      if (sections.length === 0) {
        console.log('⚠️ 全ての抽出方法が失敗 - 基本構造を作成');
        sections.push({
          title: 'INGREDIENTS',
          ingredients: r.ingredients ? r.ingredients.map(ingredient => normalizeIngredientObject(ingredient)) : [],
          instructions: r.steps || [],
          totalWeight: null
        });
      } else {
        // セクションは見つかったが材料が抽出できていない場合、元の材料リストを分配
        const totalIngredients = sections.reduce((sum, section) => sum + (section.ingredients?.length || 0), 0);
        console.log('🔍 総材料数チェック:', totalIngredients);
        
        if (totalIngredients === 0 && r.ingredients && r.ingredients.length > 0) {
          console.log('⚠️ セクション内材料なし - 智能分配を実行');
          console.log('📊 元材料リスト:', r.ingredients);
          
          // 材料の意味に基づく智能分配
          const smartMapping = createSmartIngredientMapping(r.ingredients, sections);
          
          sections.forEach((section, sectionIndex) => {
            if (smartMapping[section.title]) {
              section.ingredients = smartMapping[section.title];
              console.log(`📋 智能分配: "${section.title}" に材料 ${section.ingredients.length} 個を配置`);
            }
          });
        }
      }
      
      return sections;
    }

    // 手順からセクションを抽出する関数
    function extractSectionsFromSteps(recipeData, siteDetection) {
      const r = recipeData || {};
      const sections = [];
      
      if (!r.steps || r.steps.length === 0) return sections;
      
      let currentSection = null;
      
      r.steps.forEach((step, index) => {
        const stepText = typeof step === 'string' ? step : (step.step || step.instruction || '');
        
        // 包括的なセクションタイトル検出パターン
        const sectionPatterns = [
          // Valrhona形式: "Step01 LIQUID STARCH"
          /^Step\s*(\d+)\s*(.+?)(?:\n|$)/i,
          // 一般的な番号付きセクション: "1. Preparation", "2. Dough Making"
          /^(\d+)\.?\s*([A-Z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // 大文字タイトル: "LIQUID STARCH", "PREPARATION"
          /^([A-Z][A-Z\s&%0-9]{4,})(?:\n|$)/i,
          // 括弧付きセクション: "(1) Preparation", "[Step 1] Mixing"
          /^[\(\[\{]?(?:Step\s*)?(\d+)[\)\]\}]?\s*([A-Za-z][A-Za-z\s&%0-9]{4,})(?:\n|$)/i,
          // 日本語セクション: "1. 下準備", "2. 生地作り"
          /^(\d+)\.?\s*([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]{3,})(?:\n|$)/i
        ];
        
        let detectedTitle = null;
        let sectionMatch = null;
        
        for (const pattern of sectionPatterns) {
          const match = stepText.match(pattern);
          if (match) {
            detectedTitle = (match[2] || match[1]).trim();
            sectionMatch = match;
            console.log(`🎯 セクション検出 (パターン${sectionPatterns.indexOf(pattern) + 1}):`, detectedTitle);
            break;
          }
        }
        
        if (sectionMatch && detectedTitle && detectedTitle.length >= 3) {
          // 新しいセクション開始
          if (currentSection) {
            sections.push(currentSection);
          }
          
          currentSection = {
            title: detectedTitle,
            ingredients: [],
            instructions: [],
            totalWeight: null
          };
        }
        
        if (currentSection) {
          // 材料抽出の強化
          extractIngredientsFromStep(stepText, currentSection);
          
          // 重量情報抽出
          const weightMatch = stepText.match(/(\d+g)\s*Total weight|Total weight[:\s]*(\d+g)|^(\d+g)$/i);
          if (weightMatch) {
            currentSection.totalWeight = weightMatch[1] || weightMatch[2] || weightMatch[3];
          }
          
          // 手順テキストの追加
          const cleanInstruction = cleanStepText(stepText);
          if (cleanInstruction && cleanInstruction.length > 10) {
            currentSection.instructions.push(cleanInstruction);
          }
        }
      });
      
      if (currentSection) {
        sections.push(currentSection);
      }
      
      return sections;
    }

    // 材料から料理工程を推測する関数
    function inferSectionsFromIngredients(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 6) return [];
      
      const sections = [];
      const ingredientCategories = categorizeIngredients(r.ingredients);
      
      // カテゴリ別にセクションを作成
      Object.entries(ingredientCategories).forEach(([category, ingredients]) => {
        if (ingredients.length > 0) {
          sections.push({
            title: category,
            ingredients: ingredients,
            instructions: [],
            totalWeight: null
          });
        }
      });
      
      return sections;
    }

    // 材料をカテゴリ別に分類する関数（日本語対応強化版）
    function categorizeIngredients(ingredients) {
      const categories = {
        'ベース材料 / BASE': [],
        'フィリング・ソース / FILLING': [],
        'トッピング・飾り / TOPPINGS': [],
        '調味料・香料 / SEASONINGS': [],
        'その他 / OTHERS': []
      };
      
      console.log('🔍 材料カテゴリ分類開始:', ingredients.length, '個');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIng = normalizeIngredientObject(ingredient);
        const itemName = normalizedIng.item.toLowerCase();
        
        console.log(`🔍 材料 ${index + 1}: "${normalizedIng.item}"`);
        
        // 生地・ベース材料（日本語・英語対応）
        if (itemName.match(/flour|bread|dough|starch|yeast|egg|milk|butter|oil|sugar|water|小麦粉|薄力粉|強力粉|卵|牛乳|バター|砂糖|水|ベーキングパウダー|イースト|生地/)) {
          categories['ベース材料 / BASE'].push(normalizedIng);
          console.log(`  → ベース材料 に分類`);
        }
        // ソース・フィリング（日本語・英語対応）
        else if (itemName.match(/cream|sauce|chocolate|ganache|filling|syrup|jam|paste|クリーム|チョコ|ソース|ジャム|シロップ|ガナッシュ|あん|餡/)) {
          categories['フィリング・ソース / FILLING'].push(normalizedIng);
          console.log(`  → フィリング・ソース に分類`);
        }
        // トッピング（日本語・英語対応）
        else if (itemName.match(/nuts|seeds|fruits?|berries|sprinkles|decoration|topping|ナッツ|種|実|果物|フルーツ|飾り|トッピング|粉糖|シナモン|ココア/)) {
          categories['トッピング・飾り / TOPPINGS'].push(normalizedIng);
          console.log(`  → トッピング・飾り に分類`);
        }
        // 調味料（日本語・英語対応）
        else if (itemName.match(/salt|pepper|spice|herb|vanilla|extract|seasoning|塩|胡椒|こしょう|醤油|味噌|酢|みりん|酒|香料|エッセンス|バニラ|スパイス/)) {
          categories['調味料・香料 / SEASONINGS'].push(normalizedIng);
          console.log(`  → 調味料・香料 に分類`);
        }
        // かぼちゃ系（特別分類）
        else if (itemName.match(/pumpkin|squash|かぼちゃ|南瓜|マッシュ/)) {
          categories['ベース材料 / BASE'].push(normalizedIng);
          console.log(`  → ベース材料 に分類 (かぼちゃ系)`);
        }
        // その他
        else {
          categories['その他 / OTHERS'].push(normalizedIng);
          console.log(`  → その他 に分類`);
        }
      });
      
      // 空のカテゴリを削除
      Object.keys(categories).forEach(key => {
        if (categories[key].length === 0) {
          delete categories[key];
        }
      });
      
      console.log('📋 分類結果:');
      Object.entries(categories).forEach(([category, items]) => {
        console.log(`  ${category}: ${items.length}個`);
      });
      
      return categories;
    }

    // 複雑なレシピの自動分割
    function createAutoSections(recipeData) {
      const r = recipeData || {};
      if (!r.ingredients || r.ingredients.length < 8) return [];
      
      const sections = [];
      const sectionSize = Math.ceil(r.ingredients.length / 3); // 3分割を基本とする
      
      const sectionNames = ['PREPARATION', 'MAIN PROCESS', 'FINISHING'];
      
      for (let i = 0; i < 3; i++) {
        const startIndex = i * sectionSize;
        const endIndex = Math.min(startIndex + sectionSize, r.ingredients.length);
        const sectionIngredients = r.ingredients.slice(startIndex, endIndex);
        
        if (sectionIngredients.length > 0) {
          sections.push({
            title: sectionNames[i],
            ingredients: sectionIngredients.map(ingredient => normalizeIngredientObject(ingredient)),
            instructions: [],
            totalWeight: null
          });
        }
      }
      
      return sections;
    }

    // 手順テキストから材料を抽出する強化版
    function extractIngredientsFromStep(stepText, section) {
      const lines = stepText.split('\n');
      
      lines.forEach(line => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        
        // 複数の材料パターンを試行
        const patterns = [
          // "475g Liquid starch"
          /^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+(.+)$/,
          // "Liquid starch - 475g"
          /^(.+?)\s*[-–]\s*(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/,
          // "2 cups flour"
          /^(\d+(?:\.\d+)?)\s+(cups?|tbsp|tsp|pieces?)\s+(.+)$/i,
          // 日本語パターン: "小麦粉 200g"
          /^([\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s*(\d+(?:\.\d+)?)\s*([a-zA-Zｇｍｌ%]+)$/
        ];
        
        for (const pattern of patterns) {
          const match = trimmedLine.match(pattern);
          if (match) {
            let item, quantity, unit;
            
            if (pattern === patterns[0]) { // "475g Liquid starch"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[1]) { // "Liquid starch - 475g"
              [, item, quantity, unit] = match;
            } else if (pattern === patterns[2]) { // "2 cups flour"
              [, quantity, unit, item] = match;
            } else if (pattern === patterns[3]) { // 日本語
              [, item, quantity, unit] = match;
            }
            
            // 有効な材料かチェック
            if (item && item.length >= 2 && !item.match(/^(Step|STEP|\d+g\s*Total|Total\s*weight)/i)) {
              section.ingredients.push({
                item: item.trim(),
                quantity: quantity || '',
                unit: normalizeUnit(unit || '')
              });
              break;
            }
          }
        }
      });
    }

    // 手順テキストをクリーニングする関数
    function cleanStepText(stepText) {
      return stepText
        .replace(/^(Step\s*\d+[\s\n]*)?([A-Z][A-Z\s&%0-9]+)(?:[\s\n])/i, '')
        .replace(/(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)\s+([A-Za-z\s,()&\-'0-9]+)/g, '')
        .replace(/(\d+g)\s*Total weight/i, '')
        .trim();
    }

    // 日本語プロレシピ専用のセクション作成関数
    function createJapaneseProfessionalSections(recipeData, url = '') {
      console.log('🏷️ 日本語プロレシピセクション作成開始');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('📊 日本語プロレシピ分析:');
      console.log(`  タイトル: "${title}"`);
      console.log(`  材料数: ${ingredients.length}`);
      console.log(`  手順数: ${steps.length}`);
      
      const sections = [];
      
      // ジビエレシピの場合の特別処理
      const isGibierRecipe = title.match(/鹿|猪|いのしし|ジビエ|ウェリントン|wellington/i) ||
                            ingredients.some(ing => {
                              const itemName = typeof ing === 'string' ? ing : (ing.item || ing.name || '');
                              return itemName.match(/鹿|猪|いのしし|ジビエ|venison|wild.*boar/i);
                            });
      
      if (isGibierRecipe) {
        console.log('🦌 ジビエレシピ検出 - 専用セクション作成');
        
        // 手順から工程を検出
        const detectedProcesses = [];
        const allText = `${title} ${steps.join(' ')}`;
        
        // ジビエ料理の典型的な工程パターン
        const processPatterns = [
          { pattern: /マリナード|マリネ|漬け込み|下味/i, section: 'マリナード・下準備' },
          { pattern: /ウェリントン|パイ包み|パイ生地/i, section: 'ウェリントン包み' },
          { pattern: /コンフィ|低温調理|真空/i, section: 'コンフィ・付け合わせ' },
          { pattern: /ドフィノワーズ|グラタン|ベシャメル/i, section: 'ドフィノワーズ' },
          { pattern: /ソース|燻煙|醤油|柚子/i, section: 'ソース・調味料' },
          { pattern: /フリカッセ|きのこ|茸|マッシュルーム/i, section: 'フリカッセ・ガルニ' },
          { pattern: /ジェノベーゼ|ワサビ|香草/i, section: 'ハーブ・薬味' },
          { pattern: /盛り付け|仕上げ|飾り/i, section: '盛り付け・仕上げ' }
        ];
        
        processPatterns.forEach(({ pattern, section }) => {
          if (pattern.test(allText)) {
            detectedProcesses.push(section);
            console.log(`  工程検出: ${section}`);
          }
        });
        
        // 材料を工程別に分類
        if (detectedProcesses.length > 0) {
          detectedProcesses.forEach(processName => {
            const sectionIngredients = [];
            
            ingredients.forEach(ingredient => {
              const normalizedIngredient = normalizeIngredientObject(ingredient);
              const itemName = normalizedIngredient.item.toLowerCase();
              
              // 工程別材料分類ルール（大幅強化）
              let shouldInclude = false;
              
              switch (processName) {
                case 'マリナード・下準備':
                  shouldInclude = itemName.match(/鹿|ロース|肉|味噌|香草|塩|コショウ|pepper|salt|miso|marinade|marinate|下味|漬け込み/i);
                  break;
                case 'ウェリントン包み':
                  shouldInclude = itemName.match(/パイ|シート|キャベツ|卵黄|pastry|puff|cabbage|egg|wellington|包み|生地|粒生黒コショウ|フルール.*セル/i);
                  break;
                case 'コンフィ・付け合わせ':
                  shouldInclude = itemName.match(/白ネギ|ねぎ|オリーブオイル|ニンニク|タイム|ローリエ|leek|olive|garlic|thyme|bay|confit|ごぼう|パンチェッタ|玉ネギ|無塩バター|チキンブイヨン|白コショウ/i);
                  break;
                case 'ドフィノワーズ':
                  shouldInclude = itemName.match(/サツマイモ|ジャガイモ|生クリーム|牛乳|パルメザン|potato|cream|milk|parmesan|dauphinoise|ベシャメル|薄力粉|ナツメグ/i);
                  break;
                case 'ソース・調味料':
                  shouldInclude = itemName.match(/醤油|燻煙|柚子|バター|ブイヨン|コーンスターチ|soy|yuzu|butter|stock|cornstarch|焦がしバター|燻煙醬油|柚子果汁/i);
                  break;
                case 'フリカッセ・ガルニ':
                  shouldInclude = itemName.match(/ジロル|トランペット|芽キャベツ|きのこ|茸|mushroom|brussels|fricassee|ドライトランペット|エシャロット|サラダ油/i);
                  break;
                case 'ハーブ・薬味':
                  shouldInclude = itemName.match(/ワサビ|わさび|香草|パセリ|wasabi|herb|parsley|ジェノベーゼ|genovese|ピーテンドリル|マイクロアマランサス/i);
                  break;
                case '盛り付け・仕上げ':
                  shouldInclude = itemName.match(/飾り|ガルニ|マイクロ|garnish|micro|盛り付け|仕上げ|decoration/i);
                  break;
              }
              
              // より包括的な材料マッチング（部分一致も考慮）
              if (!shouldInclude) {
                // 材料名に含まれるキーワードで再チェック
                const keywords = itemName.split(/\s+|・|、|,/);
                keywords.forEach(keyword => {
                  if (keyword.length >= 2) { // 2文字以上のキーワードのみ
                    switch (processName) {
                      case 'マリナード・下準備':
                        if (keyword.match(/鹿|肉|味噌|香草|塩|胡椒/i)) shouldInclude = true;
                        break;
                      case 'ウェリントン包み':
                        if (keyword.match(/パイ|キャベツ|卵|生地|黒胡椒|セル/i)) shouldInclude = true;
                        break;
                      case 'コンフィ・付け合わせ':
                        if (keyword.match(/ネギ|オリーブ|ニンニク|ごぼう|バター|ブイヨン/i)) shouldInclude = true;
                        break;
                      case 'ドフィノワーズ':
                        if (keyword.match(/イモ|芋|クリーム|牛乳|チーズ|小麦粉/i)) shouldInclude = true;
                        break;
                      case 'ソース・調味料':
                        if (keyword.match(/醤油|柚子|バター|ソース|調味/i)) shouldInclude = true;
                        break;
                      case 'フリカッセ・ガルニ':
                        if (keyword.match(/きのこ|茸|キャベツ|エシャロット/i)) shouldInclude = true;
                        break;
                      case 'ハーブ・薬味':
                        if (keyword.match(/ワサビ|香草|ハーブ|パセリ/i)) shouldInclude = true;
                        break;
                    }
                  }
                });
              }
              
              if (shouldInclude) {
                sectionIngredients.push(normalizedIngredient);
                console.log(`    材料分類: "${normalizedIngredient.item}" → ${processName}`);
              }
            });
            
            if (sectionIngredients.length > 0) {
              sections.push({
                title: processName,
                ingredients: sectionIngredients,
                instructions: [],
                totalWeight: null
              });
            }
          });
        }
      }
      
      // 一般的な日本語プロレシピの場合
      if (sections.length === 0) {
        console.log('🍳 一般日本語プロレシピ処理');
        
        // 材料を基本的なカテゴリに分類
        const basicCategories = {
          '主材料': [],
          '調味料・ソース': [],
          '付け合わせ': [],
          '仕上げ・飾り': []
        };
        
        ingredients.forEach(ingredient => {
          const normalizedIngredient = normalizeIngredientObject(ingredient);
          const itemName = normalizedIngredient.item.toLowerCase();
          
          // 基本分類ルール
          if (itemName.match(/肉|魚|鶏|豚|牛|鹿|猪|meat|fish|chicken|pork|beef|venison/i)) {
            basicCategories['主材料'].push(normalizedIngredient);
          } else if (itemName.match(/醤油|味噌|塩|砂糖|酢|油|ソース|バター|soy|miso|salt|sugar|vinegar|oil|sauce|butter/i)) {
            basicCategories['調味料・ソース'].push(normalizedIngredient);
          } else if (itemName.match(/野菜|きのこ|芋|ネギ|キャベツ|vegetable|mushroom|potato|leek|cabbage/i)) {
            basicCategories['付け合わせ'].push(normalizedIngredient);
          } else if (itemName.match(/飾り|香草|スパイス|garnish|herb|spice/i)) {
            basicCategories['仕上げ・飾り'].push(normalizedIngredient);
          } else {
            // デフォルトは主材料に
            basicCategories['主材料'].push(normalizedIngredient);
          }
        });
        
        // 空でないカテゴリのみセクションとして追加
        Object.entries(basicCategories).forEach(([categoryName, categoryIngredients]) => {
          if (categoryIngredients.length > 0) {
            sections.push({
              title: categoryName,
              ingredients: categoryIngredients,
              instructions: [],
              totalWeight: null
            });
          }
        });
      }
      
      console.log('🏁 日本語プロレシピセクション作成完了:', sections.length, '個');
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients.length}`);
      });
      
      return sections;
    }

    // Valrhona専用の材料マッピング関数（改良版）
    function createValrhonaIngredientMapping(ingredients) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('🔍 Valrhona材料マッピング開始:', ingredients.length, '個の材料');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        const quantity = parseInt(normalizedIngredient.quantity) || 0;
        
        console.log(`🔍 材料 ${index + 1}: "${normalizedIngredient.item}" - ${normalizedIngredient.quantity} ${normalizedIngredient.unit}`);
        
        // より包括的で精密な分類ルール
        let classified = false;
        
        // LIQUID STARCH セクション
        if (itemName.match(/liquid\s*starch/) || itemName.includes('starch')) {
          mapping['LIQUID STARCH'].push(normalizedIngredient);
          console.log(`  → LIQUID STARCH に分類 (starch関連)`);
          classified = true;
        }
        
        // JIVARA GANACHE セクション
        if (itemName.match(/jivara/) || 
            itemName.match(/chocolate|ganache/) ||
            (itemName.includes('heavy cream') && quantity >= 190) ||
            itemName.match(/gelatin|gelatine/)) {
          mapping['JIVARA 40% INTENSE WHIPPED GANACHE'].push(normalizedIngredient);
          console.log(`  → JIVARA GANACHE に分類 (${itemName.includes('jivara') ? 'jivara' : itemName.includes('cream') ? 'heavy cream' : itemName.includes('gelatin') ? 'gelatin' : 'chocolate関連'})`);
          classified = true;
        }
        
        // CANDIED NUT MIX セクション
        if (itemName.match(/hazelnut|pistachio|kasha|nuts|candied|roasted.*piedmont|blanched.*sicilian/)) {
          mapping['SWEET & SAVORY CANDIED NUT MIX'].push(normalizedIngredient);
          console.log(`  → CANDIED NUT MIX に分類 (ナッツ関連: ${itemName})`);
          classified = true;
        }
        
        // BEER SYRUP セクション
        if (itemName.includes('beer') ||
           (itemName.includes('sugar') && quantity >= 755) ||
           (itemName.includes('water') && quantity >= 605) ||
           itemName.includes('glucose') ||
           itemName.includes('milk') && quantity > 100) {
          mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
          console.log(`  → BEER SYRUP に分類 (${itemName.includes('beer') ? 'beer' : itemName.includes('glucose') ? 'glucose' : itemName.includes('milk') ? 'milk' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water ${quantity}g`})`);
          classified = true;
        }
        
        // BABA DOUGH セクション
        if (itemName.match(/flour|strong.*flour/) ||
           itemName.match(/egg|whole.*egg/) ||
           itemName.match(/yeast|live.*yeast/) ||
           itemName.match(/butter|european.*style.*butter/) ||
           itemName.match(/lemon|candied.*lemon|diced.*candied/) ||
           itemName.includes('fleur de sel') ||
           itemName.includes('sel') ||
           (itemName.includes('sugar') && quantity <= 55) ||
           (itemName.includes('water') && quantity <= 320 && itemName.includes('gelatin'))) {
          mapping['BABA DOUGH'].push(normalizedIngredient);
          console.log(`  → BABA DOUGH に分類 (${itemName.includes('flour') ? 'flour' : itemName.includes('egg') ? 'egg' : itemName.includes('yeast') ? 'yeast' : itemName.includes('butter') ? 'butter' : itemName.includes('lemon') ? 'lemon' : itemName.includes('sel') ? 'sel' : itemName.includes('sugar') ? `sugar ${quantity}g` : `water for gelatin`})`);
          classified = true;
        }
        
        // 未分類の処理
        if (!classified) {
          console.warn(`⚠️ 未分類材料: "${normalizedIngredient.item}" - ${quantity}${normalizedIngredient.unit}`);
          
          // 数量に基づく推測
          if (itemName.includes('water')) {
            if (quantity <= 320) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  → BABA DOUGH に分類 (少量水: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  → BEER SYRUP に分類 (大量水: ${quantity}g)`);
            }
          } else if (itemName.includes('sugar')) {
            if (quantity <= 100) {
              mapping['BABA DOUGH'].push(normalizedIngredient);
              console.log(`  → BABA DOUGH に分類 (少量砂糖: ${quantity}g)`);
            } else {
              mapping['BEER SYRUP FOR BABAS'].push(normalizedIngredient);
              console.log(`  → BEER SYRUP に分類 (大量砂糖: ${quantity}g)`);
            }
          } else {
            // 最後の手段: LIQUID STARCHに分類
            mapping['LIQUID STARCH'].push(normalizedIngredient);
            console.log(`  → LIQUID STARCH に分類 (デフォルト: ${itemName})`);
          }
        }
      });
      
      // 各セクションの材料数をログ出力
      Object.entries(mapping).forEach(([section, ingredients]) => {
        console.log(`📋 ${section}: ${ingredients.length}個の材料`);
        ingredients.forEach((ing, index) => {
          console.log(`  ${index + 1}. ${ing.item} - ${ing.quantity} ${ing.unit}`);
        });
      });
      
      return mapping;
    }

    // 一般的なレシピ用の智能材料分配関数
    function createSmartIngredientMapping(ingredients, sections) {
      const mapping = {};
      
      // 各セクションを初期化
      sections.forEach(section => {
        mapping[section.title] = [];
      });
      
      console.log('🧠 智能材料分配開始:', ingredients.length, '個の材料を', sections.length, '個のセクションに分配');
      
      ingredients.forEach((ingredient, index) => {
        const normalizedIngredient = normalizeIngredientObject(ingredient);
        const itemName = normalizedIngredient.item.toLowerCase();
        
        let assigned = false;
        
        // セクション名に基づく分配
        sections.forEach(section => {
          const sectionName = section.title.toLowerCase();
          
          // キーワードマッチング
          const keywords = extractKeywords(sectionName);
          const ingredientKeywords = extractKeywords(itemName);
          
          // 共通キーワードがある場合は優先的に分配
          const commonKeywords = keywords.filter(k => 
            ingredientKeywords.some(ik => ik.includes(k) || k.includes(ik))
          );
          
          if (commonKeywords.length > 0 && !assigned) {
            mapping[section.title].push(normalizedIngredient);
            console.log(`🎯 キーワードマッチ: "${normalizedIngredient.item}" → "${section.title}" (共通: ${commonKeywords.join(', ')})`);
            assigned = true;
          }
        });
        
        // マッチしなかった場合は最初のセクションに分配
        if (!assigned && sections.length > 0) {
          mapping[sections[0].title].push(normalizedIngredient);
          console.log(`📍 デフォルト分配: "${normalizedIngredient.item}" → "${sections[0].title}"`);
        }
      });
      
      return mapping;
    }

    // テキストからキーワードを抽出する関数
    function extractKeywords(text) {
      return text.toLowerCase()
        .split(/[\s\-_&%]+/)
        .filter(word => word.length > 2)
        .map(word => word.replace(/[^a-z0-9]/g, ''));
    }

    // 材料オブジェクトを正規化する関数
    function normalizeIngredientObject(ingredient) {
      if (typeof ingredient === 'string') {
        const match = ingredient.match(/^(.+?)\s*[-–]\s*(.+)$/);
        if (match) {
          const item = match[1].trim();
          const quantityUnit = match[2].trim();
          // 日本語の定性的な分量（適量・少々・ひとつまみ・お好みで）を特別扱い
          const qualitativeMatch = quantityUnit.match(/^(適量|少々|ひとつまみ|お好みで)$/);
          if (qualitativeMatch) {
            return {
              item: item,
              quantity: '',
              unit: qualitativeMatch[1]
            };
          }
          const quantityMatch = quantityUnit.match(/^(\d+(?:\.\d+)?)\s*([a-zA-Z%]+)$/);
          if (quantityMatch) {
            return {
              item: item,
              quantity: quantityMatch[1],
              unit: normalizeUnit(quantityMatch[2])
            };
          }
        }
        return { item: ingredient, quantity: '', unit: '' };
      } else {
        return {
          item: ingredient.item || ingredient.name || '',
          quantity: ingredient.quantity || ingredient.amount || '',
          unit: normalizeUnit(ingredient.unit || '')
        };
      }
    }

    // レシピの複雑さを解析してカテゴリ別表示が適切かを判断
    function analyzeRecipeComplexity(recipeData, url = '') {
      console.log('🔍 レシピ複雑度解析開始');
      
      const r = recipeData || {};
      const ingredients = r.ingredients || [];
      const steps = r.steps || [];
      const title = r.title || '';
      
      console.log('📊 基本統計:');
      console.log(`  材料数: ${ingredients.length}`);
      console.log(`  手順数: ${steps.length}`);
      console.log(`  タイトル: "${title}"`);
      
      // 1. 材料数が少ない場合はシンプル表示（基準を緩和）
      if (ingredients.length < 5) {
        console.log('❌ 材料数が少ない (< 5) - シンプル表示');
        return false;
      }
      
      // 2. 手順からセクション構造を検出（日本語パターン強化）
      const stepsText = steps.join(' ').toLowerCase();
      const sectionIndicators = [
        // 英語パターン
        /for\s+the\s+\w+/g,
        /\b(dough|batter|cream|sauce|filling|ganache|syrup|mixture|wellington|confit|fricassee|duxelles)\b/g,
        /step\s+\d+:/g,
        /part\s+\d+/g,
        // 日本語パターン（強化）
        /【.*?】/g,
        /■.*?■/g,
        /\d+\.\s*【/g,
        /工程\s*\d+/g,
        /手順\s*\d+/g,
        /①|②|③|④|⑤|⑥|⑦|⑧|⑨|⑩/g,
        /を作る|を準備|下準備|仕上げ|盛り付け/g,
        /ソース|生地|フィリング|トッピング|ガルニ/g
      ];
      
      let sectionCount = 0;
      sectionIndicators.forEach(pattern => {
        const matches = stepsText.match(pattern);
        if (matches) {
          sectionCount += matches.length;
          console.log(`  セクション指標発見: ${pattern} - ${matches.length}個`);
        }
      });
      
      // 3. 材料名から複雑度を判定（日本語・ジビエ料理対応強化）
      const complexIngredientPatterns = [
        // 専門的な材料（西洋）
        /ganache|couverture|valrhona|callebaut/i,
        /glucose|invert\s+sugar|isomalt/i,
        /gellan|agar|pectin|xanthan/i,
        // 複数の調理工程を示唆する材料
        /tempered|melted|whipped|clarified/i,
        /reduction|infusion|extract/i,
        // 日本語の専門材料（強化）
        /ガナッシュ|クーベルチュール|転化糖|アガー|ゼラチン/i,
        /生クリーム.*?泡立て|バター.*?溶かし/i,
        // ジビエ・高級食材
        /鹿|猪|いのしし|ジビエ|venison|wild\s+boar/i,
        /フォアグラ|トリュフ|キャビア|foie\s+gras|truffle|caviar/i,
        // フランス料理技法
        /ウェリントン|wellington|コンフィ|confit|フリカッセ|fricassee/i,
        /ドフィノワーズ|dauphinoise|ベシャメル|bechamel|デュクセル|duxelles/i,
        /ジュノベーゼ|genovese|フルール.*?セル|fleur.*?sel/i,
        // 高級調味料・材料
        /パルメザン|parmesan|グリュイエール|gruyere/i,
        /エシャロット|shallot|マデラ|madeira|ポルト|port/i,
        /燻製|スモーク|smoke|燻煙/i,
        // 専門器具・技法を示唆
        /真空|vacuum|低温|sous\s+vide/i,
        /コンベクション|convection|スチーム|steam/i
      ];
      
      let complexIngredientCount = 0;
      const allText = `${title} ${ingredients.map(ing => 
        typeof ing === 'string' ? ing : (ing.item || ing.name || '')
      ).join(' ')} ${steps.join(' ')}`;
      
      complexIngredientPatterns.forEach(pattern => {
        const matches = allText.match(pattern);
        if (matches) {
          complexIngredientCount += matches.length;
          console.log(`  複雑材料/技法発見: ${matches.join(', ')}`);
        }
      });
      
      // 4. プロレシピ・コンテスト入賞作品の検出
      const professionalIndicators = [
        /コンテスト|contest|competition|入賞|受賞|award/i,
        /シェフ|chef|料理長|パティシエ|patissier/i,
        /ホテル|hotel|レストラン|restaurant/i,
        /プロ部門|professional|プロフェッショナル/i,
        /ミシュラン|michelin|星付き/i
      ];
      
      let professionalScore = 0;
      professionalIndicators.forEach(pattern => {
        if (pattern.test(allText)) {
          professionalScore += 2;
          console.log(`  プロ指標発見: ${pattern}`);
        }
      });
      
      // 5. 総合判定（基準を緩和）
      const complexityScore = sectionCount * 1.5 + complexIngredientCount + professionalScore;
      console.log('📊 複雑度スコア計算:');
      console.log(`  セクション数: ${sectionCount} × 1.5 = ${sectionCount * 1.5}`);
      console.log(`  複雑材料数: ${complexIngredientCount}`);
      console.log(`  プロ指標: ${professionalScore}`);
      console.log(`  総合スコア: ${complexityScore}`);
      
      // 6. 特定サイトは優先的にカテゴリ表示（日本語サイト追加）
      const isComplexSite = url && (
        url.includes('valrhona.com') ||
        url.includes('marmiton.org') ||
        url.includes('chef') ||
        url.includes('professional') ||
        url.includes('patisserie') ||
        url.includes('gibier.or.jp') ||
        url.includes('tsuji.ac.jp') ||
        url.includes('cordonbleu') ||
        url.includes('hotel') ||
        url.includes('restaurant')
      );
      
      if (isComplexSite) {
        console.log('✅ 複雑サイト検出 - カテゴリ表示適用');
        return true;
      }
      
      // 7. 材料数による判定（基準緩和）
      const hasManyIngredients = ingredients.length >= 8;
      const hasProfessionalElements = professionalScore > 0 || complexIngredientCount > 0;
      
      // 8. 最終判定（基準を大幅に緩和）
      const shouldCategorize = 
        complexityScore >= 2 || 
        (ingredients.length >= 8 && sectionCount > 0) ||
        (ingredients.length >= 12) ||
        (hasProfessionalElements && ingredients.length >= 6);
        
      console.log(`${shouldCategorize ? '✅' : '❌'} 最終判定: ${shouldCategorize ? 'カテゴリ表示' : 'シンプル表示'}`);
      console.log('📋 判定理由:');
      console.log(`  複雑度スコア >= 2: ${complexityScore >= 2} (${complexityScore})`);
      console.log(`  材料8個以上 + セクション: ${ingredients.length >= 8 && sectionCount > 0} (材料:${ingredients.length}, セクション:${sectionCount})`);
      console.log(`  材料12個以上: ${ingredients.length >= 12} (${ingredients.length})`);
      console.log(`  プロ要素 + 材料6個以上: ${hasProfessionalElements && ingredients.length >= 6} (プロ:${hasProfessionalElements}, 材料:${ingredients.length})`);
      
      return shouldCategorize;
    }

    // 材料専用のフレキシブル表示関数
    function displayFlexibleIngredients(recipeData, containerId, url = '') {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('❌ コンテナが見つかりません:', containerId);
        return;
      }

      if (Array.isArray(recipeData?.ingredients)) {
        recipeData.ingredients = recipeData.ingredients.map(ing => {
          if (ing && typeof ing === 'object' && ing.section_title && !ing.sectionTitle) {
            return { ...ing, sectionTitle: ing.section_title };
          }
          return ing;
        });
      }
      
      console.log('🎯 材料表示開始:', containerId);
      console.log('📊 URL:', url);
      
      // 事前に sectionTitle が埋め込まれている場合はそれを優先してグルーピング
      if (Array.isArray(recipeData?.ingredients) && recipeData.ingredients.some(i => i && typeof i === 'object' && 'sectionTitle' in i)) {
        container.innerHTML = '';
        const groups = {};
        (recipeData.ingredients || []).forEach(ing => {
          const key = (ing.sectionTitle || '').trim() || 'その他';
          if (!groups[key]) groups[key] = [];
          groups[key].push(ing);
        });
        Object.entries(groups).forEach(([title, list]) => {
          const sectionDiv = document.createElement('div');
          sectionDiv.className = 'recipe-section';
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = title;
          sectionDiv.appendChild(titleDiv);
          list.forEach(ingredient => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
          });
          const sectionActions = document.createElement('div');
          sectionActions.className = 'inline-actions';
          sectionActions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn secondary';
          addBtn.textContent = '材料を追加';
          addBtn.addEventListener('click', () => { addIngredientRowToSection(sectionDiv); });
          sectionActions.appendChild(addBtn);
          sectionDiv.appendChild(sectionActions);
          container.appendChild(sectionDiv);
        });
        return;
      }

      // レシピ構造を解析してカテゴリ別表示が適切かを判断
      const shouldUseCategorization = analyzeRecipeComplexity(recipeData, url);
      
      console.log('🏷️ カテゴリ別表示適用判定:', shouldUseCategorization);
      
      if (!shouldUseCategorization) {
        console.log('📝 シンプル表示を使用');
        displaySimpleIngredients(recipeData, containerId);
        return;
      }
      
      console.log('🔧 カテゴリ別表示を試行');
      console.log('📊 レシピデータ:', recipeData);
      console.log('📊 レシピデータの構造:', {
        hasTitle: !!recipeData?.title,
        hasIngredients: !!recipeData?.ingredients,
        hasSteps: !!recipeData?.steps,
        ingredientsLength: recipeData?.ingredients?.length || 0,
        stepsLength: recipeData?.steps?.length || 0
      });
      
      const sections = parseComplexRecipeStructure(recipeData, url);
      console.log('📋 解析されたセクション数:', sections.length);
      console.log('📋 各セクションの詳細:');
      let flatIndex = 0;
      sections.forEach((section, index) => {
        console.log(`  セクション ${index + 1}: "${section.title}" - 材料数: ${section.ingredients?.length || 0}`);
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach((ing, ingIndex) => {
            console.log(`    材料 ${ingIndex + 1}: ${ing.item} - ${ing.quantity} ${ing.unit}`);
          });
        }
      });
      
      container.innerHTML = '';
      let displayedSections = 0;
      
      // 材料セクションのみを表示
      sections.forEach((section, index) => {
        console.log(`🔍 セクション ${index + 1} 処理中:`, section.title, `材料数: ${section.ingredients?.length || 0}`);
        
        if (section.ingredients && section.ingredients.length > 0) {
          const sectionDiv = document.createElement('div');
          sectionDiv.className = 'recipe-section';
          sectionDiv.setAttribute('data-section-title', section.title || '');
          
          // セクションタイトル
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = section.title;
          sectionDiv.appendChild(titleDiv);
          console.log('📝 セクションタイトル設定:', section.title);
          
          // 総重量
          if (section.totalWeight) {
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${section.totalWeight}`;
            sectionDiv.appendChild(weightDiv);
            console.log('⚖️ 重量表示:', section.totalWeight);
          }
          
          // 材料グリッド
          section.ingredients.forEach((ingredient, ingredientIndex) => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            gridDiv.setAttribute('data-ing-index', String(flatIndex++));
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.contentEditable = 'true';
            nameDiv.spellcheck = false;
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.contentEditable = 'true';
            quantityDiv.spellcheck = false;
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.contentEditable = 'true';
            unitDiv.spellcheck = false;
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
            
            console.log(`🥄 材料 ${ingredientIndex + 1} 追加:`, `${ingredient.item} - ${ingredient.quantity} ${ingredient.unit}`);
          });
          // セクション専用「材料を追加」ボタン
          const sectionActions = document.createElement('div');
          sectionActions.className = 'inline-actions';
          sectionActions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn secondary';
          addBtn.textContent = '材料を追加';
          addBtn.addEventListener('click', () => {
            addIngredientRowToSection(sectionDiv);
          });
          sectionActions.appendChild(addBtn);
          sectionDiv.appendChild(sectionActions);
          
          container.appendChild(sectionDiv);
          displayedSections++;
          console.log('✅ セクション表示完了:', section.title);
        } else {
          console.log('⚠️ 材料なしセクション:', section.title);
        }
      });
      
      if (displayedSections > 0) {
        const flattened = [];
        sections.forEach(section => {
          (section.ingredients || []).forEach(ingredient => {
            const cloned = { ...(ingredient || {}) };
            cloned.sectionTitle = section.title || '';
            flattened.push(cloned);
          });
        });
        recipeData.ingredients = flattened;
        if (containerId === 'flexibleIngredientsDisplay') {
          window.currentRecipeData = window.currentRecipeData || {};
          window.currentRecipeData.ingredients = flattened.map(ing => ({
            item: ing.item || ing.name || '',
            quantity: ing.quantity || '',
            unit: ing.unit || '',
            sectionTitle: ing.sectionTitle || ''
          }));
        }
      }

      console.log(`🏁 フレキシブル表示完了 - 表示セクション数: ${displayedSections}`);
      
      // セクション化された材料が見つからない場合は従来の表示
      if (displayedSections === 0) {
        console.log('⚠️ カテゴリ化材料なし - シンプル表示にフォールバック');
        console.log('📊 フォールバック理由調査:');
        console.log('  - セクション数:', sections.length);
        sections.forEach((section, index) => {
          console.log(`  - セクション ${index + 1}: "${section.title}" 材料数: ${section.ingredients?.length || 0}`);
        });
        displaySimpleIngredients(recipeData, containerId);
      } else {
        console.log('✅ カテゴリ別表示成功！');
      }
    }
    
    // シンプルな材料表示関数（フォールバック用）
    function displaySimpleIngredients(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const r = recipeData || {};
      container.innerHTML = '';
      
      if (r.ingredients && r.ingredients.length > 0) {
        r.ingredients.forEach(ingredient => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          
          // 材料の表示形式を改善（分量のダブりを防ぐ）
          let ingredientText = '';
          if (typeof ingredient === 'string') {
            ingredientText = ingredient;
          } else if (ingredient && typeof ingredient === 'object') {
            const itemName = ingredient.item || ingredient.name || '';
            const quantity = ingredient.quantity || ingredient.amount || '';
            const rawUnit = ingredient.unit || '';
            
            // 単位を正規化
            const unit = normalizeUnit(rawUnit);
            
            // 分量なし/定性的な分量の扱いを最適化
            const qualitativeUnits = ['適量', '少々', 'ひとつまみ', 'お好みで'];
            const hasQuantity = quantity !== '' && quantity !== null && typeof quantity !== 'undefined';
            let quantityUnit = '';
            if (hasQuantity) {
              quantityUnit = [quantity, unit].filter(Boolean).join(' ');
            } else if (qualitativeUnits.includes(unit)) {
              quantityUnit = unit;
            } else {
              quantityUnit = '';
            }
            
            // 材料名と分量を組み合わせ（分量が空ならハイフンを出さない）
            ingredientText = quantityUnit ? [itemName, quantityUnit].join(' - ') : itemName;
          }
          
          item.textContent = ingredientText || '材料情報なし';
          container.appendChild(item);
        });
      } else if (r.ingredientLines && r.ingredientLines.length > 0) {
        r.ingredientLines.forEach(line => {
          const item = document.createElement('div');
          item.className = 'ingredient-item';
          item.textContent = line;
          container.appendChild(item);
        });
      } else {
        const item = document.createElement('div');
        item.className = 'ingredient-item';
        item.textContent = '材料が見つかりませんでした';
        container.appendChild(item);
      }
    }

    // フレキシブルなレシピ表示関数
    function displayFlexibleRecipe(recipeData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      
      const sections = parseComplexRecipeStructure(recipeData);
      
      container.innerHTML = '';
      
      sections.forEach(section => {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'recipe-section';
        
        // セクションタイトル
        const titleDiv = document.createElement('div');
        titleDiv.className = 'recipe-section-title';
        titleDiv.textContent = section.title;
        sectionDiv.appendChild(titleDiv);
        
        // 総重量
        if (section.totalWeight) {
          const weightDiv = document.createElement('div');
          weightDiv.className = 'recipe-section-weight';
          weightDiv.textContent = `Total weight: ${section.totalWeight}`;
          sectionDiv.appendChild(weightDiv);
        }
        
        // 材料グリッド
        if (section.ingredients && section.ingredients.length > 0) {
          section.ingredients.forEach(ingredient => {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'recipe-ingredients-grid';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'ingredient-name';
            nameDiv.textContent = ingredient.item || ingredient.name || '';
            
            const quantityDiv = document.createElement('div');
            quantityDiv.className = 'ingredient-quantity';
            quantityDiv.textContent = ingredient.quantity || '';
            
            const unitDiv = document.createElement('div');
            unitDiv.className = 'ingredient-unit';
            unitDiv.textContent = ingredient.unit || '';
            
            gridDiv.appendChild(nameDiv);
            gridDiv.appendChild(quantityDiv);
            gridDiv.appendChild(unitDiv);
            sectionDiv.appendChild(gridDiv);
          });
        }
        
        // 手順
        if (section.instructions && section.instructions.length > 0) {
          const instructionsDiv = document.createElement('div');
          instructionsDiv.className = 'recipe-instructions';
          
          section.instructions.forEach(instruction => {
            const p = document.createElement('p');
            p.textContent = instruction;
            instructionsDiv.appendChild(p);
          });
          
          sectionDiv.appendChild(instructionsDiv);
        }
        
        container.appendChild(sectionDiv);
      });
    }

    // 翻訳結果を表示する関数
    function displayTranslatedResults(translatedData) {
      if (!translatedData) return;

      // 画像の表示
      const imageContainer = document.getElementById('translatedRecipeImageContainer');
      const recipeImage = document.getElementById('translatedRecipeImage');
      if (currentRecipeData && currentRecipeData.image_url) {
        recipeImage.src = currentRecipeData.image_url;
        imageContainer.style.display = 'block';
      } else {
        imageContainer.style.display = 'none';
      }

      document.getElementById('translatedRecipeTitle').textContent = translatedData.title || '-';
      document.getElementById('translatedRecipeDescription').textContent = translatedData.description || '-';
      document.getElementById('translatedRecipeServings').textContent = translatedData.servings || '-';

      const finalIngredients = ensureIngredientSectionTitles(
        currentRecipeData.ingredients,
        translatedData.ingredients
      );

      translatedData.ingredients = finalIngredients;
      displayFlexibleIngredients(translatedData, 'flexibleTranslatedIngredientsDisplay', window.lastProcessedUrl);
      renderSteps(document.getElementById('translatedStepsList'), translatedData.steps || [], false);
    }

    // 翻訳材料をカテゴリー別テーブルで表示する関数
    function displayTranslatedIngredientsAsTable(translatedData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('❌ 翻訳用コンテナが見つかりません:', containerId);
        return;
      }
      
      container.innerHTML = '';
      const ingredients = translatedData.ingredients || [];
      
      if (ingredients.length === 0) {
        container.innerHTML = '<div class="ingredient-item">翻訳された材料がありません</div>';
        return;
      }
      
      console.log('🌐 翻訳材料をカテゴリー別テーブルで表示:', ingredients.length, '個');
      
      // 材料を4つのカテゴリに分類
      const categories = {
        base: { title: 'ベース材料 / BASE', items: [] },
        filling: { title: 'フィリング・ソース / FILLING', items: [] },
        seasoning: { title: '調味料・香料 / SEASONINGS', items: [] },
        others: { title: 'その他 / OTHERS', items: [] }
      };
      
      // 各材料をカテゴリに分類
      ingredients.forEach(ing => {
        const itemName = (ing.item || '').toLowerCase();
        const unit = (ing.unit || '').toLowerCase();
        
        // ベース材料パターン
        if (itemName.match(/flour|farine|生地|dough|pâte|粉|薄力粉|強力粉|バター|butter|beurre|卵|egg|œuf|牛乳|milk|lait/i)) {
          categories.base.items.push(ing);
        }
        // フィリング・ソースパターン
        else if (itemName.match(/cream|crème|クリーム|sauce|ソース|ganache|ガナッシュ|filling|フィリング|生クリーム|ホイップ/i)) {
          categories.filling.items.push(ing);
        }
        // 調味料・香料パターン
        else if (itemName.match(/salt|sel|塩|sugar|sucre|砂糖|pepper|poivre|こしょう|胡椒|spice|épice|香辛料|vanilla|vanille|バニラ|シナモン|cinnamon|cannelle/i)) {
          categories.seasoning.items.push(ing);
        }
        // その他
        else {
          categories.others.items.push(ing);
        }
      });
      
      // カテゴリー別にテーブルを作成
      let categoryCount = 0;
      Object.values(categories).forEach(category => {
        if (category.items.length > 0) {
          categoryCount++;
          
          // カテゴリータイトル
          const titleDiv = document.createElement('div');
          titleDiv.className = 'recipe-section-title';
          titleDiv.textContent = category.title;
          titleDiv.style.cssText = 'font-weight: bold; color: #4a90e2; margin: 1.5rem 0 0.5rem 0; padding: 0.5rem; background: rgba(74, 144, 226, 0.1); border-radius: 4px;';
          container.appendChild(titleDiv);
          
          // テーブル作成（ヘッダーなし）
          const table = document.createElement('table');
          table.className = 'table';
          
          // テーブルボディ
          const tbody = document.createElement('tbody');
          category.items.forEach((ingredient, index) => {
            const row = document.createElement('tr');
            
            // 番号
            const tdNum = document.createElement('td');
            tdNum.textContent = index + 1;
            tdNum.style.textAlign = 'center';
            row.appendChild(tdNum);
            
            // 材料名
            const tdItem = document.createElement('td');
            tdItem.textContent = ingredient.item || '';
            row.appendChild(tdItem);
            
            // 数量
            const tdQty = document.createElement('td');
            tdQty.textContent = ingredient.quantity || '';
            tdQty.style.textAlign = 'right';
            row.appendChild(tdQty);
            
            // 単位
            const tdUnit = document.createElement('td');
            tdUnit.textContent = ingredient.unit || '';
            tdUnit.style.textAlign = 'center';
            row.appendChild(tdUnit);
            
            tbody.appendChild(row);
          });
          table.appendChild(tbody);
          container.appendChild(table);
          
          console.log(`✅ カテゴリー "${category.title}": ${category.items.length}個の材料を表示`);
        }
      });
      
      if (categoryCount === 0) {
        // カテゴリ分けできない場合は単一テーブルで表示（ヘッダーなし）
        const table = document.createElement('table');
        table.className = 'table';
        
        const tbody = document.createElement('tbody');
        ingredients.forEach((ingredient, index) => {
          const row = document.createElement('tr');
          
          const tdNum = document.createElement('td');
          tdNum.textContent = index + 1;
          tdNum.style.textAlign = 'center';
          row.appendChild(tdNum);
          
          const tdItem = document.createElement('td');
          tdItem.textContent = ingredient.item || '';
          row.appendChild(tdItem);
          
          const tdQty = document.createElement('td');
          tdQty.textContent = ingredient.quantity || '';
          tdQty.style.textAlign = 'right';
          row.appendChild(tdQty);
          
          const tdUnit = document.createElement('td');
          tdUnit.textContent = ingredient.unit || '';
          tdUnit.style.textAlign = 'center';
          row.appendChild(tdUnit);
          
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        container.appendChild(table);
        
        console.log(`✅ 全材料を単一テーブルで表示: ${ingredients.length}個`);
      }
      
      console.log('🎉 翻訳材料のテーブル表示完了');
    }

    // 翻訳材料の構造維持表示関数（旧版 - 互換性のため保持）
    function displayTranslatedIngredientsWithStructure(translatedData, originalData, containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        console.error('❌ 翻訳用コンテナが見つかりません:', containerId);
        return;
      }
      
      console.log('🌐 翻訳構造維持表示開始');
      console.log('📊 翻訳データ:', translatedData);
      console.log('📊 元データ:', originalData);
      
      // 元のレシピ構造を取得（既に解析済みの構造を再利用）
      const url = window.lastProcessedUrl || '';
      const isValrhonaSite = url.includes('valrhona.com');
      
      if (isValrhonaSite && originalData && originalData.ingredients) {
        console.log('🏷️ Valrhona翻訳: 元構造を維持して翻訳材料をマッピング');
        
        // 元のValrhonaマッピングを再実行
        const originalMapping = createValrhonaIngredientMapping(originalData.ingredients);
        console.log('📋 元のマッピング:', originalMapping);
        
        // 翻訳材料を元の構造にマッピング
        const translatedMapping = mapTranslatedIngredientsToOriginalStructure(
          translatedData.ingredients || [],
          originalData.ingredients || [],
          originalMapping
        );
        
        // Valrhonaセクションで表示
        const valrhonaSections = [
          { title: 'LIQUID STARCH', titleJa: '液体澱粉', weight: '495g' },
          { title: 'JIVARA 40% INTENSE WHIPPED GANACHE', titleJa: 'ジヴァラ40% インテンス ホイップガナッシュ', weight: '1003g' },
          { title: 'SWEET & SAVORY CANDIED NUT MIX', titleJa: 'スイート&セイボリー キャンディードナッツミックス', weight: '177g' },
          { title: 'BEER SYRUP FOR BABAS', titleJa: 'ババ用ビールシロップ', weight: '3000g' },
          { title: 'BABA DOUGH', titleJa: 'ババ生地', weight: '599g' }
        ];
        
        container.innerHTML = '';
        
        valrhonaSections.forEach((sectionInfo) => {
          const sectionIngredients = translatedMapping[sectionInfo.title] || [];
          
          if (sectionIngredients.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'recipe-section';
            
            // セクションタイトル（日本語）
            const titleDiv = document.createElement('div');
            titleDiv.className = 'recipe-section-title';
            titleDiv.textContent = sectionInfo.titleJa;
            sectionDiv.appendChild(titleDiv);
            
            // 総重量
            const weightDiv = document.createElement('div');
            weightDiv.className = 'recipe-section-weight';
            weightDiv.textContent = `Total weight: ${sectionInfo.weight}`;
            sectionDiv.appendChild(weightDiv);
            
            // 材料グリッド
            sectionIngredients.forEach((ingredient) => {
              const gridDiv = document.createElement('div');
              gridDiv.className = 'recipe-ingredients-grid';
              
              const nameDiv = document.createElement('div');
              nameDiv.className = 'ingredient-name';
              nameDiv.textContent = ingredient.item || '';
              
              const quantityDiv = document.createElement('div');
              quantityDiv.className = 'ingredient-quantity';
              quantityDiv.textContent = ingredient.quantity || '';
              
              const unitDiv = document.createElement('div');
              unitDiv.className = 'ingredient-unit';
              unitDiv.textContent = ingredient.unit || '';
              
              gridDiv.appendChild(nameDiv);
              gridDiv.appendChild(quantityDiv);
              gridDiv.appendChild(unitDiv);
              sectionDiv.appendChild(gridDiv);
            });
            
            container.appendChild(sectionDiv);
            console.log(`✅ 翻訳セクション表示: "${sectionInfo.titleJa}" - 材料数: ${sectionIngredients.length}`);
          }
        });
        
        console.log('🌐 Valrhona翻訳構造表示完了');
      } else {
        console.log('⚠️ 非Valrhonaサイト: 通常の翻訳表示');
        displayFlexibleIngredients(translatedData, containerId, '');
      }
    }

    // 翻訳材料を元の構造にマッピングする関数
    function mapTranslatedIngredientsToOriginalStructure(translatedIngredients, originalIngredients, originalMapping) {
      const mapping = {
        'LIQUID STARCH': [],
        'JIVARA 40% INTENSE WHIPPED GANACHE': [],
        'SWEET & SAVORY CANDIED NUT MIX': [],
        'BEER SYRUP FOR BABAS': [],
        'BABA DOUGH': []
      };
      
      console.log('🔗 翻訳材料マッピング開始');
      console.log('📊 翻訳材料数:', translatedIngredients.length);
      console.log('📊 元材料数:', originalIngredients.length);
      
      // 翻訳材料を順番に元の構造に対応付け
      translatedIngredients.forEach((translatedIng, index) => {
        const normalizedTranslated = normalizeIngredientObject(translatedIng);
        
        // 対応する元の材料を見つける（インデックスベース）
        if (index < originalIngredients.length) {
          const originalIng = originalIngredients[index];
          
          // 元の材料がどのセクションに分類されていたかを調べる
          let foundSection = null;
          Object.entries(originalMapping).forEach(([sectionName, sectionIngredients]) => {
            if (sectionIngredients.some(ing => 
              ing.item === (typeof originalIng === 'string' ? originalIng : originalIng.item))) {
              foundSection = sectionName;
            }
          });
          
          if (foundSection) {
            mapping[foundSection].push(normalizedTranslated);
            console.log(`🔗 マッピング: "${normalizedTranslated.item}" → ${foundSection}`);
          } else {
            // フォールバック: 最初のセクションに追加
            mapping['LIQUID STARCH'].push(normalizedTranslated);
            console.log(`🔗 フォールバック: "${normalizedTranslated.item}" → LIQUID STARCH`);
          }
        }
      });
      
      return mapping;
    }

    // サイトの言語を判定する関数
    function detectSiteLanguage(html, url) {
      console.log('🔍 サイト言語判定開始:', url);
      
      // URLベースの判定
      const urlIndicators = {
        ja: ['.jp', 'cookpad.com', 'kurashiru.com', 'delishkitchen.tv', 'japanese', 'japan', 'rakuten-recipe.jp'],
        en: ['.com', '.org', '.net', '.edu', '.gov', '.uk', '.au', '.ca'],
        fr: ['.fr', 'marmiton.org', 'cuisine.fr', 'elle.fr/cuisine'],
        it: ['.it', 'giallozafferano.it', 'ricette.it'],
        de: ['.de', 'chefkoch.de', 'essen-und-trinken.de'],
        es: ['.es', 'recetasgratis.net', 'directoalpaladar.com']
      };
      
      let detectedLanguage = { code: 'en', name: 'English', isJapanese: false };
      
      // URLから言語を判定
      for (const [langCode, indicators] of Object.entries(urlIndicators)) {
        if (indicators.some(indicator => url && url.toLowerCase().includes(indicator))) {
          detectedLanguage = {
            code: langCode,
            name: getLanguagePromptName(langCode),
            isJapanese: langCode === 'ja'
          };
          console.log('🌐 URL判定結果:', langCode, '→', detectedLanguage);
          break;
        }
      }
      
      // HTMLコンテンツから言語を判定（URLベース判定を補強）
      const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
      const frenchRegex = /\b(recette|ingrédients|préparation|cuisson|pour|avec|dans|une|des|les|temps|min)\b/i;
      const italianRegex = /\b(ricetta|ingredienti|preparazione|cottura|per|con|in|una|dei|gli|tempo|min)\b/i;
      const germanRegex = /\b(rezept|zutaten|zubereitung|kochen|für|mit|in|eine|der|die|zeit|min)\b/i;
      const spanishRegex = /\b(receta|ingredientes|preparación|cocción|para|con|en|una|los|las|tiempo|min)\b/i;
      
      if (japaneseRegex.test(html)) {
        detectedLanguage = { code: 'ja', name: getLanguagePromptName('ja'), isJapanese: true };
        console.log('🇯🇵 日本語文字検出 → Japanese');
      } else if (frenchRegex.test(html)) {
        detectedLanguage = { code: 'fr', name: getLanguagePromptName('fr'), isJapanese: false };
        console.log('🇫🇷 フランス語キーワード検出 → French');
      } else if (italianRegex.test(html)) {
        detectedLanguage = { code: 'it', name: getLanguagePromptName('it'), isJapanese: false };
        console.log('🇮🇹 イタリア語キーワード検出 → Italian');
      } else if (germanRegex.test(html)) {
        detectedLanguage = { code: 'de', name: getLanguagePromptName('de'), isJapanese: false };
        console.log('🇩🇪 ドイツ語キーワード検出 → German');
      } else if (spanishRegex.test(html)) {
        detectedLanguage = { code: 'es', name: getLanguagePromptName('es'), isJapanese: false };
        console.log('🇪🇸 スペイン語キーワード検出 → Spanish');
      }
      
      console.log('🏁 最終言語判定:', detectedLanguage);
      return detectedLanguage;
    }

    // レシピ抽出プロンプトを生成する関数
    function generateRecipeExtractionPrompt(htmlContent, url, siteLanguage = { code: 'en', name: 'English', isJapanese: false }) {
      console.log('📝 プロンプト生成開始:', {
        url: url,
        siteLanguage: siteLanguage,
        contentLength: htmlContent.length
      });
      
      // 言語別にプロンプトを生成
      if (siteLanguage.isJapanese) {
        // 日本語サイト用のプロンプト（Recipe Keeper.app最適化版）
        return `以下のHTMLコンテンツから日本語レシピを解析し、JSON形式で構造化してください。

【Recipe Keeper最適化指示】
- 高速処理に特化した簡潔な解析
- 材料リストの正確な抽出を優先
- 分量・単位の分離に重点
- 日本語文字エンコーディングの保護
- 不要な説明文は最小限に

【日本語処理要件】
1. ひらがな・カタカナ・漢字を正確に抽出
2. UTF-8エンコーディングを維持
3. 日本語特有の分量表記を認識（大さじ、小さじ、カップ、つまみ等）
4. 文字化けを防止

【入力HTML】
${htmlContent.substring(0, 8000)}

【出力形式】
{
  "title": "レシピ名",
  "description": "簡潔な説明",
  "servings": "人数",
  "ingredients": [
    {"item": "材料名", "quantity": "分量", "unit": "単位"}
  ],
  "steps": ["手順1", "手順2"],
  "notes": "メモ"
}

【材料抽出例】
- 小麦粉 100g → {"item": "小麦粉", "quantity": "100", "unit": "g"}
- 卵 1個 → {"item": "卵", "quantity": "1", "unit": "個"}
- 大さじ2の醤油 → {"item": "醤油", "quantity": "2", "unit": "大さじ"}
- 適量の塩 → {"item": "塩", "quantity": "適量", "unit": ""}
- バター 15g → {"item": "バター", "quantity": "15", "unit": "g"}
- 牛乳 200ml → {"item": "牛乳", "quantity": "200", "unit": "ml"}
- 砂糖 30g → {"item": "砂糖", "quantity": "30", "unit": "g"}

【分量・単位抽出の重要ルール】
1. 材料名、分量、単位を必ず分離してください
2. 分量は数値のみ（"100"）、単位は文字のみ（"g"）
3. 全角数字は半角に変換してください
4. 日本語単位も正確に抽出（大さじ、小さじ、カップ、個、枚、本）
5. 適量、少々、お好みなどは分量フィールドに入れてください
6. 価格情報（円）があれば別途抽出してください

【重要】
- 材料は必ずingredients配列に含める
- 分量と単位は正確に分離（最重要）
- 日本語文字を保護
- JSONのみ出力（説明文なし）`;
      } else {
        // 海外サイト用のプロンプト（言語別対応）
        const languageInstructions = {
          'fr': {
            language: 'French',
            keywords: 'recette, ingrédients, préparation',
            example: 'Exemple: "250g de farine" → {"item": "farine", "quantity": "250", "unit": "g"}'
          },
          'it': {
            language: 'Italian', 
            keywords: 'ricetta, ingredienti, preparazione',
            example: 'Esempio: "250g di farina" → {"item": "farina", "quantity": "250", "unit": "g"}'
          },
          'de': {
            language: 'German',
            keywords: 'rezept, zutaten, zubereitung', 
            example: 'Beispiel: "250g Mehl" → {"item": "Mehl", "quantity": "250", "unit": "g"}'
          },
          'es': {
            language: 'Spanish',
            keywords: 'receta, ingredientes, preparación',
            example: 'Ejemplo: "250g de harina" → {"item": "harina", "quantity": "250", "unit": "g"}'
          },
          'en': {
            language: 'English',
            keywords: 'recipe, ingredients, instructions',
            example: 'Example: "250g flour" → {"item": "flour", "quantity": "250", "unit": "g"}'
          }
        };
        
        const langInfo = languageInstructions[siteLanguage.code] || languageInstructions['en'];
        
        return `You are a professional recipe extraction system specialized in ${langInfo.language} content. Extract recipe information from the following HTML content.

LANGUAGE SPECIFIC REQUIREMENTS:
- Detect and preserve ${langInfo.language} text accurately
- Look for keywords like: ${langInfo.keywords}
- Maintain original language in the extracted content
- Handle character encoding properly for ${langInfo.language}

Extract the following recipe information:
- Title (recipe name in original language)
- Description (recipe overview in original language)
- Servings (number of people)
- Ingredients list (separate name, quantity, unit)
- Instructions/steps (in original language)

Output format must be JSON with this structure:
{
  "title": "Recipe title in ${langInfo.language}",
  "description": "Recipe description in ${langInfo.language}",
  "servings": "Number of servings",
  "ingredients": [
    {
      "item": "ingredient name in ${langInfo.language}",
      "quantity": "amount",
      "unit": "unit in ${langInfo.language}"
    }
  ],
  "steps": [
    "Step 1 content in ${langInfo.language}",
    "Step 2 content in ${langInfo.language}"
  ]
}

INGREDIENT EXTRACTION EXAMPLES:
${langInfo.example}
- "250g flour" → {"item": "flour", "quantity": "250", "unit": "g"}
- "2 tbsp olive oil" → {"item": "olive oil", "quantity": "2", "unit": "tbsp"}
- "1 large onion" → {"item": "onion", "quantity": "1", "unit": "large"}
- "Salt to taste" → {"item": "salt", "quantity": "to taste", "unit": ""}

CRITICAL INGREDIENT PARSING RULES:
1. ALWAYS separate ingredient name, quantity, and unit into different fields
2. Quantity should be numbers only ("250", "2", "1")
3. Unit should be text only ("g", "tbsp", "large", "cup")
4. Handle fractions properly ("1/2" → "0.5" or keep as "1/2")
5. Extract "to taste", "as needed" as quantity values
6. Preserve original ${langInfo.language} units and measurements

HTML Content:
${htmlContent.substring(0, 8000)}

IMPORTANT: 
- Return only valid JSON (no explanatory text)
- Preserve original ${langInfo.language} text
- Ensure proper character encoding
- Separate ingredients into item, quantity, and unit fields accurately (MOST IMPORTANT)`;
      }
    }

    // Recipe Keeper.app風のデータ正規化関数
    function normalizeRecipeData(recipeData) {
      console.log('🔧 レシピデータ正規化開始');
      
      const normalized = {
        title: recipeData.title || 'タイトル不明',
        description: recipeData.description || '',
        servings: recipeData.servings || '',
        ingredients: [],
        steps: [],
        notes: recipeData.notes || ''
      };
      
      // 材料の正規化
      if (recipeData.ingredients && Array.isArray(recipeData.ingredients)) {
        normalized.ingredients = recipeData.ingredients.map(ingredient => {
          return normalizeIngredientObject(ingredient);
        });
      }
      
      // 手順の正規化
      if (recipeData.steps && Array.isArray(recipeData.steps)) {
        normalized.steps = recipeData.steps.map((step, index) => {
          if (typeof step === 'string') {
            return step;
          } else if (step && typeof step === 'object') {
            return step.instruction || step.step || step.text || `手順${index + 1}`;
          }
          return `手順${index + 1}`;
        });
      }
      
      console.log('✅ データ正規化完了:', normalized);
      return normalized;
    }

    // Recipe Keeper.app風のフォールバック解析関数
    function fallbackAnalysis(content, url) {
      console.log('🔄 フォールバック解析を開始');
      
      const lines = content.split('\n').filter(line => line.trim());
      const ingredients = [];
      const steps = [];
      let title = 'レシピ';
      let description = '';
      
      // タイトルを推測
      for (const line of lines.slice(0, 10)) {
        if (line.length > 5 && line.length < 100 && !line.includes('{') && !line.includes('"')) {
          title = line.trim();
          break;
        }
      }
      
      // 日本語サイトかどうかを判定
      const isJapanese = url && (
        url.includes('.jp') || 
        url.includes('cookpad.com') || 
        url.includes('kurashiru.com')
      ) || /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(content);
      
      // 材料らしい行を検出
      for (const line of lines) {
        if (isIngredientLine(line, isJapanese)) {
          const ingredient = parseIngredientLine(line, isJapanese);
          if (ingredient) {
            ingredients.push(ingredient);
          }
        }
      }
      
      // 手順らしい行を検出
      for (const line of lines) {
        if (isStepLine(line, isJapanese)) {
          const step = cleanStepText(line);
          if (step) {
            steps.push(step);
          }
        }
      }
      
      const fallbackData = {
        title: title,
        description: description,
        servings: '',
        ingredients: ingredients,
        steps: steps,
        notes: 'フォールバック解析により生成'
      };
      
      console.log('🔄 フォールバック解析完了:', fallbackData);
      return fallbackData;
    }

    // 材料行かどうかを判定（Recipe Keeper.app準拠）
    function isIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      // 基本的な除外条件
      if (!trimmed || 
          trimmed.length < 2 || 
          trimmed.length > 150 ||
          trimmed.includes('作り方') || 
          trimmed.includes('手順') ||
          trimmed.includes('Instructions') ||
          trimmed.includes('Method') ||
          trimmed.includes('Steps')) {
        return false;
      }
      
      if (isJapanese) {
        // 日本語の材料パターン（Recipe Keeper.app準拠）
        return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(trimmed) && 
               (
                 // 数字+日本語単位
                 /\d+[gmlカップ大さじ小さじ個枚本袋缶適量少々]/.test(trimmed) ||
                 // 全角数字+日本語単位
                 /[０-９]+[ｇｍｌカップ大さじ小さじ個枚本袋缶適量少々]/.test(trimmed) ||
                 // コロン区切り
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[：:]\s*\d/.test(trimmed) ||
                 // 特殊分量
                 /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+\s*[：:]\s*(適量|少々|お好み|ひとつまみ|ひと振り)/.test(trimmed) ||
                 // 価格情報
                 /\d+円/.test(trimmed)
               );
      } else {
        // 英語の材料パターン（Recipe Keeper.app準拠）
        return (
          // 標準的な単位
          /\d+\s*(g|ml|cup|tbsp|tsp|oz|lb|kg|l|dl|cl)/.test(trimmed) ||
          // 分数
          /\d+\/\d+/.test(trimmed) ||
          // サイズ表現
          /\d+\s+(large|medium|small|whole|piece|slice)/.test(trimmed) ||
          // ダッシュ区切り
          /\w+\s*[-–—]\s*\d+/.test(trimmed) ||
          // コロン区切り
          /\w+\s*:\s*\d+/.test(trimmed) ||
          // 特殊表現
          /(to taste|as needed|pinch|dash)/.test(trimmed.toLowerCase())
        );
      }
    }

    // 材料行を解析（Recipe Keeper.app最適化版）
    function parseIngredientLine(line, isJapanese = false) {
      const trimmed = line.trim();
      console.log('🔍 材料行解析:', trimmed);
      
      if (isJapanese) {
        // 日本語材料の高精度解析（Recipe Keeper.app準拠）
        
        // パターン1: "材料名 分量単位 価格円"
        const pattern1 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)\s+(\d+)円$/);
        if (pattern1) {
          console.log('✅ パターン1適用: 材料名+分量単位+価格');
          return {
            item: pattern1[1].trim(),
            quantity: pattern1[2].trim(),
            unit: pattern1[3].trim(),
            price: pattern1[4].trim()
          };
        }

        // パターン2: "材料名 価格円"
        const pattern2 = trimmed.match(/^(.+?)\s+(\d+)円$/);
        if (pattern2) {
          console.log('✅ パターン2適用: 材料名+価格');
          return {
            item: pattern2[1].trim(),
            quantity: '',
            unit: '',
            price: pattern2[2].trim()
          };
        }

        // パターン3: "材料名 分量単位"
        const pattern3 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)$/);
        if (pattern3) {
          console.log('✅ パターン3適用: 材料名+分量単位');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // パターン4: "材料名 分量"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern4) {
          console.log('✅ パターン4適用: 材料名+分量');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: ''
          };
        }

        // パターン5: "材料名：分量単位" (コロン区切り)
        const pattern5 = trimmed.match(/^(.+?)\s*[：:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern5) {
          console.log('✅ パターン5適用: 材料名：分量単位');
          return {
            item: pattern5[1].trim(),
            quantity: pattern5[2].trim(),
            unit: pattern5[3].trim() || ''
          };
        }

        // パターン6: "材料名：分量" (コロン区切り、単位なし)
        const pattern6 = trimmed.match(/^(.+?)\s*[：:]\s*(\d+(?:\.\d+)?(?:\/\d+)?)$/);
        if (pattern6) {
          console.log('✅ パターン6適用: 材料名：分量');
          return {
            item: pattern6[1].trim(),
            quantity: pattern6[2].trim(),
            unit: ''
          };
        }

        // パターン7: "材料名：適量・少々" (特殊分量)
        const pattern7 = trimmed.match(/^(.+?)\s*[：:]\s*(適量|少々|お好み|ひとつまみ|ひと振り)$/);
        if (pattern7) {
          console.log('✅ パターン7適用: 材料名：特殊分量');
          return {
            item: pattern7[1].trim(),
            quantity: pattern7[2].trim(),
            unit: ''
          };
        }

        // パターン8: 全角数字対応
        const pattern8 = trimmed.match(/^(.+?)\s+([０-９]+(?:\.[０-９]+)?)\s*([a-zA-Zgmlカップ大さじ小さじ個枚本袋缶適量少々\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]*)$/);
        if (pattern8) {
          console.log('✅ パターン8適用: 全角数字');
          // 全角数字を半角に変換
          const quantity = pattern8[2].replace(/[０-９]/g, (match) => String.fromCharCode(match.charCodeAt(0) - 0xFEE0));
          return {
            item: pattern8[1].trim(),
            quantity: quantity,
            unit: pattern8[3].trim() || ''
          };
        }

      } else {
        // 英語材料の高精度解析
        
        // パターン1: "quantity unit ingredient"
        const pattern1 = trimmed.match(/^(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)\s+(.+)$/);
        if (pattern1) {
          console.log('✅ 英語パターン1: quantity unit ingredient');
          return {
            item: pattern1[3].trim(),
            quantity: pattern1[1].trim(),
            unit: pattern1[2].trim()
          };
        }

        // パターン2: "ingredient - quantity unit"
        const pattern2 = trimmed.match(/^(.+?)\s*[-–—]\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern2) {
          console.log('✅ 英語パターン2: ingredient - quantity unit');
          return {
            item: pattern2[1].trim(),
            quantity: pattern2[2].trim(),
            unit: pattern2[3].trim()
          };
        }

        // パターン3: "ingredient: quantity unit"
        const pattern3 = trimmed.match(/^(.+?)\s*:\s*(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern3) {
          console.log('✅ 英語パターン3: ingredient: quantity unit');
          return {
            item: pattern3[1].trim(),
            quantity: pattern3[2].trim(),
            unit: pattern3[3].trim()
          };
        }

        // パターン4: "ingredient quantity unit"
        const pattern4 = trimmed.match(/^(.+?)\s+(\d+(?:\.\d+)?(?:\/\d+)?)\s*(\w+)$/);
        if (pattern4) {
          console.log('✅ 英語パターン4: ingredient quantity unit');
          return {
            item: pattern4[1].trim(),
            quantity: pattern4[2].trim(),
            unit: pattern4[3].trim()
          };
        }
      }
      
      console.log('⚠️ フォールバック: パターンマッチ失敗');
      // フォールバック: 材料名のみ
      return {
        item: trimmed,
        quantity: '',
        unit: ''
      };
    }

    // 手順行かどうかを判定
    function isStepLine(line, isJapanese = false) {
      const trimmed = line.trim();
      
      if (isJapanese) {
        return /^\d+[．.]/.test(trimmed) ||
               /^[０-９]+[．.]/.test(trimmed) ||
               /^手順\s*\d+/.test(trimmed) ||
               /作り方|手順|方法/.test(trimmed);
      } else {
        return /^\d+\./.test(trimmed) ||
               /^step\s+\d+/i.test(trimmed) ||
               /^instruction/i.test(trimmed);
      }
    }

    // 保存ボタンの表示制御
    function showSaveButtons() {
      const saveSection = document.getElementById('saveSection');
      const translationSection = document.getElementById('translationSection');
      const saveModeBothLabel = document.getElementById('saveModeBothLabel');
      const saveModeTranslatedLabel = document.getElementById('saveModeTranslatedLabel');
      const saveModeHint = document.getElementById('saveModeHint');
      
      if (saveSection) {
        saveSection.style.display = 'block';
      }
      
      const hasTranslation = translationSection && translationSection.style.display !== 'none';
      if (saveModeBothLabel && saveModeTranslatedLabel) {
        // 有効/無効を切り替え
        const bothRadio = saveModeBothLabel.querySelector('input[type="radio"]');
        const transRadio = saveModeTranslatedLabel.querySelector('input[type="radio"]');
        if (hasTranslation) {
          saveModeBothLabel.style.opacity = '1';
          saveModeTranslatedLabel.style.opacity = '1';
          bothRadio.disabled = false;
          transRadio.disabled = false;
          if (saveModeHint) saveModeHint.textContent = '保存モードを選択して「選択して保存」を押してください。';
        } else {
          saveModeBothLabel.style.opacity = '0.7';
          saveModeTranslatedLabel.style.opacity = '0.7';
          bothRadio.disabled = true;
          transRadio.disabled = true;
          if (saveModeHint) saveModeHint.textContent = '翻訳後に「翻訳のみ」「原語＋翻訳」が選べるようになります。';
        }
      }
    }

    // レシピをデータベースに保存する関数
    async function saveRecipeToDatabase(recipeData, isTranslated = false) {
      if (!sb) {
        alert('データベース接続が確立されていません');
        return;
      }

      try {
        console.log('保存するレシピデータ:', recipeData);
        
        // レシピ本体を保存
        // servingsを適切な数値に変換
        let servingsValue = null;
        if (recipeData.servings) {
          const parsed = parseInt(recipeData.servings);
          if (!isNaN(parsed)) {
            servingsValue = parsed;
          }
        }
        
        const { data: savedRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: recipeData.title || '無題のレシピ',
            description: recipeData.description || null,
            servings: servingsValue,
            category: recipeData.category || 'その他',
            tags: recipeData.tags || ['URL取り込み'],
            notes: recipeData.notes || null,
            source_url: recipeData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('レシピ保存エラー:', recipeError);
          throw new Error(`レシピ保存に失敗しました: ${recipeError.message}`);
        }

        const recipeId = savedRecipe.id;
        console.log('保存されたレシピID:', recipeId, 'タイプ:', typeof recipeId);
        console.log('レシピ保存成功:', recipeId);

        // 材料を保存
        if (recipeData.ingredients && recipeData.ingredients.length > 0) {
          const ingredientsToSave = recipeData.ingredients.map((ing, index) => {
            console.log(`材料 ${index + 1}:`, {
              item: ing.item || ing.name,
              quantity: ing.quantity,
              unit: ing.unit,
              original: ing
            });
            
            return {
              recipe_id: recipeId,
              position: index + 1,
              item: ing.item || ing.name || '',
              quantity: ing.quantity || null,
              unit: ing.unit || null,
              price: null
            };
          });

          console.log('保存する材料データ:', ingredientsToSave);

          const { error: ingredientsError } = await sb
            .from('recipe_ingredients')
            .insert(ingredientsToSave);

          if (ingredientsError) {
            console.error('材料保存エラー:', ingredientsError);
          } else {
            console.log('✅ 材料保存成功');
          }
        }

        // 手順を保存
        if (recipeData.steps && recipeData.steps.length > 0) {
          const stepsToSave = recipeData.steps.map((step, index) => ({
            recipe_id: recipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));

          const { error: stepsError } = await sb
            .from('recipe_steps')
            .insert(stepsToSave);

          if (stepsError) {
            console.error('手順保存エラー:', stepsError);
          }
        }

        alert('✅ レシピが正常に保存されました！\n\nレシピ詳細ページで確認できます。');
        
        // レシピ詳細ページへのリンクを表示
        if (confirm('保存したレシピを見ますか？')) {
          window.location.href = `recipe_detail.html?id=${recipeId}`;
        } else if (confirm('トップページに移動しますか？')) {
          window.location.href = '../index.html';
        }

      } catch (error) {
        console.error('保存処理エラー:', error);
        alert('❌ レシピの保存に失敗しました:\n' + error.message);
      }
    }

    // 保存ボタンのイベントリスナー
    document.getElementById('saveByModeButton')?.addEventListener('click', async () => {
      const mode = (document.querySelector('input[name="saveMode"]:checked')?.value) || 'original';
      const urlInput = document.getElementById('urlInput');
      
      if (mode === 'original') {
        if (!currentRecipeData) {
          alert('保存するレシピがありません');
          return;
        }
        const saveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URL取り込み']
        };
        await saveRecipeToDatabase(saveData, false);
        return;
      }

      // 翻訳データ抽出
      const translatedTitle = document.getElementById('translatedRecipeTitle')?.textContent;
      const translatedDescription = document.getElementById('translatedRecipeDescription')?.textContent;
      const translatedServings = document.getElementById('translatedRecipeServings')?.textContent;
      
      if (!translatedTitle || translatedTitle === '-') {
        alert('翻訳結果がありません');
        return;
      }
      
      // テーブル形式の翻訳材料を抽出
      const translatedIngredientsRaw = extractTranslatedIngredients();
      const translatedIngredients = ensureIngredientSectionTitles(currentRecipeData?.ingredients, translatedIngredientsRaw);
      const translatedSteps = extractTranslatedSteps();

      const translatedSaveData = {
        title: translatedTitle,
        description: translatedDescription !== '-' ? translatedDescription : '',
        servings: translatedServings !== '-' ? translatedServings : '',
        ingredients: translatedIngredients,
        steps: translatedSteps,
        source_url: urlInput ? urlInput.value : '',
        tags: ['翻訳', 'URL取り込み'],
        category: '翻訳'
      };

      if (mode === 'translated') {
        await saveRecipeToDatabase(translatedSaveData, true);
        return;
      }

      if (mode === 'both') {
        // 1) 元のレシピを保存（手動でIDを取得）
        const originalSaveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URL取り込み', '翻訳元']
        };

        // servingsを数値化
        let servingsValue = null;
        if (originalSaveData.servings) {
          const parsed = parseInt(originalSaveData.servings);
          if (!isNaN(parsed)) servingsValue = parsed;
        }

        const { data: savedOriginalRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: originalSaveData.title || '無題のレシピ',
            description: originalSaveData.description || null,
            servings: servingsValue,
            category: originalSaveData.category || 'その他',
            tags: originalSaveData.tags || ['URL取り込み'],
            notes: originalSaveData.notes || null,
            source_url: originalSaveData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('元のレシピ保存エラー:', recipeError);
          throw new Error(`元のレシピ保存に失敗しました: ${recipeError.message}`);
        }

        const originalRecipeId = savedOriginalRecipe.id;

        // 材料
        if (originalSaveData.ingredients && originalSaveData.ingredients.length > 0) {
          const ingredientsToSave = originalSaveData.ingredients.map((ing, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            item: ing.item || ing.name || '',
            quantity: ing.quantity || null,
            unit: ing.unit || null,
            price: null
          }));
          const { error: ingredientsError } = await sb.from('recipe_ingredients').insert(ingredientsToSave);
          if (ingredientsError) console.error('材料保存エラー:', ingredientsError);
        }

        // 手順
        if (originalSaveData.steps && originalSaveData.steps.length > 0) {
          const stepsToSave = originalSaveData.steps.map((step, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));
          const { error: stepsError } = await sb.from('recipe_steps').insert(stepsToSave);
          if (stepsError) console.error('手順保存エラー:', stepsError);
        }

        // 2) 翻訳レシピをtranslation_*テーブルに保存
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const languageCode = targetLanguageSelect ? targetLanguageSelect.value : DEFAULT_TRANSLATION_LANGUAGE;
        const translationRecipeId = await saveTranslationRecipe(
          originalRecipeId,
          originalSaveData,
          {
            ...translatedSaveData,
            ingredients: ensureIngredientSectionTitles(originalSaveData.ingredients, translatedSaveData.ingredients)
          },
          languageCode
        );

        alert('✅ 元のレシピと翻訳レシピの両方が保存されました');
        if (confirm('元のレシピを表示しますか？')) {
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
        }
        return;
      }
    });

    // 翻訳レシピをtranslation_recipesテーブルに保存する関数
    async function saveTranslationRecipe(originalRecipeId, originalData, translatedData, languageCode) {
      if (!sb) {
        alert('データベース接続が確立されていません');
        return null;
      }

      try {
        console.log('翻訳レシピを保存中...', { originalRecipeId, languageCode });

        // 翻訳レシピ本体を保存
        const { data: savedTranslation, error: translationError } = await sb
          .from('translation_recipes')
          .insert({
            original_recipe_id: originalRecipeId,
            original_title: originalData.title || '無題のレシピ',
            translated_title: translatedData.title || '無題のレシピ',
            original_description: originalData.description || null,
            translated_description: translatedData.description || null,
            servings: translatedData.servings ? parseInt(translatedData.servings) : null,
            language_code: languageCode,
            category: '翻訳レシピ',
            tags: ['翻訳', '多言語', 'URL取り込み']
          })
          .select()
          .single();

        if (translationError) {
          console.error('翻訳レシピ保存エラー:', translationError);
          throw new Error(`翻訳レシピ保存に失敗しました: ${translationError.message}`);
        }

        const translationRecipeId = savedTranslation.id;
        console.log('翻訳レシピ保存成功:', translationRecipeId);

        // 翻訳された材料を保存
        if (translatedData.ingredients && translatedData.ingredients.length > 0) {
          const translatedIngredientsToSave = translatedData.ingredients.map((ing, index) => {
            const originalIng = originalData.ingredients?.[index] || {};
            return {
              translation_recipe_id: translationRecipeId,
              position: index + 1,
              original_item: originalIng.item || originalIng.name || null,
              translated_item: ing.item || ing.name || null,
              quantity: ing.quantity || null,
              unit: ing.unit || null,
              price: null
            };
          });

          const { error: ingredientsError } = await sb
            .from('translation_recipe_ingredients')
            .insert(translatedIngredientsToSave);

          if (ingredientsError) {
            console.error('翻訳材料保存エラー:', ingredientsError);
          } else {
            console.log('✅ 翻訳材料保存成功');
          }
        }

        // 翻訳された手順を保存
        if (translatedData.steps && translatedData.steps.length > 0) {
          const translatedStepsToSave = translatedData.steps.map((step, index) => {
            const originalStep = originalData.steps?.[index] || '';
            const translatedInstruction = typeof step === 'string' ? step : step.instruction || step.text || '';
            const originalInstruction = typeof originalStep === 'string' ? originalStep : originalStep.instruction || originalStep.text || '';

            return {
              translation_recipe_id: translationRecipeId,
              position: index + 1,
              original_instruction: originalInstruction || null,
              translated_instruction: translatedInstruction || null
            };
          });

          const { error: stepsError } = await sb
            .from('translation_recipe_steps')
            .insert(translatedStepsToSave);

          if (stepsError) {
            console.error('翻訳手順保存エラー:', stepsError);
          } else {
            console.log('✅ 翻訳手順保存成功');
          }
        }

        return translationRecipeId;

      } catch (error) {
        console.error('翻訳レシピ保存処理エラー:', error);
        throw error;
      }
    }

    // 「両方を保存」ボタンのイベントリスナー
    document.getElementById('saveBothButton')?.addEventListener('click', async () => {
      if (!currentRecipeData) {
        alert('保存するレシピがありません');
        return;
      }

      try {
        // 1. まず元のレシピを保存
        const urlInput = document.getElementById('urlInput');
        const originalSaveData = {
          ...currentRecipeData,
          source_url: urlInput ? urlInput.value : '',
          tags: ['URL取り込み', '翻訳元']
        };

        console.log('ステップ1: 元のレシピを保存中...');
        
        // servingsを適切な数値に変換
        let servingsValue = null;
        if (originalSaveData.servings) {
          const parsed = parseInt(originalSaveData.servings);
          if (!isNaN(parsed)) {
            servingsValue = parsed;
          }
        }
        
        const { data: savedOriginalRecipe, error: recipeError } = await sb
          .from('recipes')
          .insert({
            title: originalSaveData.title || '無題のレシピ',
            description: originalSaveData.description || null,
            servings: servingsValue,
            category: originalSaveData.category || 'その他',
            tags: originalSaveData.tags || ['URL取り込み'],
            notes: originalSaveData.notes || null,
            source_url: originalSaveData.source_url || null,
            is_groq_generated: true
          })
          .select()
          .single();

        if (recipeError) {
          console.error('元のレシピ保存エラー:', recipeError);
          throw new Error(`元のレシピ保存に失敗しました: ${recipeError.message}`);
        }

        const originalRecipeId = savedOriginalRecipe.id;
        console.log('✅ 元のレシピ保存成功:', originalRecipeId);

        // 材料を保存
        if (originalSaveData.ingredients && originalSaveData.ingredients.length > 0) {
          const ingredientsToSave = originalSaveData.ingredients.map((ing, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            item: ing.item || ing.name || '',
            quantity: ing.quantity || null,
            unit: ing.unit || null,
            price: null
          }));

          const { error: ingredientsError } = await sb
            .from('recipe_ingredients')
            .insert(ingredientsToSave);

          if (ingredientsError) {
            console.error('材料保存エラー:', ingredientsError);
          }
        }

        // 手順を保存
        if (originalSaveData.steps && originalSaveData.steps.length > 0) {
          const stepsToSave = originalSaveData.steps.map((step, index) => ({
            recipe_id: originalRecipeId,
            position: index + 1,
            instruction: typeof step === 'string' ? step : step.instruction || step.text || '',
            step_number: index + 1
          }));

          const { error: stepsError } = await sb
            .from('recipe_steps')
            .insert(stepsToSave);

          if (stepsError) {
            console.error('手順保存エラー:', stepsError);
          }
        }

        // 2. 翻訳されたレシピを取得
        console.log('ステップ2: 翻訳レシピを取得中...');
        
        const translatedTitle = document.getElementById('translatedRecipeTitle')?.textContent;
        const translatedDescription = document.getElementById('translatedRecipeDescription')?.textContent;
        const translatedServings = document.getElementById('translatedRecipeServings')?.textContent;
        
        if (!translatedTitle || translatedTitle === '-') {
          alert('翻訳レシピが見つかりません。元のレシピのみ保存しました。');
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
          return;
        }

        // 翻訳された材料を取得
        // テーブル形式の翻訳材料を抽出
        const translatedIngredients = extractTranslatedIngredients();
        const translatedSteps = extractTranslatedSteps();

        const translatedSaveData = {
          title: translatedTitle,
          description: translatedDescription !== '-' ? translatedDescription : '',
          servings: translatedServings !== '-' ? translatedServings : '',
          ingredients: translatedIngredients,
          steps: translatedSteps
        };

        // 3. 翻訳レシピを保存
        console.log('ステップ3: 翻訳レシピを保存中...');
        
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const languageCode = targetLanguageSelect ? targetLanguageSelect.value : DEFAULT_TRANSLATION_LANGUAGE;
        
        const translationRecipeId = await saveTranslationRecipe(
          originalRecipeId,
          originalSaveData,
          {
            ...translatedSaveData,
            ingredients: ensureIngredientSectionTitles(originalSaveData.ingredients, translatedSaveData.ingredients)
          },
          languageCode
        );

        console.log('✅ 翻訳レシピ保存成功:', translationRecipeId);

        // 完了メッセージ
        alert('✅ 元のレシピと翻訳レシピの両方が正常に保存されました！\n\n元のレシピID: ' + originalRecipeId + '\n翻訳レシピID: ' + translationRecipeId);
        
        // 元のレシピ詳細ページへ移動
        if (confirm('元のレシピを見ますか？')) {
          window.location.href = `recipe_detail.html?id=${originalRecipeId}`;
        } else if (confirm('トップページに移動しますか？')) {
          window.location.href = '../index.html';
        }

      } catch (error) {
        console.error('両方保存処理エラー:', error);
        alert('❌ レシピの保存に失敗しました:\n' + error.message);
      }
    });

  </script>
  <script>
    // 元ページプレビュー制御
    (function() {
      const urlInput = document.getElementById('urlInput');
      const previewUrl = document.getElementById('sourcePreviewUrl');
      const btn = document.getElementById('loadSourcePreviewBtn');
      const pane = document.getElementById('sourcePreviewPane');
      const frame = document.getElementById('sourcePreviewFrame');
      const info = document.getElementById('sourcePreviewInfo');
      const dockRight = document.getElementById('dockPreviewRight');
      const split = document.getElementById('sourcePreviewSplit');

      if (!btn || !frame) return;

      // URLフィールド連動
      if (urlInput && previewUrl) {
        previewUrl.value = urlInput.value || '';
        urlInput.addEventListener('change', () => { previewUrl.value = urlInput.value; });
      }

      btn.addEventListener('click', async () => {
        try {
          const url = (previewUrl.value || urlInput.value || '').trim();
          if (!url) { alert('URLを入力してください'); return; }
          pane.style.display = 'block';
          info.textContent = '読み込み中…';

          // 直接埋め込みをまず試す（失敗してもcatchしない）
          try {
            frame.removeAttribute('srcdoc');
            frame.src = url;
            // 2秒後に見えなければプロキシへ切替
            setTimeout(async () => {
              const blankLike = !frame.contentWindow || !frame.contentDocument || frame.contentDocument.body.children.length === 0;
              if (blankLike) {
                const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
                // 安全のため <script> を除去し、<base> を付与して相対パスを解決
                const sanitized = String(raw)
                  .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                  .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
                  .replace(/on\w+\s*=\s*'[^']*'/gi, '')
                  .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
                const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
                const adCss = `<style>
                  [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
                  header nav, footer { display:none !important; }
                  body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
                </style>`;
                const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
                const blob = new Blob([wrapped], { type: 'text/html' });
                const objectUrl = URL.createObjectURL(blob);
                frame.src = objectUrl;
                info.textContent = 'プロキシ経由で表示（blob）';
              } else {
                info.textContent = '直接表示';
              }
            }, 2000);
          } catch (_) {
            const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
            const sanitized = String(raw)
              .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
              .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
              .replace(/on\w+\s*=\s*'[^']*'/gi, '')
              .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
            const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
            const adCss = `<style>
              [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
              header nav, footer { display:none !important; }
              body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
            </style>`;
            const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
            const blob = new Blob([wrapped], { type: 'text/html' });
            const objectUrl = URL.createObjectURL(blob);
            frame.src = objectUrl;
            info.textContent = 'プロキシ経由で表示（blob）';
          }
        } catch (e) {
          console.error('プレビュー読み込みエラー:', e);
          alert('元ページの読み込みに失敗しました: ' + e.message);
          info.textContent = '読み込み失敗';
        }
      });

      dockRight.addEventListener('change', () => {
        // 右にドック: iframe 50% + 右側に編集（既存UI）を想定 → ここでは左右分割の方向だけ変更
        split.style.flexDirection = dockRight.checked ? 'row' : 'column';
        frame.style.width = dockRight.checked ? '50%' : '100%';
      });

      // 分離テーブル表示機能はユーザー要望により無効化（従来表示）
    })();
  </script>
  <script>
    // 元言語の材料リストをその場編集（ダブルクリックで編集）
    function enableInlineIngredientEditing(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      if (container.__inlineEditBound) return; // 重複バインド防止
      container.__inlineEditBound = true;
      const commit = (grid, newName, newQty, newUnit, writeDom = false) => {
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        if (writeDom) {
          nameDiv.textContent = newName;
          qtyDiv.textContent = newQty;
          unitDiv.textContent = newUnit;
        }
        if (window.currentRecipeData?.ingredients) {
          // data-ing-index があればインデックスで更新、なければ名前一致
          const idxAttr = grid.getAttribute('data-ing-index');
          let target = null;
          if (idxAttr && window.currentRecipeData.ingredients[parseInt(idxAttr)]) {
            target = window.currentRecipeData.ingredients[parseInt(idxAttr)];
          } else {
            const currentName = (newName || '').trim();
            const idx = window.currentRecipeData.ingredients.findIndex(ing => (ing.item || ing.name || '').trim() === currentName);
            target = idx >= 0 ? window.currentRecipeData.ingredients[idx] : null;
          }
          if (target) {
            target.item = newName; target.name = newName; target.quantity = newQty; target.unit = newUnit;
          }
        }
      };

      // contentEditableの変更をブラー時に反映
      container.addEventListener('focusout', (e) => {
        const grid = e.target.closest('.recipe-ingredients-grid');
        if (!grid) return;
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        commit(grid, nameDiv.textContent.trim(), qtyDiv.textContent.trim(), unitDiv.textContent.trim(), true);
      });

      // 入力中もデータ更新（軽量）
      container.addEventListener('input', (e) => {
        const grid = e.target.closest('.recipe-ingredients-grid');
        if (!grid) return;
        const nameDiv = grid.querySelector('.ingredient-name');
        const qtyDiv = grid.querySelector('.ingredient-quantity');
        const unitDiv = grid.querySelector('.ingredient-unit');
        // 入力中はDOMを書き換えず、データのみ更新（IMEの確定中にカーソルが飛ぶのを防止）
        commit(grid, nameDiv.textContent.trim(), qtyDiv.textContent.trim(), unitDiv.textContent.trim(), false);
      });
    }

    // 元言語の手順リストをその場編集
    function enableInlineStepsEditing(containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;
      if (container.__inlineStepBound) return;
      container.__inlineStepBound = true;

      const sync = (el, writeDom = false) => {
        const idxAttr = el.getAttribute('data-step-index');
        if (!idxAttr) return;
        const idx = parseInt(idxAttr);
        let text = (el.textContent || '').trim();
        // 先頭の連番「N. 」を取り除いて中身だけ保存
        text = text.replace(/^\d+\.?\s*/, '');
        if (!Array.isArray(window.currentRecipeData?.steps)) return;
        const original = window.currentRecipeData.steps[idx];
        if (typeof original === 'object') {
          window.currentRecipeData.steps[idx].step = text;
          window.currentRecipeData.steps[idx].instruction = text;
          window.currentRecipeData.steps[idx].text = text;
        } else {
          window.currentRecipeData.steps[idx] = text;
        }
        if (writeDom) {
          // 表示の連番は維持（再整形）
          el.textContent = `${idx + 1}. ${text}`;
        }
      };

      container.addEventListener('input', (e) => {
        const el = e.target.closest('.step-item');
        if (!el) return;
        // 入力中はDOMを書き換えずデータのみ更新
        sync(el, false);
      });

      container.addEventListener('focusout', (e) => {
        const el = e.target.closest('.step-item');
        if (!el) return;
        // フォーカスアウトで表示を整形
        sync(el, true);
      });
    }

    // 原語：インライン編集の追加/適用
    function addInlineIngredientRow() {
      const container = document.getElementById('flexibleIngredientsDisplay');
      if (!container) return;
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      gridDiv.setAttribute('data-ing-index', String(window.currentRecipeData?.ingredients?.length || 0));
      const nameDiv = document.createElement('div');
      nameDiv.className = 'ingredient-name';
      nameDiv.contentEditable = 'true';
      nameDiv.spellcheck = false;
      nameDiv.textContent = '';
      const qtyDiv = document.createElement('div');
      qtyDiv.className = 'ingredient-quantity';
      qtyDiv.contentEditable = 'true';
      qtyDiv.spellcheck = false;
      qtyDiv.textContent = '';
      const unitDiv = document.createElement('div');
      unitDiv.className = 'ingredient-unit';
      unitDiv.contentEditable = 'true';
      unitDiv.spellcheck = false;
      unitDiv.textContent = '';
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      container.appendChild(gridDiv);
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      window.currentRecipeData.ingredients.push({ item: '', quantity: '', unit: '' });
    }

    // 指定セクションに材料行を追加
    function addIngredientRowToSection(sectionDiv) {
      if (!sectionDiv) return;
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      const nameDiv = document.createElement('div');
      nameDiv.className = 'ingredient-name';
      nameDiv.contentEditable = 'true';
      nameDiv.spellcheck = false;
      const qtyDiv = document.createElement('div');
      qtyDiv.className = 'ingredient-quantity';
      qtyDiv.contentEditable = 'true';
      qtyDiv.spellcheck = false;
      const unitDiv = document.createElement('div');
      unitDiv.className = 'ingredient-unit';
      unitDiv.contentEditable = 'true';
      unitDiv.spellcheck = false;
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      // セクション内の追加ボタンの直前に挿入
      const actions = sectionDiv.querySelector('.inline-actions:last-of-type');
      if (actions) {
        sectionDiv.insertBefore(gridDiv, actions);
      } else {
        sectionDiv.appendChild(gridDiv);
      }
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      // sectionTitleを付与して保存（翻訳/再描画でカテゴリ維持）
      const sectionTitle = sectionDiv.getAttribute('data-section-title') || sectionDiv.querySelector('.recipe-section-title')?.textContent || '';
      window.currentRecipeData.ingredients.push({ item: '', quantity: '', unit: '', sectionTitle });
    }

    function addInlineStepRow() {
      const stepsList = document.getElementById('stepsList');
      if (!stepsList) return;
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.steps)) window.currentRecipeData.steps = [];
      const idx = window.currentRecipeData.steps.length;
      window.currentRecipeData.steps.push('');
      const item = document.createElement('div');
      item.className = 'step-item';
      item.setAttribute('data-step-index', String(idx));
      item.contentEditable = 'true';
      item.spellcheck = false;
      item.textContent = `${idx + 1}. `;
      stepsList.appendChild(item);
    }

    function addInlineCategoryBlock() {
      const container = document.getElementById('flexibleIngredientsDisplay');
      if (!container) return;
      // セクションタイトル
      const sectionDiv = document.createElement('div');
      sectionDiv.className = 'recipe-section';
      const titleDiv = document.createElement('div');
      titleDiv.className = 'recipe-section-title';
      titleDiv.contentEditable = 'true';
      titleDiv.spellcheck = false;
      titleDiv.textContent = '新しいカテゴリ';
      sectionDiv.setAttribute('data-section-title', titleDiv.textContent.trim());
      titleDiv.addEventListener('input', () => {
        sectionDiv.setAttribute('data-section-title', titleDiv.textContent.trim());
      });
      sectionDiv.appendChild(titleDiv);
      // 空の材料1行
      const gridDiv = document.createElement('div');
      gridDiv.className = 'recipe-ingredients-grid';
      const nameDiv = document.createElement('div'); nameDiv.className = 'ingredient-name'; nameDiv.contentEditable = 'true';
      const qtyDiv = document.createElement('div'); qtyDiv.className = 'ingredient-quantity'; qtyDiv.contentEditable = 'true';
      const unitDiv = document.createElement('div'); unitDiv.className = 'ingredient-unit'; unitDiv.contentEditable = 'true';
      gridDiv.appendChild(nameDiv); gridDiv.appendChild(qtyDiv); gridDiv.appendChild(unitDiv);
      sectionDiv.appendChild(gridDiv);
      // セクション専用 追加ボタン
      const actions = document.createElement('div');
      actions.className = 'inline-actions';
      actions.style.cssText = 'margin-top:.5rem; display:flex; justify-content:flex-end;';
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'btn secondary';
      addBtn.textContent = '材料を追加';
      addBtn.addEventListener('click', () => addIngredientRowToSection(sectionDiv));
      actions.appendChild(addBtn);
      sectionDiv.appendChild(actions);
      container.appendChild(sectionDiv);

      // データモデルに反映（カテゴリ概念がないため、フラット配列末尾に空行を追加するのみ）
      if (!window.currentRecipeData) window.currentRecipeData = {};
      if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
      window.currentRecipeData.ingredients.push({
        item: '',
        quantity: '',
        unit: '',
        sectionTitle: titleDiv.textContent.trim()
      });
    }

    function syncCurrentRecipeFromDOM(options = {}) {
      const { showAlert = true } = options;
      if (!currentRecipeData) {
        if (showAlert) alert('元となるレシピデータがありません。');
        return;
      }

      // DOMから現在の値を読み取る
      currentRecipeData.title = document.getElementById('recipeTitle')?.textContent?.trim() || currentRecipeData.title;
      currentRecipeData.description = document.getElementById('recipeDescription')?.textContent?.trim() || currentRecipeData.description;
      currentRecipeData.servings = document.getElementById('recipeServings')?.textContent?.trim() || currentRecipeData.servings;

      const imageUrlInput = document.getElementById('recipeImageUrlInput');
      if (imageUrlInput) {
          const imageUrl = imageUrlInput.value.trim();
          if (imageUrl) {
              currentRecipeData.image_url = imageUrl;
          } else {
              delete currentRecipeData.image_url;
          }
      }

      // 材料の同期
      const ingredientsContainer = document.getElementById('flexibleIngredientsDisplay');
      const newIngredients = [];
      
      // 新しいカテゴリ形式 (.recipe-section) から材料を抽出
      const sections = ingredientsContainer.querySelectorAll('.recipe-section');
      if (sections.length > 0) {
        sections.forEach(section => {
          const sectionTitleEl = section.querySelector('.recipe-section-title');
          const sectionTitle = sectionTitleEl ? sectionTitleEl.textContent.trim() : '';
          
          const ingredientGrids = section.querySelectorAll('.recipe-ingredients-grid');
          ingredientGrids.forEach(grid => {
            const nameEl = grid.querySelector('.ingredient-name');
            const quantityEl = grid.querySelector('.ingredient-quantity');
            const unitEl = grid.querySelector('.ingredient-unit');
            
            if (nameEl) {
              newIngredients.push({
                item: nameEl.textContent.trim(),
                quantity: quantityEl ? quantityEl.textContent.trim() : '',
                unit: unitEl ? unitEl.textContent.trim() : '',
                sectionTitle: sectionTitle
              });
            }
          });
        });
      } else {
        // 古いテーブル形式から材料を抽出（フォールバック）
        const ingredientRows = ingredientsContainer.querySelectorAll('table tbody tr');
        if (ingredientRows.length > 0) {
          Array.from(ingredientRows).map(row => {
            const nameEl = row.querySelector('[data-key="item"]');
            const quantityEl = row.querySelector('[data-key="quantity"]');
            const unitEl = row.querySelector('[data-key="unit"]');
            
            if (nameEl && nameEl.textContent.trim()) {
              newIngredients.push({
                item: nameEl.textContent.trim(),
                quantity: quantityEl ? quantityEl.textContent.trim() : '',
                unit: unitEl ? unitEl.textContent.trim() : '',
                // カテゴリ名は古い形式では取得が難しい
              });
            }
          });
        }
      }

      if (newIngredients.length > 0) {
        currentRecipeData.ingredients = newIngredients;
      }

      // 手順の同期
      const stepsContainer = document.getElementById('stepsList');
      const stepItems = stepsContainer.querySelectorAll('.step-item, .step-text');
      if (stepItems.length > 0) {
        const newSteps = Array.from(stepItems)
          .map(el => el.innerHTML.replace(/^<b>\d+\.?<\/b>\s*/, '').trim())
          .filter(step => step && step !== '手順なし');
        currentRecipeData.steps = newSteps;
      }
      
      if (showAlert) {
        alert('現在の編集内容を内部データに同期しました。');
      }
      console.log('🔄 Synced from DOM:', currentRecipeData);
    }

    // ボタン初期化
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('btnAddIngredientInline')?.addEventListener('click', addInlineIngredientRow);
      document.getElementById('btnAddStepInline')?.addEventListener('click', addInlineStepRow);
      document.getElementById('btnAddCategoryInline')?.addEventListener('click', addInlineCategoryBlock);
      document.getElementById('btnApplyOriginalEdits')?.addEventListener('click', () => syncCurrentRecipeFromDOM({ showAlert: true }));
    });

    // 保存パネル内の簡易プレビュー（同じプロキシ回避ロジックを流用）
    (function() {
      const urlInput = document.getElementById('urlInput');
      const urlBox = document.getElementById('savePaneUrl');
      const btn = document.getElementById('savePaneLoadBtn');
      const frame = document.getElementById('savePaneFrame');
      const originalPreview = document.getElementById('recipePreview');
      const quickTitle = document.getElementById('quickTitle');
      const quickServings = document.getElementById('quickServings');
      const quickNotes = document.getElementById('quickNotes');
      const quickIngName = document.getElementById('quickIngName');
      const quickIngQty = document.getElementById('quickIngQty');
      const quickIngUnit = document.getElementById('quickIngUnit');
      const quickAddIng = document.getElementById('quickAddIng');
      const quickIngTable = document.getElementById('quickIngTable');
      if (!btn || !frame) return;

      btn.addEventListener('click', async () => {
        const url = (urlBox.value || urlInput?.value || '').trim();
        if (!url) { alert('URLを入力してください'); return; }
        try {
          frame.removeAttribute('srcdoc');
          frame.src = url;
          setTimeout(async () => {
            const blankLike = !frame.contentWindow || !frame.contentDocument || frame.contentDocument.body.children.length === 0;
            if (blankLike) {
              const raw = await window.fetchHtmlViaProxy(url, { minLength: 2000, timeout: 12000 });
              const sanitized = String(raw)
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                .replace(/on\w+\s*=\s*"[^"]*"/gi, '')
                .replace(/on\w+\s*=\s*'[^']*'/gi, '')
                .replace(/on\w+\s*=\s*[^\s>]+/gi, '');
              const base = `<base href="${url.replace(/\/(?:[^\/]*?)?$/,'/')}" />`;
              const adCss = `<style>
                [id*="ad" i], [class*="ad" i], .adsbygoogle, .sponsor, .sponsored, .advertisement, .banner, .promo, .cookie, .gdpr, .share, .social, .app, .install { display:none !important; }
                header nav, footer { display:none !important; }
                body { word-wrap: break-word !important; overflow-wrap: break-word !important; white-space: normal !important; line-height: 1.5; box-sizing: border-box !important; }
              </style>`;
              const wrapped = sanitized.replace(/<head(.*?)>/i, `<head$1>${base}${adCss}`);
              const blob = new Blob([wrapped], { type: 'text/html' });
              const objectUrl = URL.createObjectURL(blob);
              frame.src = objectUrl;
            }
            // 高さを元レシピプレビューに合わせて少し小さく
            try {
              const baseHeight = originalPreview ? originalPreview.getBoundingClientRect().height : 420;
              const desired = Math.max(240, Math.floor(baseHeight - 40));
              frame.style.height = desired + 'px';
            } catch (_) {}
          }, 1500);
        } catch (e) {
          alert('プレビュー読み込みに失敗しました: ' + e.message);
        }
      });

      // クイック修正: タイトル/人数/メモ
      const applyQuickFields = () => {
        if (quickTitle) document.getElementById('recipeTitle').textContent = quickTitle.value || document.getElementById('recipeTitle').textContent;
        if (quickServings) document.getElementById('recipeServings').textContent = quickServings.value || document.getElementById('recipeServings').textContent;
      };
      quickTitle?.addEventListener('change', applyQuickFields);
      quickServings?.addEventListener('change', applyQuickFields);

      // クイック材料追加: 原語の材料表示末尾に1行追加（保存時にも反映されるようcurrentRecipeDataにもpush）
      function syncQuickTableFromData() {
        if (!quickIngTable) return;
        const tbody = quickIngTable.querySelector('tbody');
        tbody.innerHTML = '';
        const list = (window.currentRecipeData?.ingredients || []);
        list.forEach((ing, idx) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="item" type="text" value="${ing.item || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="quantity" type="text" value="${ing.quantity || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color);"><input data-idx="${idx}" data-key="unit" type="text" value="${ing.unit || ''}" style="width:100%; padding:.3rem .5rem;"></td>
            <td style="padding:.35rem; border-bottom:1px solid var(--border-color); text-align:right;"><button data-del="${idx}" type="button" class="btn secondary" style="padding:.25rem .5rem;">削除</button></td>`;
          tbody.appendChild(tr);
        });
        // 入力変更 → データ反映
        tbody.querySelectorAll('input').forEach(inp => {
          inp.addEventListener('change', (e) => {
            const el = e.target;
            const i = parseInt(el.getAttribute('data-idx'));
            const key = el.getAttribute('data-key');
            if (!window.currentRecipeData?.ingredients?.[i]) return;
            window.currentRecipeData.ingredients[i][key] = el.value;
          });
        });
        // 削除
        tbody.querySelectorAll('button[data-del]').forEach(btnDel => {
          btnDel.addEventListener('click', (e) => {
            const i = parseInt(e.target.getAttribute('data-del'));
            if (window.currentRecipeData?.ingredients) {
              window.currentRecipeData.ingredients.splice(i, 1);
              syncQuickTableFromData();
              // 左側の表示も同期（簡易: クリアして再描画）
              const container = document.getElementById('flexibleIngredientsDisplay');
              container.innerHTML = '';
              window.currentRecipeData.ingredients.forEach(ing => {
                const row = document.createElement('div');
                row.className = 'ingredient-item';
                row.textContent = [ing.item || '', [ing.quantity || '', ing.unit || ''].filter(Boolean).join(' ')].filter(Boolean).join(' - ');
                container.appendChild(row);
              });
            }
          });
        });
      }

      quickAddIng?.addEventListener('click', () => {
        const name = (quickIngName?.value || '').trim();
        const qty = (quickIngQty?.value || '').trim();
        const unit = (quickIngUnit?.value || '').trim();
        if (!name) { alert('材料名を入力してください'); return; }
        const container = document.getElementById('flexibleIngredientsDisplay');
        const row = document.createElement('div');
        row.className = 'ingredient-item';
        const text = [name, [qty, unit].filter(Boolean).join(' ')].filter(Boolean).join(' - ');
        row.textContent = text;
        container?.appendChild(row);
        // データモデルも更新
        if (!window.currentRecipeData) window.currentRecipeData = { ingredients: [] };
        if (!Array.isArray(window.currentRecipeData.ingredients)) window.currentRecipeData.ingredients = [];
        window.currentRecipeData.ingredients.push({ item: name, quantity: qty, unit: unit });
        // 入力欄をクリア
        if (quickIngName) quickIngName.value = '';
        if (quickIngQty) quickIngQty.value = '';
        if (quickIngUnit) quickIngUnit.value = '';
        syncQuickTableFromData();
      });

      // 初期同期（抽出済みがある場合）
      if (window.currentRecipeData?.ingredients?.length) {
        syncQuickTableFromData();
      }
    })();
  </script>
</body>
</html>
