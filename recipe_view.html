<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ表示 — Recipe Box</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js"></script>

  <link rel="stylesheet" href="assets/css/style.css">
  <style>
    /* ===== AIモーダル（3タブ統合版） ===== */
    .ai-view-modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:1000; display:none; align-items:center; justify-content:center; }
    .ai-view-modal-content{ background:var(--bg-panel,#fff); color:var(--fg,#222); width:clamp(320px,92vw,860px); max-height:92vh; overflow:hidden; border-radius:12px; box-shadow:0 8px 28px rgba(0,0,0,.35); display:flex; flex-direction:column; }
    .ai-view-modal-header{ display:flex; align-items:center; justify-content:space-between; gap:1rem; padding:.85rem 1rem; border-bottom:1px solid rgba(0,0,0,.08); }
    .ai-view-modal-title{ font-weight:700; }
    .ai-view-modal-close{ background:none; border:none; font-size:1.5rem; line-height:1; cursor:pointer; }
    .ai-view-tabs{ display:flex; gap:.25rem; padding:.5rem; border-bottom:1px solid rgba(0,0,0,.06); background:var(--bg-muted,#f7f7f7); }
    .ai-tab{ padding:.4rem .75rem; border-radius:999px; cursor:pointer; border:1px solid transparent; }
    .ai-tab[aria-selected="true"]{ background:#e8f0fe; border-color:#b6cef7; }
    .ai-chat-container{ flex:1; overflow:auto; padding:1rem; display:none; }
    .ai-chat-container.active{ display:block; }
    .ai-input-row{ display:flex; gap:.5rem; padding:.75rem 1rem; border-top:1px solid rgba(0,0,0,.08); }
    .ai-input-row textarea{ flex:1; resize:vertical; min-height:42px; }
    .ai-btn{ padding:.5rem .85rem; border:1px solid #d0d7de; border-radius:8px; background:#fff; cursor:pointer; }
    .ai-btn.primary{ background:#2563eb; color:#fff; border-color:#2563eb; }
    .ai-msg{ 
      margin:.8rem 0; 
      padding:1rem 1.2rem; 
      border-radius:12px; 
      border:1px solid #e5e7eb; 
      background:#fafafa; 
      line-height:1.7; 
      font-size: 0.95em;
    }
    .ai-msg.user{ 
      background:#eef5ff; 
      border-color:#cfe2ff; 
    }
    
    /* マークダウン風のスタイリング */
    .ai-msg h1, .ai-msg h2, .ai-msg h3, .ai-msg h4 {
      margin: 1.5rem 0 0.8rem 0;
      color: #1a1a1a;
      font-weight: 600;
    }
    
    .ai-msg h1 { font-size: 1.4em; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
    .ai-msg h2 { font-size: 1.3em; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3rem; }
    
    /* ===== ステータスポップアップ ===== */
    .status-popup {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .status-popup-content {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
      display: flex;
      align-items: center;
      gap: 1rem;
      min-width: 300px;
      max-width: 500px;
    }
    
    .status-icon {
      flex-shrink: 0;
    }
    
    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #2563eb;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .status-text {
      flex: 1;
    }
    
    .status-title {
      font-weight: 600;
      font-size: 1.1em;
      color: #1a1a1a;
      margin-bottom: 0.25rem;
    }
    
    .status-message {
      color: #666;
      font-size: 0.9em;
    }
    
    .status-popup.success .spinner {
      border: 3px solid #d1fae5;
      border-top: 3px solid #10b981;
    }
    
    .status-popup.error .spinner {
      border: 3px solid #fee2e2;
      border-top: 3px solid #ef4444;
    }
    
    .status-popup.success .status-title {
      color: #10b981;
    }
    
    .status-popup.error .status-title {
      color: #ef4444;
    }
    .ai-msg h3 { font-size: 1.2em; color: #2563eb; }
    .ai-msg h4 { font-size: 1.1em; color: #374151; }
    
    .ai-msg p {
      margin: 0.8rem 0;
      line-height: 1.7;
    }
    
    .ai-msg ul, .ai-msg ol {
      margin: 0.8rem 0;
      padding-left: 1.5rem;
    }
    
    .ai-msg li {
      margin: 0.4rem 0;
      line-height: 1.6;
    }
    
    .ai-msg strong {
      color: #1a1a1a;
      font-weight: 600;
    }
    
    .ai-msg em {
      color: #6b7280;
      font-style: italic;
    }
    
    .ai-msg blockquote {
      margin: 1rem 0;
      padding: 0.8rem 1rem;
      background: #f8f9fa;
      border-left: 4px solid #2563eb;
      border-radius: 0 6px 6px 0;
    }
    
    .ai-msg code {
      background: #f1f5f9;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
      color: #dc2626;
    }
    
    .ai-msg pre {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
      margin: 1rem 0;
    }
    
    .ai-msg pre code {
      background: none;
      padding: 0;
      color: #374151;
    }
    
    /* 改善提案の特別なスタイリング */
    .ai-msg .improvement-section {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
    }
    
    .ai-msg .improvement-title {
      color: #0369a1;
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 0.8rem;
    }
    
    .ai-msg .rationale, .ai-msg .implementation, .ai-msg .risk {
      margin: 0.8rem 0;
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
    }
    
    .ai-msg .rationale {
      background: #fef3c7;
      border-left: 3px solid #f59e0b;
    }
    
    .ai-msg .implementation {
      background: #dbeafe;
      border-left: 3px solid #3b82f6;
    }
    
    .ai-msg .risk {
      background: #fee2e2;
      border-left: 3px solid #ef4444;
    }
    
    .ai-msg .rationale::before {
      content: "根拠: ";
      font-weight: 600;
      color: #92400e;
    }
    
    .ai-msg .implementation::before {
      content: "実装: ";
      font-weight: 600;
      color: #1e40af;
    }
    
    .ai-msg .risk::before {
      content: "リスク: ";
      font-weight: 600;
      color: #991b1b;
    }
    .loading{ width:24px; height:24px; border:3px solid rgba(0,0,0,.15); border-top-color:rgba(0,0,0,.45); border-radius:50%; animation:spin 1s linear infinite; margin:.25rem auto; }
    @keyframes spin{ to{ transform:rotate(360deg);} }
    body.modal-open{ overflow:hidden; }
    /* 既存の解析カードの体裁補助 */
    .grid{ display:grid; grid-template-columns: 1fr auto; gap:.25rem .75rem; align-items:baseline; }
    .card .num{ text-align:right; }

    /* AIモーダル内のテーブルを見やすくするスタイル */
    .ai-chat-container table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
        margin-bottom: 1rem;
        font-size: 0.9em;
        line-height: 1.5;
    }
    .ai-chat-container th,
    .ai-chat-container td {
        border: 1px solid #dee2e6; /* var(--line-primary) */
        padding: 0.6rem 0.75rem;
        text-align: left;
        vertical-align: top;
    }
    .ai-chat-container th {
        background-color: #f8f9fa; /* Lighter than --bg-muted */
        font-weight: 600;
    }
    .ai-chat-container tr:nth-child(even) {
        background-color: #f7f7f7; /* var(--bg-muted) */
    }
  </style>
</head>
<body>

  <header class="app-header">
    <h1 class="brand">レシピ表示</h1>
    <div class="header-actions" data-actions>
      <button class="btn primary small js-ai-advice">✨ AIアドバイス</button>
      <button class="btn js-edit">編集</button>
      <button class="btn ghost js-delete" style="color:#c0392b;border-color:#c0392b;">削除</button>
      <button class="btn js-back">戻る</button>
    </div>
  </header>

  <!-- ステータス表示ポップアップ -->
  <div id="statusPopup" class="status-popup" style="display: none;">
    <div class="status-popup-content">
      <div class="status-icon">
        <div class="spinner"></div>
      </div>
      <div class="status-text">
        <div class="status-title">処理中...</div>
        <div class="status-message">しばらくお待ちください</div>
      </div>
    </div>
  </div>

  <main class="container two-col-layout">
    <article class="panel">
      <div class="fav-block" style="text-align:right;margin-bottom:1rem;">
        <button id="favBtn" class="btn small">♡ お気に入り</button>
      </div>
      <h2 id="recipeTitle">タイトル</h2>
      <div class="muted" id="meta">作成日 — / 更新日 —</div>
      <div id="tags" style="margin:8px 0;"></div>
      
      <!-- レシピ画像表示エリア -->
      <div id="recipeImageContainer" class="recipe-image-container" style="display: none; margin: 16px 0;">
        <img id="recipeImage" src="" alt="レシピ画像" class="recipe-image" />
      </div>
      
      <p id="recipeIntro" class="lead"></p>
      <div id="notes" style="margin-top:16px;white-space:pre-wrap;"></div>
    </article>

    <aside class="panel">
      <h3>材料</h3>
      <div id="ingredients"><div class="muted">未登録</div></div>

      <h3 style="margin-top:24px;">手順</h3>
      <ol id="steps"><li class="muted">未登録</li></ol>

      <section class="card" id="analysisSection" style="display:none;">
        <h3>科学メモ（ベーカーズ％）</h3>
        <div class="grid">
          <div>粉合計</div><div><span id="flour_g">–</span> g (100%)</div>
          <div>加水率</div><div><span id="hydration_bp">–</span>%（水分 <span id="water_g">–</span> g）</div>
          <div>油脂</div><div><span id="fat_bp">–</span>%（<span id="fat_g">–</span> g）</div>
          <div>糖</div><div><span id="sugar_bp">–</span>%（<span id="sugar_g">–</span> g）</div>
          <div>塩</div><div><span id="salt_bp">–</span>%（<span id="salt_g">–</span> g）</div>
          <div>酵母</div><div><span id="yeast_bp">–</span>%（<span id="yeast_g">–</span> g）</div>
        </div>
        <p id="analysisNotes" class="note"></p>
      </section>


    </aside>
  </main>



  <div id="aiModal" class="ai-view-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="aiTitle">
    <div class="ai-view-modal-content" tabindex="-1">
      <header class="ai-view-modal-header">
        <div class="ai-view-modal-title" id="aiTitle">✨ AI レシピ アシスタント</div>
        <button class="ai-view-modal-close" id="aiClose" aria-label="閉じる">×</button>
      </header>
      <nav class="ai-view-tabs" role="tablist">
        <button class="ai-tab" role="tab" aria-selected="true" data-tab="advice">提案</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="temps">温度・時間</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="hazards">危害要因</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="new">新規レシピ</button>
      </nav>
      <section id="tab-advice" class="ai-chat-container active"></section>
      <section id="tab-temps" class="ai-chat-container"></section>
      <section id="tab-hazards" class="ai-chat-container"></section>
      <section id="tab-new" class="ai-chat-container"></section>
      <div class="ai-input-row">
        <textarea id="aiInput" placeholder="質問や要望を入力…"></textarea>
        <button class="ai-btn" id="aiSave">新規レシピ化</button>
        <button class="ai-btn primary" id="aiSend">送信</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Supabase 初期化（既に window.sb があれば流用） =====
    if (window.supabase && !window.sb) {
      window.sb = window.supabase.createClient(
        "https://ctxyawinblwcbkovfsyj.supabase.co",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q",
        { auth: { storageKey: 'app-main-11-view', autoRefreshToken: true, persistSession: true, detectSessionInUrl: false } }
      );
    }

    // ===== 要素参照 =====
    const btnOpen = document.querySelector('.js-ai-advice');
    const btnBack = document.querySelector('.js-back');
    const modal = document.getElementById('aiModal');
    const modalContent = modal.querySelector('.ai-view-modal-content');
    const btnClose = document.getElementById('aiClose');
    const tabs = document.querySelectorAll('.ai-tab');
    const panes = { advice: document.getElementById('tab-advice'), temps: document.getElementById('tab-temps'), hazards: document.getElementById('tab-hazards'), new: document.getElementById('tab-new') };
    const input = document.getElementById('aiInput');
    const btnSend = document.getElementById('aiSend');
    const btnSave = document.getElementById('aiSave');
    // 入力の有効/無効切り替え
    function setAIInputEnabled(enabled){
      try{
        if (input) {
          input.disabled = !enabled;
          input.style.opacity = enabled ? '1' : '0.6';
          input.style.pointerEvents = enabled ? 'auto' : 'none';
        }
        if (btnSend) {
          btnSend.disabled = !enabled;
          btnSend.style.opacity = enabled ? '1' : '0.6';
          btnSend.style.pointerEvents = enabled ? 'auto' : 'none';
        }
      }catch(_){}
    }


    // ▼▼▼【変更点 1】会話履歴を保存するオブジェクトを追加 ▼▼▼
    const chatHistories = { advice: [], temps: [], hazards: [], new: [] };

    // ===== タブ切替（遅延生成対応） =====
    const tabLoaded = { advice:false, temps:false, hazards:false, new:false };
    tabs.forEach(t=>t.addEventListener('click', async ()=>{
      tabs.forEach(x=>x.setAttribute('aria-selected','false'));
      t.setAttribute('aria-selected','true');
      Object.values(panes).forEach(p=>p.classList.remove('active'));
      panes[t.dataset.tab].classList.add('active');
      if(!tabLoaded[t.dataset.tab]){ await generateTab(t.dataset.tab); tabLoaded[t.dataset.tab]=true; }
    }));

    // ===== 開閉（Esc/背景クリック/戻る導線） =====
    const openModal = ()=>{ modal.style.display='flex'; document.body.classList.add('modal-open'); modalContent.focus({preventScroll:true}); };
    const closeModal = ()=>{ modal.style.display='none'; document.body.classList.remove('modal-open'); };
    btnOpen?.addEventListener('click', async ()=>{ openModal(); if(!tabLoaded.advice) { await generateTab('advice'); tabLoaded.advice=true; } });
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', (e)=>{ if(e.target === modal) closeModal(); });
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex') closeModal(); });
    btnBack?.addEventListener('click', ()=>{ location.href='index.html'; });

    // ===== 便利関数 =====
    const md = (s)=>{ try{ return marked.parse(s||''); }catch{ return (s||''); } };
    const pushMsg = (pane, role, text)=>{ 
      const el=document.createElement('div'); 
      el.className=`ai-msg ${role}`; 
      el.innerHTML = role==='assistant'? md(text): (text||''); 
      pane.appendChild(el); 
      
      // 最初のAIアドバイス生成時のみ一番上にスクロール
      const isFirstAIResponse = pane.children.length === 1 && role === 'assistant';
      if (isFirstAIResponse) {
        pane.scrollTop = 0;
      } else {
        pane.scrollTop = pane.scrollHeight;
      }
    };
    const spinner = ()=>{ const d=document.createElement('div'); d.className='loading'; return d; };

    // ===== レシピ抽出 =====
    function scrapeRecipe(){
      const title = document.getElementById('recipeTitle')?.textContent?.trim() || '';
      const ings = Array.from(document.querySelectorAll('#ingredients tbody tr')).map(tr=>{
        const tds = tr.querySelectorAll('td');
        return { item:(tds[0]?.textContent||'').trim(), quantity:(tds[1]?.textContent||'').trim(), unit:(tds[2]?.textContent||'').trim() };
      });
      const steps = Array.from(document.querySelectorAll('#steps li')).map(li=> (li.textContent||'').trim()).filter(Boolean);
      return { title, ings, steps };
    }

    // ===== タブ別プロンプト =====
    function buildPrompts(){
      const { title, ings, steps } = scrapeRecipe();
      const ingText = ings.map(i=>`- ${i.item} ${i.quantity||''} ${i.unit||''}`).join('\n');
      const stepText = steps.map((s,i)=> `${i+1}. ${s}`).join('\n');
      const base = `# ルセット名\n${title||'無題のレシピ'}\n\n## 材料\n${ingText}\n\n## 手順\n${stepText}`;
      const advice = `あなたはプロ向けの調理科学アドバイザーです。${base}

## 改善提案（要約版）

### 主要な改善点（3-4個）

各改善点を簡潔に記述してください：

#### 1. [改善項目名]
- **根拠:** 簡潔な科学的根拠
- **実装:** 具体的な手順（1-2行）
- **注意点:** 重要なリスクや注意事項

#### 2. [改善項目名]
- **根拠:** 簡潔な科学的根拠
- **実装:** 具体的な手順（1-2行）
- **注意点:** 重要なリスクや注意事項

### 調理科学のポイント

重要な調理科学の観点を簡潔に箇条書きで：
- メイラード反応、酵素活性、タンパク質変性など
- パン/生地系の場合はベーカーズ％の妥当性

**必ず簡潔で実用的なアドバイスにしてください。**`;
      const temps = `あなたはプロの食品安全コンサルタントです。以下のレシピの重要管理点（CCP）における温度と時間を管理するための表を作成してください。\n\n${base}\n\n— 出力仕様 —\n- 必ずMarkdownの表形式で出力してください。\n- 表には「工程」「温度（表面/中心）」「時間」「備考（食品安全上の根拠など）」の列を含めてください。`;
      const hazards = `以下のレシピに関する危害要因（微生物/アレルゲン/化学・物理）とCCP候補、簡単な管理基準案を箇条書きで。\n\n${base}`;
      const newRecipe = `あなたはレシピ開発の専門家です。以下の会話履歴・提案内容・現在のレシピ情報をすべて考慮し、改善された新規レシピを厳密なJSONだけで出力してください。

【現在のレシピ情報】
${base}

【出力仕様】
- JSONのみを出力（前後説明・マークダウン不可）
- 形式は次の通り：
{
  "recipe": {
    "title": "料理名",
    "description": "説明",
    "servings": "人数",
    "ingredients": [{"item":"材料名","quantity":"分量","unit":"単位"}],
    "steps": ["手順1","手順2"],
    "notes": "メモ"
  },
  "analysis": "置き換えの理由、味・質感・栄養・安全面の考察を簡潔に"
}
- 単位は g / ml に統一（tsp=5ml, tbsp=15ml, 小さじ=5ml, 大さじ=15ml, カップ=200ml）
- steps は配列のテキストで簡潔に`;
      return { advice, temps, hazards, new: newRecipe };
    }

    // ===== 直接Gemini API呼び出し =====
    async function invokeGemini(prompt, responseSchema){
       const load = spinner();
       const activePane = document.querySelector('.ai-chat-container.active') || panes.advice;
       activePane.appendChild(load);
       try{
         // レート制限対策
         await new Promise(resolve => setTimeout(resolve, 1000));
         
         const GEMINI_API_KEY = 'AIzaSyAUsJcsyFY1vcBlrDNn1DYLRor_oqLErx4';
         const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${GEMINI_API_KEY}`, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
         });
 
         if (!response.ok) {
           const errorData = await response.json();
           throw new Error(`Gemini API エラー: ${errorData.error?.message || response.statusText}`);
         }
 
         const result = await response.json();
         if (result.candidates && result.candidates[0] && result.candidates[0].content) {
           const content = result.candidates[0].content.parts[0].text;
           console.log('[AI raw]', content);
           
           // JSONを抽出
           const jsonMatch = content.match(/\{[\s\S]*\}/);
           if (jsonMatch) {
             try {
               const jsonData = JSON.parse(jsonMatch[0]);
               return jsonData;
             } catch (parseError) {
               console.error('JSON解析エラー:', parseError);
               return { text: content };
             }
           }
           
           return { text: content };
         }
 
         throw new Error('Gemini APIから有効なレスポンスを取得できませんでした');
       }catch(e){ 
         pushMsg(activePane,'assistant',`エラー: ${e.message}`); 
         return null; 
       }
       finally{ load.remove(); }
     }

    // ===== 応答テキスト抽出（Gemini / OpenAI 両対応） =====
    function extractLLMText(r){
      try{
        if (!r) return '';
        if (typeof r === 'string') return r;
        if (r.text) return r.text;
        if (r.output_text) return r.output_text;
        if (r.message && typeof r.message.content === 'string') return r.message.content;
        if (Array.isArray(r.choices) && r.choices.length){
          const ch = r.choices[0];
          return (ch.message && ch.message.content) || ch.text || '';
        }
        if (Array.isArray(r.candidates) && r.candidates.length){
          const cand = r.candidates[0];
          if (cand && cand.content && Array.isArray(cand.content.parts)){
            return cand.content.parts.map(p => (p && p.text) ? p.text : '').join('\n').trim();
          }
        }
        if (r.content && Array.isArray(r.content.parts)){
            return r.content.parts.map(p => p.text || '').join('\n').trim();
        }
        try { return JSON.stringify(r); } catch { return ''; }
      }catch(e){
        console.error('extractLLMText error', e, r);
        return '';
      }
    }
    
    // ===== レシピ表示用ヘルパ =====
    function renderRecipeCard(pane, recipeObj, sourceLabel = 'AI提案'){
      try{
        const title = recipeObj.title || '無題のレシピ';
        const desc = recipeObj.description || recipeObj.notes || '';
        const servings = recipeObj.servings ? String(recipeObj.servings) : '';
        const ings = Array.isArray(recipeObj.ingredients) ? recipeObj.ingredients : [];
        const steps = Array.isArray(recipeObj.steps) ? recipeObj.steps : [];

        const ingTable = `
          <table class="table" style="margin-top:8px;">
            <thead><tr><th>番号</th><th>材料名</th><th>分量</th><th>単位</th></tr></thead>
            <tbody>
              ${ings.map((it,idx)=>`<tr><td>${idx+1}</td><td>${(it.item||it.name||'').toString()}</td><td>${(it.quantity||'').toString()}</td><td>${(it.unit||'').toString()}</td></tr>`).join('')}
            </tbody>
          </table>`;
        const stepList = `<ol style="margin-top:8px;">${steps.map(s=>`<li>${(s||'').toString()}</li>`).join('')}</ol>`;

        const wrap = document.createElement('div');
        wrap.className = 'card';
        wrap.style.padding = '12px';
        wrap.innerHTML = `
          <div class="muted" style="margin-bottom:4px;">${sourceLabel}</div>
          <h4 style="margin:4px 0;">${title}</h4>
          ${servings ? `<div style="margin:4px 0;">人数: ${servings}</div>` : ''}
          ${desc ? `<p style="white-space:pre-wrap;">${desc}</p>` : ''}
          <h5 style="margin-top:8px;">材料</h5>
          ${ingTable}
          <h5 style="margin-top:12px;">手順</h5>
          ${stepList}
        `;
        pane.appendChild(wrap);

        const btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        btnRow.style.marginTop = '8px';
        const btnApply = document.createElement('button');
        btnApply.className = 'ai-btn';
        btnApply.textContent = '反映';
        btnApply.addEventListener('click', ()=> applyRecipeToView(recipeObj));

        const btnNew = document.createElement('button');
        btnNew.className = 'ai-btn primary';
        btnNew.textContent = '新規';
        btnNew.addEventListener('click', ()=>{
          try {
            // 2系統で受け渡し（URLパラメータ + localStorage フォールバック）
            localStorage.setItem('ai_generated_recipe', JSON.stringify(recipeObj));
            const recipeData = encodeURIComponent(JSON.stringify(recipeObj));
            window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
          } catch (_) {
            // パラメータにフォールバック
            const recipeData = encodeURIComponent(JSON.stringify(recipeObj));
            window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
          }
        });
        const btnCancel = document.createElement('button');
        btnCancel.className = 'ai-btn';
        btnCancel.textContent = 'キャンセル';
        btnCancel.addEventListener('click', ()=>{
          // キャンセル: ボタン行を無効化してメッセージ表示
          btnApply.disabled = true;
          btnNew.disabled = true;
          btnCancel.disabled = true;
          const note = document.createElement('div');
          note.className = 'muted';
          note.style.marginTop = '6px';
          note.textContent = 'キャンセルしました';
          pane.appendChild(note);
        });
        btnRow.appendChild(btnApply);
        btnRow.appendChild(btnNew);
        btnRow.appendChild(btnCancel);
        pane.appendChild(btnRow);
      }catch(e){
        console.error('renderRecipeCard error', e);
      }
    }

    function applyRecipeToView(recipe){
      try{
        const ingEl = document.getElementById('ingredients');
        const stepsEl = document.getElementById('steps');
        const titleEl = document.getElementById('recipeTitle');
        const notesEl = document.getElementById('notes');
        if (titleEl && recipe.title) titleEl.textContent = recipe.title;
        if (notesEl && (recipe.description || recipe.notes)) notesEl.textContent = recipe.description || recipe.notes;
        const ings = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];
        const cols = ['番号','材料名','分量','単位'];
        const thead = `<thead><tr>${cols.map(c=>`<th>${c}</th>`).join('')}</tr></thead>`;
        const tbody = `<tbody>${ings.map((it,idx)=>`<tr><td>${idx+1}</td><td>${(it.item||it.name||'')}</td><td>${it.quantity||''}</td><td>${it.unit||''}</td></tr>`).join('')}</tbody>`;
        ingEl.innerHTML = `<table class="table">${thead}${tbody}</table>`;
        const steps = Array.isArray(recipe.steps) ? recipe.steps : [];
        stepsEl.innerHTML = steps.map(s=>`<li>${(s||'').toString()}</li>`).join('') || '<li class="muted">未登録</li>';
      }catch(e){ console.error('applyRecipeToView error', e); }
    }

    // ===== タブ内容生成（必要時に呼び出し） =====
    async function generateTab(kind){
      const prompts = buildPrompts();
      const pane = panes[kind];
      const basePrompt = prompts[kind];
      let promptToSend = basePrompt;
      if (kind === 'new' && chatHistories.new.length){
        const historyText = chatHistories.new.map(m=>`${m.role==='user'?'ユーザー':'アシスタント'}:\n${m.content}`).join('\n\n');
        promptToSend = `${basePrompt}\n\n---\n以下はこれまでの会話履歴です。すべて考慮して新規レシピJSONを出力してください。\n\n${historyText}`;
      }
      const r = await invokeGemini(promptToSend);
      const t = extractLLMText(r) || '（結果なし）';
      // JSONを人間向けカード表示
      const jsonMatchForView = t && t.match(/\{[\s\S]*\}/);
      if (jsonMatchForView) {
        try {
          const obj = JSON.parse(jsonMatchForView[0]);
          const recipeObj = obj.recipe || obj;
          renderRecipeCard(pane, recipeObj, 'AI新規レシピ');
          if (obj.analysis) {
            const ana = document.createElement('div');
            ana.className = 'card';
            ana.style.padding = '12px';
            ana.style.marginTop = '8px';
            ana.innerHTML = `<h5>考察</h5><p style="white-space:pre-wrap;">${obj.analysis}</p>`;
            pane.appendChild(ana);
          }
        } catch (_) {
          pushMsg(pane, 'assistant', t);
        }
      } else {
        pushMsg(pane, 'assistant', t);
      }
      chatHistories[kind].push({ role: 'assistant', content: t });
      // 自動整形→適用（new タブのみ）
      if (kind === 'new') {
        try {
          const jsonMatch = t.match(/\{[\s\S]*\}/);
          const jsonText = jsonMatch ? jsonMatch[0] : t;
          const obj = JSON.parse(jsonText);
          localStorage.setItem('ai_generated_recipe', JSON.stringify(obj));
          // ビューへの反映/編集画面ボタンはカードに追加済み
        } catch (_) {}
      }
    }

    // ▼▼▼ 会話履歴を考慮してAIに質問するよう修正 ▼▼▼
    btnSend.addEventListener('click', async ()=>{
      const q = input.value.trim(); if(!q) return;

      const activeTabEl = document.querySelector('.ai-tab[aria-selected="true"]');
      const kind = activeTabEl.dataset.tab;
      const pane = panes[kind];
      const history = chatHistories[kind];
      
      pushMsg(pane,'user',q);
      history.push({ role: 'user', content: q });
      input.value='';

      // ステータス表示開始
      showStatusPopup('AI分析中...', 'AIが回答を生成しています', 'loading');

      try {
        setAIInputEnabled(false);
        const historyText = history.map(msg => {
            return `${msg.role === 'user' ? 'ユーザー' : 'アシスタント'}:\n${msg.content}`;
        }).join('\n\n');

        const initialPrompt = buildPrompts()[kind];
        const fullPrompt = `${initialPrompt}\n\n---\n上記は最初の指示です。以下はそれ以降の会話履歴です。文脈を踏まえて応答を続けてください。\n\n${historyText}`;

        const r = await invokeGemini(fullPrompt);
        const t = extractLLMText(r) || '（結果なし）';
        
        pushMsg(pane,'assistant',t);
        history.push({ role: 'assistant', content: t });
        
        // ステータス表示完了
        updateStatusPopup('完了', 'AI回答を生成しました', 'success');
        setTimeout(hideStatusPopup, 1500);
        
        // 新規レシピ提案の場合、送信ボタンを表示
        if (kind === 'advice' && t.includes('レシピ') && t.includes('材料')) {
          showNewRecipeSendButton(t);
        }
      } catch (error) {
        console.error('AI回答生成エラー:', error);
        updateStatusPopup('エラー', 'AI回答の生成に失敗しました', 'error');
        setTimeout(hideStatusPopup, 3000);
      } finally {
        setAIInputEnabled(true);
        if (input) input.value = '';
      }
    });

    input.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); btnSend.click(); }});

    // ===== ステータスポップアップ制御 =====
    function showStatusPopup(title, message, type = 'loading') {
      const popup = document.getElementById('statusPopup');
      const titleEl = popup.querySelector('.status-title');
      const messageEl = popup.querySelector('.status-message');
      const spinnerEl = popup.querySelector('.spinner');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // クラスをリセット
      popup.className = 'status-popup';
      if (type !== 'loading') {
        popup.classList.add(type);
        // 成功・エラー時はスピナーを非表示
        spinnerEl.style.display = 'none';
      } else {
        spinnerEl.style.display = 'block';
      }
      
      popup.style.display = 'flex';
    }
    
    function hideStatusPopup() {
      const popup = document.getElementById('statusPopup');
      popup.style.display = 'none';
    }
    
    function updateStatusPopup(title, message, type = 'loading') {
      const popup = document.getElementById('statusPopup');
      const titleEl = popup.querySelector('.status-title');
      const messageEl = popup.querySelector('.status-message');
      const spinnerEl = popup.querySelector('.spinner');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // クラスを更新
      popup.className = 'status-popup';
      if (type !== 'loading') {
        popup.classList.add(type);
        spinnerEl.style.display = 'none';
      } else {
        spinnerEl.style.display = 'block';
      }
    }

    // ===== 新規レシピ送信機能 =====
    function showNewRecipeSendButton(recipeText) {
      // 既存の送信ボタンを削除
      const existingBtn = document.getElementById('newRecipeSendBtn');
      if (existingBtn) existingBtn.remove();
      
      // 新規レシピ送信ボタンを作成
      const sendBtn = document.createElement('button');
      sendBtn.id = 'newRecipeSendBtn';
      sendBtn.className = 'ai-btn primary';
      sendBtn.innerHTML = '📝 新規レシピとして作成';
      sendBtn.style.marginTop = '10px';
      sendBtn.style.width = '100%';
      
      // ボタンをAIアドバイスパネルに追加
      const advicePane = panes.advice;
      if (advicePane) {
        advicePane.appendChild(sendBtn);
        
        // ボタンクリックイベント
        sendBtn.addEventListener('click', async () => {
          try {
            await createNewRecipeFromText(recipeText);
          } catch (error) {
            console.error('新規レシピ作成エラー:', error);
            updateStatusPopup('エラー', '新規レシピの作成に失敗しました', 'error');
            setTimeout(hideStatusPopup, 3000);
          }
        });
      }
    }
    
    async function createNewRecipeFromText(recipeText) {
      console.log('新規レシピ作成開始:', recipeText);
      
      // ステータス表示開始
      showStatusPopup('レシピ構造化中...', 'AIがレシピデータを整理しています', 'loading');
      
      try {
        // レシピテキストを構造化
        const structuredPrompt = `以下のレシピテキストを構造化されたJSON形式に変換してください：

${recipeText}

以下のJSON形式で回答してください（コメントや説明は含めず、JSONのみを返してください）：
{
  "title": "料理名",
  "description": "料理の説明",
  "servings": "人数",
  "ingredients": [
    {
      "item": "材料名",
      "quantity": "分量",
      "unit": "単位"
    }
  ],
  "steps": [
    "手順1",
    "手順2"
  ],
  "notes": "メモやコツ"
}`;

        updateStatusPopup('AI処理中...', 'レシピデータを構造化しています', 'loading');
        
        const result = await invokeGemini(structuredPrompt);
        const structuredRecipe = result || {};
        
        console.log('構造化されたレシピ:', structuredRecipe);
        
        if (!structuredRecipe.title || !structuredRecipe.ingredients || !structuredRecipe.steps) {
          throw new Error('レシピの構造化に失敗しました');
        }
        
        updateStatusPopup('ページ準備中...', '新規レシピ作成ページを開いています', 'loading');
        
        // 新規レシピ作成ページに遷移
        const recipeData = encodeURIComponent(JSON.stringify(structuredRecipe));
        window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
        
        // 送信ボタンを削除
        const sendBtn = document.getElementById('newRecipeSendBtn');
        if (sendBtn) sendBtn.remove();
        
        // ステータス表示完了
        updateStatusPopup('完了', '新規レシピ作成ページを開きました！', 'success');
        setTimeout(hideStatusPopup, 2000);
        
      } catch (error) {
        console.error('新規レシピ作成エラー:', error);
        throw error; // エラーを上位に再スロー
      }
    }

    // ▼▼▼【ここから元に戻した箇所】▼▼▼
    // ===== 新規レシピ化（JSON + 単位正規化） =====
    btnSave.addEventListener('click', async ()=>{
      const schema = { type:"OBJECT", properties:{ title:{type:"STRING"}, category:{type:"STRING"}, tags:{type:"ARRAY",items:{type:"STRING"}}, notes:{type:"STRING"}, ingredients:{type:"ARRAY", items:{type:"OBJECT", properties:{ item:{type:"STRING"}, quantity:{type:"STRING"}, unit:{type:"STRING"} }, required:["item"]}}, steps:{type:"ARRAY",items:{type:"STRING"}} }, required:["title","category","tags","notes","ingredients","steps"] };
      
      // 新規レシピ化専用のプロンプトを作成
      const { title, ings, steps } = scrapeRecipe();
      const ingText = ings.map(i=>`- ${i.item} ${i.quantity||''} ${i.unit||''}`).join('\n');
      const stepText = steps.map((s,i)=> `${i+1}. ${s}`).join('\n');
      
      const recipePrompt = `以下のレシピを基に、改善された新レシピを作成してください：

# レシピ名
${title||'無題のレシピ'}

## 材料
${ingText}

## 手順
${stepText}

## 出力仕様
1. 上記レシピを改善し、新しいレシピを作成してください
2. 材料はg/mlを基本単位とし、単位省略不可
3. 同義単位は変換してください（tsp=5ml, tbsp=15ml, 小さじ=5ml, 大さじ=15ml）
4. 以下のJSON形式でのみ回答してください（マークダウン記号は使用しない）：

{
  "title": "改善されたレシピ名",
  "category": "カテゴリ",
  "tags": ["タグ1", "タグ2"],
  "notes": "レシピの説明やコツ",
  "ingredients": [
    {"item": "材料名", "quantity": "分量", "unit": "単位"}
  ],
  "steps": ["手順1", "手順2"]
}`;

      // 会話履歴（提案タブ）を考慮
      let promptWithHistory = recipePrompt;
      if (chatHistories.advice && chatHistories.advice.length){
        const historyText = chatHistories.advice.map(m=>`${m.role==='user'?'ユーザー':'アシスタント'}:\n${m.content}`).join('\n\n');
        promptWithHistory = `${recipePrompt}\n\n---\n以下はこれまでの会話履歴です。置き換え依頼や条件を必ず考慮して出力してください。\n\n${historyText}\n\n---\n出力は次のJSON形式：\n{\n  "recipe": {"title":"…","description":"…","servings":"…","ingredients":[{"item":"…","quantity":"…","unit":"…"}],"steps":["…","…"],"notes":"…"},\n  "analysis": "置き換えの理由・味・質感・安全の考察"\n}`;
      }
      const r = await invokeGemini(promptWithHistory, schema);
      const jsonText = extractLLMText(r);
      if (!jsonText){ alert('JSONを取得できませんでした。'); return; }
      try{
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        const cleanJsonText = jsonMatch ? jsonMatch[0] : jsonText;
        const parsed = JSON.parse(cleanJsonText);
        const obj = parsed.recipe || parsed;
        // 単位の軽い正規化（スプーン換算）
        const unitMap = { 'tsp':'ml', 'tbsp':'ml', '小さじ':'ml', '大さじ':'ml' };
        const toVol = (q,u)=>{ const n=Number(q); if(!Number.isFinite(n)) return q; if(u==='tsp'||u==='小さじ') return n*5; if(u==='tbsp'||u==='大さじ') return n*15; return n; };
        obj.ingredients = (obj.ingredients||[]).map(it=>{ const u=(it.unit||'').toLowerCase(); if(unitMap[u]) return { ...it, quantity:String(toVol(it.quantity,u)), unit:'ml' }; return it; });
        // 同じチャットライン（提案タブ）に人間向けカードで表示し、反映/編集ボタンを提供
        renderRecipeCard(panes.advice, obj, '新規レシピ化（AI）');
        if (parsed.analysis) {
          const ana = document.createElement('div');
          ana.className = 'card';
          ana.style.padding = '12px';
          ana.style.marginTop = '8px';
          ana.innerHTML = `<h5>考察</h5><p style="white-space:pre-wrap;">${parsed.analysis}</p>`;
          panes.advice.appendChild(ana);
        }
        localStorage.setItem('ai_generated_recipe', JSON.stringify(obj));
      }catch(e){
        console.error('JSON解析エラー:', e, '元のテキスト:', jsonText);
        alert('JSONの解析に失敗: '+ e.message + '\n\n取得されたテキスト: ' + jsonText.substring(0, 200) + '...');
      }
    });
    // ▲▲▲【ここまで元に戻した箇所】▲▲▲
  </script>

<script>
// ===== レシピ読み込み（URLの id から取得して表示） =====
(function(){
  try{
    const params = new URLSearchParams(location.search);
    const id = params.get('id');
    if(!id){
      alert('レシピIDがありません'); location.href='index.html'; return;
    }

    if(!window.sb && window.supabase){
      window.sb = window.supabase.createClient(
        "https://ctxyawinblwcbkovfsyj.supabase.co",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q"
      );
    }
    if(!window.sb){ console.error('Supabase not initialized'); return; }
    const sb = window.sb;

    const titleEl = document.getElementById('recipeTitle');
    const metaEl  = document.getElementById('meta');
    const tagsEl  = document.getElementById('tags');
    const notesEl = document.getElementById('notes');
    const ingEl   = document.getElementById('ingredients');
    const stepsEl = document.getElementById('steps');
    const btnEdit   = document.querySelector('.js-edit');
    const btnDelete = document.querySelector('.js-delete');
    const favBtn    = document.getElementById('favBtn');

    btnEdit?.addEventListener('click', ()=>{ location.href = `recipe_edit.html?id=${encodeURIComponent(id)}`; });
    btnDelete?.addEventListener('click', async ()=>{
      if(!confirm('このレシピを削除しますか？（材料・手順は残る場合があります）')) return;
      try{
        // 削除前に現在のレシピのカテゴリーとタグを取得
        const { data: currentRecipe } = await sb.from('recipes').select('category, tags').eq('id', id).single();
        const deletedCategory = currentRecipe?.category;
        const deletedTags = Array.isArray(currentRecipe?.tags) ? currentRecipe.tags : [];
        
        // レシピを削除
        await sb.from('recipes').delete().eq('id', id);
        
        // カスタムカテゴリーの自動削除チェック
        if (deletedCategory) {
          await cleanupUnusedCategory(deletedCategory);
        }
        
        // タグの自動削除チェック
        if (deletedTags.length > 0) {
          await cleanupUnusedTags(deletedTags);
        }
        
        alert('削除しました'); 
        location.href = 'index.html';
      }catch(e){ 
        alert('削除に失敗: ' + (e.message||e)); 
      }
    });
    
    // 未使用カテゴリーの削除関数
    async function cleanupUnusedCategory(categoryName) {
      try {
        console.log('カテゴリー使用状況をチェック中:', categoryName);
        
        // 基本カテゴリーは削除しない
        const basicCategories = [
          'すべて', 'アミューズ', '前菜', 'ソース', 'スープ', 'パスタ', 
          '魚料理', '肉料理', 'メイン', 'デザート', 'パン', 'その他'
        ];
        
        if (basicCategories.includes(categoryName)) {
          console.log('基本カテゴリーなので削除をスキップ:', categoryName);
          return;
        }
        
        // 同じカテゴリーを使用している他のレシピがあるかチェック
        const { data: recipesWithCategory, error: checkError } = await sb
          .from('recipes')
          .select('id')
          .eq('category', categoryName);
        
        if (checkError) {
          console.error('カテゴリー使用状況チェックエラー:', checkError);
          return;
        }
        
        // 使用しているレシピが0件の場合、categoriesテーブルからも削除
        if (recipesWithCategory.length === 0) {
          console.log('未使用カテゴリーを削除中:', categoryName);
          
          const { error: deleteError } = await sb
            .from('categories')
            .delete()
            .eq('name', categoryName);
          
          if (deleteError) {
            console.error('カテゴリー削除エラー:', deleteError);
          } else {
            console.log('未使用カテゴリーを削除しました:', categoryName);
            
            // index.htmlに未使用カテゴリー削除の通知を送る
            localStorage.setItem('categoryDeleted', JSON.stringify({
              name: categoryName,
              timestamp: Date.now()
            }));
          }
        } else {
          console.log('カテゴリーは他のレシピで使用中:', categoryName, '使用数:', recipesWithCategory.length);
        }
        
      } catch (error) {
        console.error('カテゴリークリーンアップエラー:', error);
      }
    }

    // 未使用タグの削除関数
    async function cleanupUnusedTags(tagsToCheck) {
      if (!Array.isArray(tagsToCheck) || tagsToCheck.length === 0) {
        return;
      }
      
      try {
        console.log('未使用タグのクリーンアップを開始:', tagsToCheck);
        
        // 全レシピのタグを取得
        const { data: allRecipes, error: recipesError } = await sb
          .from('recipes')
          .select('tags')
          .not('tags', 'is', null);
        
        if (recipesError) {
          console.error('レシピ取得エラー:', recipesError);
          return;
        }
        
        // 使用されているタグを集計
        const usedTags = new Set();
        allRecipes.forEach(recipe => {
          if (Array.isArray(recipe.tags)) {
            recipe.tags.forEach(tag => usedTags.add(tag));
          }
        });
        
        // チェック対象のタグで使用されていないものを削除
        for (const tagName of tagsToCheck) {
          if (!usedTags.has(tagName)) {
            console.log('未使用タグを削除:', tagName);
            
            const { error: deleteError } = await sb
              .from('tags')
              .delete()
              .eq('name', tagName);
            
            if (deleteError) {
              console.error('タグ削除エラー:', tagName, deleteError);
            } else {
              console.log('未使用タグ削除成功:', tagName);
            }
          }
        }
        
      } catch (error) {
        console.error('未使用タグクリーンアップエラー:', error);
      }
    }

    function getClientId(){
      let cid = localStorage.getItem('client_id');
      if(!cid){ cid = (crypto?.randomUUID?.() || String(Math.random()).slice(2)); localStorage.setItem('client_id', cid); }
      return cid;
    }
    async function refreshFavState(){
      try{
        const { data } = await sb.from('favorites').select('id').eq('recipe_id', id).eq('client_id', getClientId()).limit(1);
        const on = !!(data && data.length);
        if(favBtn){
          favBtn.textContent = on ? '♥ お気に入り解除' : '♡ お気に入り';
          favBtn.dataset.active = on ? '1' : '0';
        }
      }catch(_){}
    }
    favBtn?.addEventListener('click', async ()=>{
      try{
        const cid = getClientId();
        const { data } = await sb.from('favorites').select('id').eq('recipe_id', id).eq('client_id', cid).limit(1);
        if(data && data.length){
          await sb.from('favorites').delete().eq('id', data[0].id);
        }else{
          await sb.from('favorites').insert({ recipe_id: id, client_id: cid });
        }
        await refreshFavState();
      }catch(e){ alert('お気に入り操作に失敗: ' + (e.message||e)); }
    });

    function esc(s){ return String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    async function load(){
      const { data: recs, error } = await sb.from('recipes').select('*').eq('id', id).limit(1);
      if(error){ console.error(error); alert('レシピの取得に失敗しました'); return; }
      const r = recs?.[0];
      if(!r){ alert('レシピが見つかりません'); return; }

      titleEl.textContent = r.title || '無題のレシピ';
      const dt = r.updated_at || r.created_at;
      metaEl.textContent = dt ? `更新: ${new Date(dt).toLocaleString()}` : '';

      const tags = Array.isArray(r.tags) ? r.tags : (r.tags ? String(r.tags).split(/[,\s]+/).filter(Boolean) : []);
      tagsEl.innerHTML = (tags||[]).map(t=>`<span class="tag">${esc(t)}</span>`).join('');
      notesEl.textContent = r.notes || '';
      
      // レシピ画像の表示
      const recipeImageContainer = document.getElementById('recipeImageContainer');
      const recipeImage = document.getElementById('recipeImage');
      console.log('🔍 画像データ確認:', { 
        hasImageUrl: !!r.image_url, 
        imageUrlLength: r.image_url ? r.image_url.length : 0,
        imageUrlStart: r.image_url ? r.image_url.substring(0, 50) + '...' : 'none'
      });
      
      if (r.image_url && r.image_url.trim()) {
        recipeImage.src = r.image_url;
        recipeImageContainer.style.display = 'flex';
        console.log('📸 レシピ画像を表示しました');
      } else {
        recipeImageContainer.style.display = 'none';
        console.log('❌ 画像データがありません');
      }

      try{
        const { data: ings, error: e1 } = await sb.from('recipe_ingredients').select('*').eq('recipe_id', id).order('position', {ascending:true}).order('id', {ascending:true});
        if(!e1 && ings?.length){
          // 列名を日本語にマッピング
          const columnMapping = {
            'position': '番号',
            'item': '材料名',
            'quantity': '分量',
            'unit': '単位'
          };
          
          const cols = Object.keys(ings[0]).filter(k=>!['id','recipe_id','created_at','updated_at'].includes(k));
          const thead = `<thead><tr>${cols.map(c=>`<th>${esc(columnMapping[c] || c)}</th>`).join('')}</tr></thead>`;
          const tbody = `<tbody>${ings.map(row=>`<tr>${cols.map(c=>`<td>${esc(row[c])}</td>`).join('')}</tr>`).join('')}</tbody>`;
          ingEl.innerHTML = `<table class="table">${thead}${tbody}</table>`;
        }else{
          ingEl.innerHTML = '<div class="muted">未登録</div>';
        }
      }catch(_){
        ingEl.innerHTML = '<div class="muted">未登録</div>';
      }

      try{
        const { data: steps, error: e2 } = await sb.from('recipe_steps').select('*').eq('recipe_id', id).order('position', {ascending:true}).order('id', {ascending:true});
        if(!e2 && steps?.length){
          stepsEl.innerHTML = steps.map(s=>`<li>${esc(s.instruction || s.step || s.description || s.body || '')}</li>`).join('');
        }else{
          stepsEl.innerHTML = '<li class="muted">未登録</li>';
        }
      }catch(_){
        stepsEl.innerHTML = '<li class="muted">未登録</li>';
      }

      await refreshFavState();
    }

    load();
  }catch(e){
    console.error(e);
  }
})();
</script>
</body>
</html>