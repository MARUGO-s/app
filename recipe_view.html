<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ表示 — Recipe Box</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js"></script>
  
  <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>

  <header class="app-header">
    <h1 class="brand">レシピ表示</h1>
    <div class="header-actions" data-actions>
      <button class="btn primary small js-ai-advice">✨ AIアドバイス</button>
      <button class="btn js-edit">編集</button>
      <button class="btn ghost js-delete" style="color: #c0392b; border-color: #c0392b;">削除</button>
      <button class="btn js-back">戻る</button>
    </div>
  </header>

  <main class="container two-col-layout">
    <article class="panel">
      <!-- ★★★ 修正点: お気に入りボタンをこちらに移動 ★★★ -->
      <div class="fav-block" style="text-align: right; margin-bottom: 1rem;">
        <button id="favBtn" class="btn small">♡ お気に入り</button>
      </div>

      <h2 id="recipeTitle">タイトル</h2>
      <div class="muted" id="meta">作成日 — / 更新日 —</div>
      <div id="tags" style="margin:8px 0;"></div>
      <p id="recipeIntro" class="lead"></p>
      <div id="notes" style="margin-top:16px;white-space:pre-wrap;"></div>
    </article>

    <aside class="panel">
      <h3>材料</h3>
      <div id="ingredients">
        <div class="muted">未登録</div>
      </div>

      <h3 style="margin-top:24px;">手順</h3>
      <ol id="steps">
        <li class="muted">未登録</li>
      </ol>
    </aside>
  </main>

  <footer class="app-footer">
    <div><a href="index.html">一覧へ</a></div>
  </footer>

  <!-- AI Chat Modal -->
  <div id="ai-view-modal" class="ai-view-modal-overlay">
    <div class="ai-view-modal-content">
      <header class="ai-view-modal-header">
        <h3 class="ai-view-modal-title">✨ AI レシピ アシスタント</h3>
        <button id="ai-view-modal-close" class="ai-view-modal-close">&times;</button>
      </header>
      <div id="ai-chat-container" class="ai-chat-container">
        <!-- Chat messages will be appended here -->
      </div>
      <div class="ai-input-container">
        <textarea id="ai-user-input" class="input" placeholder="質問や要望を入力..." rows="1"></textarea>
        <button id="ai-send-btn" class="btn primary">送信</button>
      </div>
      <div class="ai-modal-actions">
        <button id="ai-save-new-btn" class="btn primary">この内容で新規作成</button>
      </div>
    </div>
  </div>


  <script>
(function(){
  const params = new URLSearchParams(location.search);
  const id = params.get('id');

  // --- Supabase Client ---
  if (window.supabase && !window.sb) {
    window.sb = window.supabase.createClient("https://ctxyawinblwcbkovfsyj.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q");
  }
  if(!window.sb){ alert('Supabase not initialized'); return; }
  if(!id){ alert('レシピIDがありません'); location.href='index.html'; return; }

  // --- Page Elements ---
  const titleEl = document.querySelector('#recipeTitle');
  const metaEl = document.querySelector('#meta');
  const tagsEl = document.querySelector('#tags');
  const favBtn = document.querySelector('#favBtn');
  const introEl = document.querySelector('#recipeIntro');
  const notesEl = document.querySelector('#notes');
  const ingEl = document.querySelector('#ingredients');
  const stepsEl = document.querySelector('#steps');

  // --- AI Modal Elements ---
  const aiModal = document.querySelector('#ai-view-modal');
  const aiModalCloseBtn = document.querySelector('#ai-view-modal-close');
  const aiChatContainer = document.querySelector('#ai-chat-container');
  const aiUserInput = document.querySelector('#ai-user-input');
  const aiSendBtn = document.querySelector('#ai-send-btn');
  const aiSaveNewBtn = document.querySelector('#ai-save-new-btn');
  
  // --- State ---
  let recipeData = {};
  let chatHistory = [];
  let isAiLoading = false;

  // --- Helper Functions ---
  const esc = (s) => String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  const getClientId = () => {
    let clientId = localStorage.getItem("client_id");
    if (!clientId) {
        clientId = crypto?.randomUUID?.() || String(Math.random()).slice(2);
        localStorage.setItem("client_id", clientId);
    }
    return clientId;
  };

  // --- Main Logic ---
  async function deleteRecipe() {
    if (!confirm('このレシピを完全に削除しますか？')) return;
    const { error } = await sb.from('recipes').delete().eq('id', id);
    if (error) {
      alert('レシピの削除に失敗しました: ' + error.message);
    } else {
      alert('レシピを削除しました。');
      location.href = 'index.html';
    }
  }

  async function loadRecipe() {
    try {
      const { data: r, error } = await sb.from('recipes').select('*').eq('id', id).single();
      if (error || !r) throw new Error('レシピの読み込みに失敗しました。');
      
      recipeData.title = r.title || '無題のレシピ';
      recipeData.intro = r.intro || '';
      recipeData.notes = r.notes || r.meta?.note || '';
      recipeData.tags = r.tags || [];

      titleEl.textContent = recipeData.title;
      metaEl.textContent = r.updated_at ? `更新: ${new Date(r.updated_at).toLocaleString('ja-JP')}` : '';
      tagsEl.innerHTML = recipeData.tags.map(t => `<span class="tag">${esc(t)}</span>`).join('');
      introEl.textContent = recipeData.intro;
      notesEl.textContent = recipeData.notes;

      const { data: ings } = await sb.from('recipe_ingredients').select('item,quantity,unit').eq('recipe_id', id).order('position');
      recipeData.ingredients = ings || [];
      ingEl.innerHTML = recipeData.ingredients.length ? `<table class="table"><thead><tr><th>材料名</th><th class="num">分量</th><th>単位</th></tr></thead><tbody>${ings.map(i => `<tr><td>${esc(i.item)}</td><td class="num">${esc(i.quantity ?? '')}</td><td>${esc(i.unit ?? '')}</td></tr>`).join('')}</tbody></table>` : '<div class="muted">材料は登録されていません。</div>';

      const { data: steps } = await sb.from('recipe_steps').select('instruction').eq('recipe_id', id).order('position');
      recipeData.steps = steps || [];
      stepsEl.innerHTML = recipeData.steps.length > 0 ? steps.map(s => `<li>${esc(s.instruction)}</li>`).join('') : '<li class="muted">手順は登録されていません。</li>';

      setupFavoriteButton(id);
    } catch (err) {
      alert(err.message);
      location.href = 'index.html';
    }
  }

  // --- AI Logic ---
  function renderChatMessage(message, role) {
    const messageEl = document.createElement('div');
    messageEl.className = `ai-chat-message ${role}`;
    messageEl.innerHTML = role === 'assistant' ? marked.parse(message) : esc(message);
    aiChatContainer.appendChild(messageEl);
    aiChatContainer.scrollTop = aiChatContainer.scrollHeight;
  }

  function toggleAiLoading(show) {
    isAiLoading = show;
    aiSendBtn.disabled = show;
    aiUserInput.disabled = show;
    
    const existingSpinner = aiChatContainer.querySelector('.loading-spinner-small');
    if (existingSpinner) existingSpinner.remove();

    if (show) {
      const spinner = document.createElement('div');
      spinner.className = 'loading-spinner-small';
      aiChatContainer.appendChild(spinner);
      aiChatContainer.scrollTop = aiChatContainer.scrollHeight;
    }
  }

  async function fetchWithRetry(url, options, maxRetries = 3) {
      let attempt = 0;
      while (attempt < maxRetries) {
          try {
              const response = await fetch(url, options);
              if (response.status >= 500 && response.status < 600) {
                  throw new Error(`API Server Error: ${response.status}`);
              }
              return response;
          } catch (error) {
              attempt++;
              if (attempt >= maxRetries) {
                  throw error;
              }
              const delay = Math.pow(2, attempt) * 1000;
              console.log(`Attempt ${attempt} failed. Retrying in ${delay}ms...`);
              await new Promise(resolve => setTimeout(resolve, delay));
          }
      }
  }

  async function callGeminiApi() {
    toggleAiLoading(true);
    try {
        const apiKey = "AIzaSyBNgqPMcJiVSysDAaXKzCOv08IGUeuEAwg";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: chatHistory })
        };
        const response = await fetchWithRetry(apiUrl, options);

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const result = await response.json();
        
        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) throw new Error('AIからの応答が空でした。');

        chatHistory.push({ role: "model", parts: [{ text }] });
        renderChatMessage(text, 'assistant');
    } catch (error) {
        console.error("AI Error:", error);
        renderChatMessage(`エラーが発生しました: ${error.message}`, 'assistant');
    } finally {
        toggleAiLoading(false);
    }
  }

  async function handleAiAdviceClick() {
    if (!aiModal) return;
    aiModal.style.display = 'flex';
    aiChatContainer.innerHTML = '';
    
    const ingredientsText = recipeData.ingredients.map(i => `- ${i.item} ${i.quantity || ''} ${i.unit || ''}`).join('\n');
    const stepsText = recipeData.steps.map((s, i) => `${i + 1}. ${s.instruction}`).join('\n');
    
    const initialPrompt = `あなたはプロの料理研究家です。以下のレシピについて、より美味しくするための具体的な改善案、プロならではのコツ、または面白いアレンジ方法を提案してください。回答はフレンドリーな会話形式で、要点をまとめて端的に伝えてください。

# レシピ名: ${recipeData.title}

## 材料
${ingredientsText}

## 手順
${stepsText}`;
    
    chatHistory = [{ role: "user", parts: [{ text: initialPrompt }] }];
    await callGeminiApi();
  }
  
  async function handleSendMessage() {
    const userInput = aiUserInput.value.trim();
    if (!userInput || isAiLoading) return;

    renderChatMessage(userInput, 'user');
    chatHistory.push({ role: "user", parts: [{ text: userInput }] });
    aiUserInput.value = '';
    await callGeminiApi();
  }

  async function handleSaveAsNew() {
      const savePrompt = `私たちのこれまでの会話に基づき、最終的なレシピをJSON形式で提供してください。備考や他のテキストは一切含めず、JSONオブジェクトのみを返してください。JSONのキーは "title", "category", "tags", "notes", "ingredients" (item, quantity, unit を含むオブジェクトの配列), "steps" (文字列の配列) としてください。`;
      
      chatHistory.push({ role: "user", parts: [{ text: savePrompt }] });
      toggleAiLoading(true);

      try {
        const apiKey = "AIzaSyBNgqPMcJiVSysDAaXKzCOv08IGUeuEAwg";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
        const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: chatHistory, generationConfig: { responseMimeType: "application/json" } })
        };
        
        const response = await fetchWithRetry(apiUrl, options);

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const result = await response.json();
        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!jsonText) throw new Error('AIからのJSON応答がありませんでした。');

        localStorage.setItem('ai_generated_recipe', jsonText);
        alert('AIが提案したレシピを編集画面に読み込みます。');
        location.href = 'recipe_edit.html';

      } catch (error) {
        alert(`新規保存の準備に失敗しました: ${error.message}`);
      } finally {
        toggleAiLoading(false);
        chatHistory.pop(); 
      }
  }


  // --- Event Listeners ---
  document.addEventListener('click', (e) => {
    const target = e.target.closest('button');
    if (!target) return;

    if (target.classList.contains('js-edit')) {
        location.href = `recipe_edit.html?id=${id}`;
    } else if (target.classList.contains('js-back')) {
        location.href = 'index.html';
    } else if (target.classList.contains('js-delete')) {
        deleteRecipe();
    } else if (target.classList.contains('js-ai-advice')) {
        handleAiAdviceClick();
    }
  });

  if (aiModal) {
    aiModalCloseBtn.addEventListener('click', () => aiModal.style.display = 'none');
    aiSendBtn.addEventListener('click', handleSendMessage);
    aiSaveNewBtn.addEventListener('click', handleSaveAsNew);
    aiUserInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSendMessage();
      }
    });
  }


  // --- Favorite Button Logic ---
  async function setupFavoriteButton(recipe_id) {
    const clientId = getClientId();
    const { data, error } = await sb.from("favorites").select("id").eq("recipe_id", recipe_id).eq("client_id", clientId).limit(1);
    let isFavorite = data && data.length > 0;

    const updateButton = () => {
        favBtn.innerHTML = isFavorite ? '♥ お気に入り' : '♡ お気に入り';
        favBtn.classList.toggle('danger', isFavorite);
        favBtn.classList.toggle('ghost', !isFavorite);
    };
    updateButton();

    favBtn.addEventListener('click', async () => {
        isFavorite = !isFavorite;
        updateButton();
        try {
            if (isFavorite) {
                await sb.from("favorites").insert({ recipe_id, client_id: clientId });
            } else {
                await sb.from("favorites").delete().eq("recipe_id", recipe_id).eq("client_id", clientId);
            }
        } catch (err) {
            alert("お気に入り状態の更新に失敗しました。");
            isFavorite = !isFavorite; // Revert state
            updateButton();
        }
    });
  }

  // --- Initial Load ---
  loadRecipe();
})();
  </script>
</body>
</html>
