<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>レシピ表示 — Recipe Box</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js"></script>

  <link rel="stylesheet" href="assets/css/style.css">
  <style>
    /* 翻訳タイトルのスタイル */
    .translated-title {
      font-size: 0.9em;
      color: #ffffff;
      font-style: italic;
      margin-top: 0.25rem;
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
      border-left: 3px solid #ddd;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .translated-text {
      font-size: 1em;
    }
    
    .original-text {
      font-size: 0.7em;
      color: #cccccc;
      margin-left: 0.5rem;
    }
    
    .translated-description {
      margin: 1rem 0;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border-left: 3px solid #4a90e2;
    }
    
    .translated-description .translated-text {
      font-size: 1em;
      color: #ffffff;
      margin-bottom: 0.5rem;
    }
    
    .translated-description .original-text {
      font-size: 0.8em;
      color: #cccccc;
      font-style: italic;
    }
    
    .translated-section {
      margin: 1.5rem 0;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      border-left: 3px solid #4a90e2;
    }
    
    .translated-section h4 {
      color: #4a90e2;
      margin-bottom: 1rem;
      font-size: 1.1em;
    }
    
    .original-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .original-section h5 {
      color: #cccccc;
      margin-bottom: 0.5rem;
      font-size: 0.9em;
    }
    
    /* 翻訳ポップアップのダークテーマ */
    .translate-popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
    }
    
    .translate-popup-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2a2a2a;
      padding: 2rem;
      border-radius: 12px;
      min-width: 320px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      border: 1px solid #444;
    }
    
    .translate-popup-content h3 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: #ffffff;
      text-align: center;
      font-size: 1.2em;
    }
    
    .language-buttons {
      margin-bottom: 1.5rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    
    .language-buttons .btn {
      margin: 0;
      padding: 0.75rem 1rem;
      font-size: 0.9em;
      text-align: center;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    
    .language-buttons .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    /* 翻訳中アニメーションのダークテーマ */
    .translate-loading {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1001;
    }
    
    .translate-loading-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2a2a2a;
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      border: 1px solid #444;
      min-width: 200px;
    }
    
    .loading-icon {
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    
    .loading-text {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #ffffff;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #444;
      border-top: 4px solid #4a90e2;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    /* 国旗のスタイル */
    .flag-emoji {
      font-size: 1em;
      margin-left: 0.25rem;
    }

    /* テーブルの幅調整 */
    .table {
      width: 100%;
      max-width: 100%;
      table-layout: fixed;
      word-wrap: break-word;
      border-collapse: collapse;
      border-spacing: 0;
    }
    
    .table th,
    .table td {
      padding: 4px 8px;
      text-align: left;
      vertical-align: top;
      word-break: break-word;
      line-height: 1.5;
      border-bottom: 1px solid rgba(204, 204, 204, 0.5);
    }
    
    .table th:nth-child(1),
    .table td:nth-child(1) {
      width: 8%;
      text-align: center;
    }
    
    .table th:nth-child(2),
    .table td:nth-child(2) {
      width: 40%;
    }
    
    .table th:nth-child(3),
    .table td:nth-child(3) {
      width: 25%;
      text-align: right;
    }
    
    .table th:nth-child(4),
    .table td:nth-child(4) {
      width: 15%;
      text-align: center;
    }
    
    .table th:nth-child(5),
    .table td:nth-child(5) {
      width: 12%;
      text-align: right;
    }
    
    
    /* レスポンシブ対応 */
    @media (max-width: 768px) {
      .table th,
      .table td {
        padding: 3px 6px;
        font-size: 0.9em;
        line-height: 1.5;
        border-bottom: 1px solid rgba(204, 204, 204, 0.5);
      }
      
      .table th:nth-child(1),
      .table td:nth-child(1) {
        width: 10%;
      }
      
      .table th:nth-child(2),
      .table td:nth-child(2) {
        width: 45%;
      }
      
      .table th:nth-child(3),
      .table td:nth-child(3) {
        width: 25%;
      }
      
      .table th:nth-child(4),
      .table td:nth-child(4) {
        width: 20%;
      }
    }
    /* ===== AIモーダル（3タブ統合版） ===== */
    .ai-view-modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:1000; display:none; align-items:center; justify-content:center; }
    .ai-view-modal-content{ background:var(--bg-panel,#fff); color:var(--fg,#222); width:clamp(320px,92vw,860px); max-height:92vh; overflow:hidden; border-radius:12px; box-shadow:0 8px 28px rgba(0,0,0,.35); display:flex; flex-direction:column; }
    .ai-view-modal-header{ display:flex; align-items:center; justify-content:space-between; gap:1rem; padding:.85rem 1rem; border-bottom:1px solid rgba(0,0,0,.08); }
    .ai-view-modal-title{ font-weight:700; }
    .ai-view-modal-close{ background:none; border:none; font-size:1.5rem; line-height:1; cursor:pointer; }
    .ai-view-tabs{ display:flex; gap:.25rem; padding:.5rem; border-bottom:1px solid rgba(0,0,0,.06); background:var(--bg-muted,#f7f7f7); }
    .ai-tab{ padding:.4rem .75rem; border-radius:999px; cursor:pointer; border:1px solid transparent; }
    .ai-tab[aria-selected="true"]{ background:#e8f0fe; border-color:#b6cef7; }
    .ai-chat-container{ flex:1; overflow:auto; padding:1rem; display:none; }
    .ai-chat-container.active{ display:block; }
    .ai-input-row{ display:flex; gap:.5rem; padding:.75rem 1rem; border-top:1px solid rgba(0,0,0,.08); }
    .ai-input-row textarea{ flex:1; resize:vertical; min-height:42px; }
    .ai-btn{ padding:.5rem .85rem; border:1px solid #d0d7de; border-radius:8px; background:#fff; cursor:pointer; }
    .ai-btn.primary{ background:#2563eb; color:#fff; border-color:#2563eb; }
    .ai-msg{ 
      margin:.8rem 0; 
      padding:1rem 1.2rem; 
      border-radius:12px; 
      border:1px solid #e5e7eb; 
      background:#fafafa; 
      line-height:1.7; 
      font-size: 0.95em;
    }
    .ai-msg.user{ 
      background:#eef5ff; 
      border-color:#cfe2ff; 
    }
    
    /* マークダウン風のスタイリング */
    .ai-msg h1, .ai-msg h2, .ai-msg h3, .ai-msg h4 {
      margin: 1.5rem 0 0.8rem 0;
      color: #1a1a1a;
      font-weight: 600;
    }
    
    .ai-msg h1 { font-size: 1.4em; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
    .ai-msg h2 { font-size: 1.3em; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3rem; }
    
    /* ===== ステータスポップアップ ===== */
    .status-popup {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .status-popup-content {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.35);
      display: flex;
      align-items: center;
      gap: 1rem;
      min-width: 300px;
      max-width: 500px;
    }
    
    .status-icon {
      flex-shrink: 0;
    }
    
    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #2563eb;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .status-text {
      flex: 1;
    }
    
    .status-title {
      font-weight: 600;
      font-size: 1.1em;
      color: #1a1a1a;
      margin-bottom: 0.25rem;
    }
    
    .status-message {
      color: #666;
      font-size: 0.9em;
    }
    
    .status-popup.success .spinner {
      border: 3px solid #d1fae5;
      border-top: 3px solid #10b981;
    }
    
    .status-popup.error .spinner {
      border: 3px solid #fee2e2;
      border-top: 3px solid #ef4444;
    }
    
    .status-popup.success .status-title {
      color: #10b981;
    }
    
    .status-popup.error .status-title {
      color: #ef4444;
    }
    .ai-msg h3 { font-size: 1.2em; color: #2563eb; }
    .ai-msg h4 { font-size: 1.1em; color: #374151; }
    
    .ai-msg p {
      margin: 0.8rem 0;
      line-height: 1.7;
    }
    
    .ai-msg ul, .ai-msg ol {
      margin: 0.8rem 0;
      padding-left: 1.5rem;
    }
    
    .ai-msg li {
      margin: 0.4rem 0;
      line-height: 1.6;
    }
    
    .ai-msg strong {
      color: #1a1a1a;
      font-weight: 600;
    }
    
    .ai-msg em {
      color: #6b7280;
      font-style: italic;
    }
    
    .ai-msg blockquote {
      margin: 1rem 0;
      padding: 0.8rem 1rem;
      background: #f8f9fa;
      border-left: 4px solid #2563eb;
      border-radius: 0 6px 6px 0;
    }
    
    .ai-msg code {
      background: #f1f5f9;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.9em;
      color: #dc2626;
    }
    
    .ai-msg pre {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
      margin: 1rem 0;
    }
    
    .ai-msg pre code {
      background: none;
      padding: 0;
      color: #374151;
    }
    
    /* 改善提案の特別なスタイリング */
    .ai-msg .improvement-section {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
    }
    
    .ai-msg .improvement-title {
      color: #0369a1;
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 0.8rem;
    }
    
    .ai-msg .rationale, .ai-msg .implementation, .ai-msg .risk {
      margin: 0.8rem 0;
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
    }
    
    .ai-msg .rationale {
      background: #fef3c7;
      border-left: 3px solid #f59e0b;
    }
    
    .ai-msg .implementation {
      background: #dbeafe;
      border-left: 3px solid #3b82f6;
    }
    
    .ai-msg .risk {
      background: #fee2e2;
      border-left: 3px solid #ef4444;
    }
    
    .ai-msg .rationale::before {
      content: "根拠: ";
      font-weight: 600;
      color: #92400e;
    }
    
    .ai-msg .implementation::before {
      content: "実装: ";
      font-weight: 600;
      color: #1e40af;
    }
    
    .ai-msg .risk::before {
      content: "リスク: ";
      font-weight: 600;
      color: #991b1b;
    }
    .loading{ width:24px; height:24px; border:3px solid rgba(0,0,0,.15); border-top-color:rgba(0,0,0,.45); border-radius:50%; animation:spin 1s linear infinite; margin:.25rem auto; }
    @keyframes spin{ to{ transform:rotate(360deg);} }
    body.modal-open{ overflow:hidden; }
    /* 既存の解析カードの体裁補助 */
    .grid{ display:grid; grid-template-columns: 1fr auto; gap:.25rem .75rem; align-items:baseline; }
    .card .num{ text-align:right; }

    /* AIモーダル内のテーブルを見やすくするスタイル */
    .ai-chat-container table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
        margin-bottom: 1rem;
        font-size: 0.9em;
        line-height: 1.5;
    }
    .ai-chat-container th,
    .ai-chat-container td {
        border: 1px solid #dee2e6; /* var(--line-primary) */
        padding: 0.6rem 0.75rem;
        text-align: left;
        vertical-align: top;
    }
    .ai-chat-container th {
        background-color: #f8f9fa; /* Lighter than --bg-muted */
        font-weight: 600;
    }
    .ai-chat-container tr:nth-child(even) {
        background-color: #f7f7f7; /* var(--bg-muted) */
    }
  </style>
</head>
<body>

  <header class="app-header">
    <h1 class="brand">レシピ表示</h1>
    <div class="header-actions" data-actions>
      <button class="btn primary small js-ai-advice">✨ AIアドバイス</button>
      <button class="btn js-edit">編集</button>
      <button class="btn ghost js-delete" style="color:#c0392b;border-color:#c0392b;">削除</button>
      <button class="btn js-back">戻る</button>
    </div>
  </header>

  <!-- ステータス表示ポップアップ -->
  <div id="statusPopup" class="status-popup" style="display: none;">
    <div class="status-popup-content">
      <div class="status-icon">
        <div class="spinner"></div>
      </div>
      <div class="status-text">
        <div class="status-title">処理中...</div>
        <div class="status-message">しばらくお待ちください</div>
      </div>
    </div>
  </div>

  <main class="container two-col-layout">
    <article class="panel">
      <div class="fav-block" style="text-align:right;margin-bottom:1rem;">
        <button id="favBtn" class="btn small">♡ お気に入り</button>
        <button id="translateBtn" class="btn small" style="margin-left: 0.5rem;" onclick="showTranslatePopup()">🌍 翻訳</button>
      </div>
      <h2 id="recipeTitle">タイトル</h2>
      <div id="translatedTitle" class="translated-title" style="display: none;"></div>
      <div class="muted" id="meta">作成日 — / 更新日 —</div>
      
      <!-- カテゴリーとタグの表示 -->
      <div id="categoryAndTags" style="margin: 8px 0;">
        <div id="categoryDisplay" style="display: none; margin-bottom: 6px;">
          <span class="category-badge" style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 12px; font-size: 0.85em; font-weight: 500; display: inline-block;">
            <i class="fas fa-folder" style="margin-right: 4px; font-size: 0.8em;"></i>
            <span id="categoryText"></span>
          </span>
        </div>
        <div id="tagsDisplay" style="display: none;">
          <div style="display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
            <i class="fas fa-tags" style="color: #7b1fa2; font-size: 0.8em; margin-right: 4px;"></i>
            <div id="tagsContainer" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
          </div>
        </div>
      </div>
      
      <div id="sourceUrlSection" style="margin: 8px 0; display: none;">
        <span class="muted">参考URL: </span>
        <a id="sourceUrlLink" href="#" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: none;">
          <i class="fas fa-external-link-alt" style="margin-right: 4px; font-size: 0.85em;"></i>
          <span id="sourceUrlText"></span>
        </a>
      </div>
      <div id="tags" style="margin:8px 0;"></div>
      
      <!-- レシピ画像表示エリア -->
      <div id="recipeImageContainer" class="recipe-image-container" style="display: none; margin: 16px 0;">
        <img id="recipeImage" src="" alt="レシピ画像" class="recipe-image" />
      </div>
      
      <p id="recipeIntro" class="lead"></p>
      <div id="notes" style="margin-top:16px;white-space:pre-wrap;"></div>
    </article>

    <aside class="panel">
      <h3>材料</h3>
      <div id="ingredients"><div class="muted">未登録</div></div>

      <h3 style="margin-top:24px;">手順</h3>
      <ol id="steps"><li class="muted">未登録</li></ol>

      <section class="card" id="analysisSection" style="display:none;">
        <h3>科学メモ（ベーカーズ％）</h3>
        <div class="grid">
          <div>粉合計</div><div><span id="flour_g">–</span> g (100%)</div>
          <div>加水率</div><div><span id="hydration_bp">–</span>%（水分 <span id="water_g">–</span> g）</div>
          <div>油脂</div><div><span id="fat_bp">–</span>%（<span id="fat_g">–</span> g）</div>
          <div>糖</div><div><span id="sugar_bp">–</span>%（<span id="sugar_g">–</span> g）</div>
          <div>塩</div><div><span id="salt_bp">–</span>%（<span id="salt_g">–</span> g）</div>
          <div>酵母</div><div><span id="yeast_bp">–</span>%（<span id="yeast_g">–</span> g）</div>
        </div>
        <p id="analysisNotes" class="note"></p>
      </section>


    </aside>
  </main>

  <!-- 翻訳ポップアップ -->
  <div id="translatePopup" class="translate-popup">
    <div class="translate-popup-content">
      <h3>翻訳先言語を選択</h3>
      <div class="language-buttons">
        <button class="btn" onclick="startTranslation('fr')">🇫🇷 フランス語</button>
        <button class="btn" onclick="startTranslation('it')">🇮🇹 イタリア語</button>
        <button class="btn" onclick="startTranslation('zh')">🇨🇳 中国語</button>
        <button class="btn" onclick="startTranslation('es')">🇪🇸 スペイン語</button>
        <button class="btn" onclick="startTranslation('de')">🇩🇪 ドイツ語</button>
        <button class="btn" onclick="startTranslation('en')">🇺🇸 英語</button>
      </div>
      <button class="btn ghost" onclick="closeTranslatePopup()">キャンセル</button>
    </div>
  </div>

  <!-- 翻訳中アニメーション -->
  <div id="translateLoading" class="translate-loading">
    <div class="translate-loading-content">
      <div class="loading-icon">🌍</div>
      <div class="loading-text">翻訳中...</div>
      <div class="loading-spinner"></div>
    </div>
  </div>

  <style>
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>

  <div id="aiModal" class="ai-view-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="aiTitle">
    <div class="ai-view-modal-content" tabindex="-1">
      <header class="ai-view-modal-header">
        <div class="ai-view-modal-title" id="aiTitle">✨ AI レシピ アシスタント</div>
        <button class="ai-view-modal-close" id="aiClose" aria-label="閉じる">×</button>
      </header>
      <nav class="ai-view-tabs" role="tablist">
        <button class="ai-tab" role="tab" aria-selected="true" data-tab="advice">提案</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="temps">温度・時間</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="hazards">危害要因</button>
        <button class="ai-tab" role="tab" aria-selected="false" data-tab="new">新規レシピ</button>
      </nav>
      <section id="tab-advice" class="ai-chat-container active"></section>
      <section id="tab-temps" class="ai-chat-container"></section>
      <section id="tab-hazards" class="ai-chat-container"></section>
      <section id="tab-new" class="ai-chat-container"></section>
      <div class="ai-input-row">
        <textarea id="aiInput" placeholder="質問や要望を入力…"></textarea>
        <button class="ai-btn" id="aiSave">新規レシピ化</button>
        <button class="ai-btn primary" id="aiSend">送信</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Supabase 初期化（既に window.sb があれば流用） =====
    if (window.supabase && !window.sb) {
      window.sb = window.supabase.createClient(
        "https://ctxyawinblwcbkovfsyj.supabase.co",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q",
        { auth: { storageKey: 'app-main-11-view', autoRefreshToken: true, persistSession: true, detectSessionInUrl: false } }
      );
    }

    // ===== 要素参照 =====
    const btnOpen = document.querySelector('.js-ai-advice');
    const btnBack = document.querySelector('.js-back');
    console.log('戻るボタン要素:', btnBack);
    const modal = document.getElementById('aiModal');
    const modalContent = modal.querySelector('.ai-view-modal-content');
    const btnClose = document.getElementById('aiClose');
    const tabs = document.querySelectorAll('.ai-tab');
    const panes = { advice: document.getElementById('tab-advice'), temps: document.getElementById('tab-temps'), hazards: document.getElementById('tab-hazards'), new: document.getElementById('tab-new') };
    const input = document.getElementById('aiInput');
    const btnSend = document.getElementById('aiSend');
    const btnSave = document.getElementById('aiSave');
    // 入力の有効/無効切り替え
    function setAIInputEnabled(enabled){
      try{
        if (input) {
          input.disabled = !enabled;
          input.style.opacity = enabled ? '1' : '0.6';
          input.style.pointerEvents = enabled ? 'auto' : 'none';
        }
        if (btnSend) {
          btnSend.disabled = !enabled;
          btnSend.style.opacity = enabled ? '1' : '0.6';
          btnSend.style.pointerEvents = enabled ? 'auto' : 'none';
        }
      }catch(_){}
    }


    // ▼▼▼【変更点 1】会話履歴を保存するオブジェクトを追加 ▼▼▼
    const chatHistories = { advice: [], temps: [], hazards: [], new: [] };

    // ===== タブ切替（遅延生成対応） =====
    const tabLoaded = { advice:false, temps:false, hazards:false, new:false };
    tabs.forEach(t=>t.addEventListener('click', async ()=>{
      tabs.forEach(x=>x.setAttribute('aria-selected','false'));
      t.setAttribute('aria-selected','true');
      Object.values(panes).forEach(p=>p.classList.remove('active'));
      panes[t.dataset.tab].classList.add('active');
      if(!tabLoaded[t.dataset.tab]){ await generateTab(t.dataset.tab); tabLoaded[t.dataset.tab]=true; }
    }));

    // ===== 開閉（Esc/背景クリック/戻る導線） =====
    const openModal = ()=>{ modal.style.display='flex'; document.body.classList.add('modal-open'); modalContent.focus({preventScroll:true}); };
    const closeModal = ()=>{ modal.style.display='none'; document.body.classList.remove('modal-open'); };
    btnOpen?.addEventListener('click', async ()=>{ openModal(); if(!tabLoaded.advice) { await generateTab('advice'); tabLoaded.advice=true; } });
    btnClose?.addEventListener('click', closeModal);
    modal.addEventListener('click', (e)=>{ if(e.target === modal) closeModal(); });
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex') closeModal(); });

    // ===== 翻訳機能拡張 =====
    let enhancedTranslatedData = null;


    // 既存の翻訳機能に新機能を統合
    function toggleEnhancedLanguageDisplay() {
      // 既存の翻訳データがあるかチェック
      if (currentTranslatedData) {
        // 既存の翻訳表示と元表示を切り替え
        const ingredientsEl = document.getElementById('ingredients');
        const stepsEl = document.getElementById('steps');
        
        // 現在翻訳表示中かどうかチェック
        const isTranslatedShowing = ingredientsEl.querySelector('.translated-section');
        
        if (isTranslatedShowing) {
          // 元の表示に戻す - ページをリロード
          location.reload();
        } else {
          // 翻訳版を再表示（元の言語を検出）
          const detectedLanguage = detectOriginalLanguage();
          showTranslatedResult(currentTranslatedData, detectedLanguage);
          btnToggleLanguage.textContent = '🔄 元の言語に戻す';
        }
      }
    }

    // 元の言語を検出する関数
    function detectOriginalLanguage() {
      // 材料名から言語を推定
      const firstIngredient = currentTranslatedData?.ingredients?.[0]?.item || '';
      if (firstIngredient.match(/[スペイン語特有の文字]/)) return 'es';
      if (firstIngredient.match(/[フランス語特有の文字]/)) return 'fr';
      if (firstIngredient.match(/[イタリア語特有の文字]/)) return 'it';
      if (firstIngredient.match(/[ドイツ語特有の文字]/)) return 'de';
      if (firstIngredient.match(/[中国語]/)) return 'zh';
      // デフォルトは英語
      return 'en';
      }
    }

    async function saveEnhancedTranslation() {
      if (!currentTranslatedData) return;

      try {
        const params = new URLSearchParams(location.search);
        const id = params.get('id');

        // 既存の翻訳データを新形式で保存
        await saveTranslationToDatabase(currentTranslatedData, id);
        
        console.log('翻訳を保存しました');
      } catch (error) {
        console.error('翻訳保存エラー:', error);
        throw error;
      }
    }

    async function saveTranslationToDatabase(translatedData, recipeId) {
      // レシピの翻訳情報を保存
      const recipeUpdateData = {
        title_translated: translatedData.title,
        is_translated: true,
        translation_date: new Date().toISOString()
      };

      const { error: recipeError } = await sb.from('recipes')
        .update(recipeUpdateData)
        .eq('id', recipeId);

      if (recipeError) throw recipeError;

      // 材料の翻訳を保存
      if (translatedData.ingredients) {
        for (let i = 0; i < translatedData.ingredients.length; i++) {
          const ing = translatedData.ingredients[i];
          const { error: ingError } = await sb.from('recipe_ingredients')
            .update({
              item_translated: ing.item,
              unit_translated: ing.unit
            })
            .eq('recipe_id', recipeId)
            .eq('position', i + 1);
          
          if (ingError) console.warn('材料翻訳保存エラー:', ingError);
        }
      }

      // 手順の翻訳を保存
      if (translatedData.steps) {
        for (let i = 0; i < translatedData.steps.length; i++) {
          const step = translatedData.steps[i];
          const { error: stepError } = await sb.from('recipe_steps')
            .update({
              instruction_translated: step
            })
            .eq('recipe_id', recipeId)
            .eq('position', i + 1);
          
          if (stepError) console.warn('手順翻訳保存エラー:', stepError);
        }
      }
    }

    // ===== 便利関数 =====
    const md = (s)=>{ try{ return marked.parse(s||''); }catch{ return (s||''); } };
    const pushMsg = (pane, role, text)=>{ 
      const el=document.createElement('div'); 
      el.className=`ai-msg ${role}`; 
      el.innerHTML = role==='assistant'? md(text): (text||''); 
      pane.appendChild(el); 
      
      // 最初のAIアドバイス生成時のみ一番上にスクロール
      const isFirstAIResponse = pane.children.length === 1 && role === 'assistant';
      if (isFirstAIResponse) {
        pane.scrollTop = 0;
      } else {
        pane.scrollTop = pane.scrollHeight;
      }
    };
    const spinner = ()=>{ const d=document.createElement('div'); d.className='loading'; return d; };

    // ===== レシピ抽出 =====
    function scrapeRecipe(){
      const title = document.getElementById('recipeTitle')?.textContent?.trim() || '';
      const ings = Array.from(document.querySelectorAll('#ingredients tbody tr')).map(tr=>{
        const tds = tr.querySelectorAll('td');
        return { item:(tds[0]?.textContent||'').trim(), quantity:(tds[1]?.textContent||'').trim(), unit:(tds[2]?.textContent||'').trim() };
      });
      const steps = Array.from(document.querySelectorAll('#steps li')).map(li=> (li.textContent||'').trim()).filter(Boolean);
      return { title, ings, steps };
    }

    // ===== タブ別プロンプト =====
    function buildPrompts(){
      const { title, ings, steps } = scrapeRecipe();
      const ingText = ings.map(i=>`- ${i.item} ${i.quantity||''} ${i.unit||''}`).join('\n');
      const stepText = steps.map((s,i)=> `${i+1}. ${s}`).join('\n');
      const base = `# ルセット名\n${title||'無題のレシピ'}\n\n## 材料\n${ingText}\n\n## 手順\n${stepText}`;
      const advice = `あなたはプロ向けの調理科学アドバイザーです。${base}

## 改善提案（要約版）

### 主要な改善点（3-4個）

各改善点を簡潔に記述してください：

#### 1. [改善項目名]
- **根拠:** 簡潔な科学的根拠
- **実装:** 具体的な手順（1-2行）
- **注意点:** 重要なリスクや注意事項

#### 2. [改善項目名]
- **根拠:** 簡潔な科学的根拠
- **実装:** 具体的な手順（1-2行）
- **注意点:** 重要なリスクや注意事項

### 調理科学のポイント

重要な調理科学の観点を簡潔に箇条書きで：
- メイラード反応、酵素活性、タンパク質変性など
- パン/生地系の場合はベーカーズ％の妥当性

**必ず簡潔で実用的なアドバイスにしてください。**`;
      const temps = `あなたはプロの食品安全コンサルタントです。以下のレシピの重要管理点（CCP）における温度と時間を管理するための表を作成してください。\n\n${base}\n\n— 出力仕様 —\n- 必ずMarkdownの表形式で出力してください。\n- 表には「工程」「温度（表面/中心）」「時間」「備考（食品安全上の根拠など）」の列を含めてください。`;
      const hazards = `以下のレシピに関する危害要因（微生物/アレルゲン/化学・物理）とCCP候補、簡単な管理基準案を箇条書きで。\n\n${base}`;
      const newRecipe = `あなたはレシピ開発の専門家です。以下の会話履歴・提案内容・現在のレシピ情報をすべて考慮し、改善された新規レシピを厳密なJSONだけで出力してください。

【現在のレシピ情報】
${base}

【出力仕様】
- JSONのみを出力（前後説明・マークダウン不可）
- 形式は次の通り：
{
  "recipe": {
    "title": "料理名",
    "description": "説明",
    "servings": "人数",
    "ingredients": [{"item":"材料名","quantity":"分量","unit":"単位"}],
    "steps": ["手順1","手順2"],
    "notes": "メモ"
  },
  "analysis": "置き換えの理由、味・質感・栄養・安全面の考察を簡潔に"
}
- 単位は g / ml に統一（tsp=5ml, tbsp=15ml, 小さじ=5ml, 大さじ=15ml, カップ=200ml）
- steps は配列のテキストで簡潔に`;
      return { advice, temps, hazards, new: newRecipe };
    }

    // ===== 直接Gemini API呼び出し =====
    async function invokeGemini(prompt, responseSchema){
       const load = spinner();
       const activePane = document.querySelector('.ai-chat-container.active') || panes.advice;
       activePane.appendChild(load);
       try{
         // レート制限対策
         await new Promise(resolve => setTimeout(resolve, 1000));
         
        // SupabaseからAPIキーを取得
        const { data: apiKeys, error: apiError } = await sb.functions.invoke('get-api-keys', {
          body: { keyName: 'GEMINI_API_KEY' }
        });
        
        if (apiError) {
          console.error('APIキー取得エラー:', apiError);
          throw new Error(`APIキーの取得に失敗しました: ${apiError.message}`);
        }
        
        if (!apiKeys || !apiKeys.success) {
          console.error('APIキー取得レスポンス:', apiKeys);
          throw new Error('APIキーの取得に失敗しました: 無効なレスポンス');
        }
        
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKeys.apiKey}`, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
         });
 
         if (!response.ok) {
           const errorData = await response.json();
           throw new Error(`Gemini API エラー: ${errorData.error?.message || response.statusText}`);
         }
 
         const result = await response.json();
         if (result.candidates && result.candidates[0] && result.candidates[0].content) {
           const content = result.candidates[0].content.parts[0].text;
           console.log('[AI raw]', content);
           
           // JSONを抽出
           const jsonMatch = content.match(/\{[\s\S]*\}/);
           if (jsonMatch) {
             try {
               const jsonData = JSON.parse(jsonMatch[0]);
               return jsonData;
             } catch (parseError) {
               console.error('JSON解析エラー:', parseError);
               return { text: content };
             }
           }
           
           return { text: content };
         }
 
         throw new Error('Gemini APIから有効なレスポンスを取得できませんでした');
       }catch(e){ 
         pushMsg(activePane,'assistant',`エラー: ${e.message}`); 
         return null; 
       }
       finally{ load.remove(); }
     }

    // ===== 応答テキスト抽出（Gemini / OpenAI 両対応） =====
    function extractLLMText(r){
      try{
        if (!r) return '';
        if (typeof r === 'string') return r;
        if (r.text) return r.text;
        if (r.output_text) return r.output_text;
        if (r.message && typeof r.message.content === 'string') return r.message.content;
        if (Array.isArray(r.choices) && r.choices.length){
          const ch = r.choices[0];
          return (ch.message && ch.message.content) || ch.text || '';
        }
        if (Array.isArray(r.candidates) && r.candidates.length){
          const cand = r.candidates[0];
          if (cand && cand.content && Array.isArray(cand.content.parts)){
            return cand.content.parts.map(p => (p && p.text) ? p.text : '').join('\n').trim();
          }
        }
        if (r.content && Array.isArray(r.content.parts)){
            return r.content.parts.map(p => p.text || '').join('\n').trim();
        }
        try { return JSON.stringify(r); } catch { return ''; }
      }catch(e){
        console.error('extractLLMText error', e, r);
        return '';
      }
    }
    
    // ===== レシピ表示用ヘルパ =====
    function renderRecipeCard(pane, recipeObj, sourceLabel = 'AI提案'){
      try{
        const title = recipeObj.title || '無題のレシピ';
        const desc = recipeObj.description || recipeObj.notes || '';
        const servings = recipeObj.servings ? String(recipeObj.servings) : '';
        const ings = Array.isArray(recipeObj.ingredients) ? recipeObj.ingredients : [];
        const steps = Array.isArray(recipeObj.steps) ? recipeObj.steps : [];

        const ingTable = `
          <div style="overflow-x: auto; width: 100%; margin-top:8px;">
            <table class="table">
              <thead><tr><th>番号</th><th>材料名</th><th>分量</th><th>単位</th></tr></thead>
              <tbody>
                ${ings.map((it,idx)=>`<tr><td>${idx+1}</td><td>${(it.item||it.name||'').toString()}</td><td>${(it.quantity||'').toString()}</td><td>${(it.unit||'').toString()}</td></tr>`).join('')}
              </tbody>
            </table>
          </div>`;
        const stepList = `<ol style="margin-top:8px;">${steps.map(s=>`<li>${(s||'').toString()}</li>`).join('')}</ol>`;

        const wrap = document.createElement('div');
        wrap.className = 'card';
        wrap.style.padding = '12px';
        wrap.innerHTML = `
          <div class="muted" style="margin-bottom:4px;">${sourceLabel}</div>
          <h4 style="margin:4px 0;">${title}</h4>
          ${servings ? `<div style="margin:4px 0;">人数: ${servings}</div>` : ''}
          ${desc ? `<p style="white-space:pre-wrap;">${desc}</p>` : ''}
          <h5 style="margin-top:8px;">材料</h5>
          ${ingTable}
          <h5 style="margin-top:12px;">手順</h5>
          ${stepList}
        `;
        pane.appendChild(wrap);

        const btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        btnRow.style.marginTop = '8px';
        const btnApply = document.createElement('button');
        btnApply.className = 'ai-btn';
        btnApply.textContent = '反映';
        btnApply.addEventListener('click', ()=> applyRecipeToView(recipeObj));

        const btnNew = document.createElement('button');
        btnNew.className = 'ai-btn primary';
        btnNew.textContent = '新規';
        btnNew.addEventListener('click', ()=>{
          try {
            // 2系統で受け渡し（URLパラメータ + localStorage フォールバック）
            localStorage.setItem('ai_generated_recipe', JSON.stringify(recipeObj));
            const recipeData = encodeURIComponent(JSON.stringify(recipeObj));
            window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
          } catch (_) {
            // パラメータにフォールバック
            const recipeData = encodeURIComponent(JSON.stringify(recipeObj));
            window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
          }
        });
        const btnCancel = document.createElement('button');
        btnCancel.className = 'ai-btn';
        btnCancel.textContent = 'キャンセル';
        btnCancel.addEventListener('click', ()=>{
          // キャンセル: ボタン行を無効化してメッセージ表示
          btnApply.disabled = true;
          btnNew.disabled = true;
          btnCancel.disabled = true;
          const note = document.createElement('div');
          note.className = 'muted';
          note.style.marginTop = '6px';
          note.textContent = 'キャンセルしました';
          pane.appendChild(note);
        });
        btnRow.appendChild(btnApply);
        btnRow.appendChild(btnNew);
        btnRow.appendChild(btnCancel);
        pane.appendChild(btnRow);
      }catch(e){
        console.error('renderRecipeCard error', e);
      }
    }

    function applyRecipeToView(recipe){
      try{
        console.log('applyRecipeToView called with:', recipe);
        const ingEl = document.getElementById('ingredients');
        const stepsEl = document.getElementById('steps');
        const titleEl = document.getElementById('recipeTitle');
        const notesEl = document.getElementById('notes');
        console.log('stepsEl found:', !!stepsEl);
        if (titleEl && recipe.title) titleEl.textContent = recipe.title;
        if (notesEl && (recipe.description || recipe.notes)) notesEl.textContent = recipe.description || recipe.notes;
        const ings = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];
        const cols = ['番号','材料名','分量','単位'];
        const thead = `<thead><tr>${cols.map(c=>`<th>${c}</th>`).join('')}</tr></thead>`;
        const tbody = `<tbody>${ings.map((it,idx)=>`<tr><td>${idx+1}</td><td>${(it.item||it.name||'')}</td><td>${it.quantity||''}</td><td>${it.unit||''}</td></tr>`).join('')}</tbody>`;
        ingEl.innerHTML = `<div style="overflow-x: auto; width: 100%;"><table class="table">${thead}${tbody}</table></div>`;
        const steps = Array.isArray(recipe.steps) ? recipe.steps : [];
        console.log('手順データ:', steps);
        if (steps.length > 0) {
          const stepsHTML = steps.map(s=>`<li>${(s||'').toString()}</li>`).join('');
          console.log('手順HTML:', stepsHTML);
          stepsEl.innerHTML = stepsHTML;
        } else {
          stepsEl.innerHTML = '<li class="muted">未登録</li>';
        }
      }catch(e){ console.error('applyRecipeToView error', e); }
    }

    // ===== タブ内容生成（必要時に呼び出し） =====
    async function generateTab(kind){
      const prompts = buildPrompts();
      const pane = panes[kind];
      const basePrompt = prompts[kind];
      let promptToSend = basePrompt;
      if (kind === 'new' && chatHistories.new.length){
        const historyText = chatHistories.new.map(m=>`${m.role==='user'?'ユーザー':'アシスタント'}:\n${m.content}`).join('\n\n');
        promptToSend = `${basePrompt}\n\n---\n以下はこれまでの会話履歴です。すべて考慮して新規レシピJSONを出力してください。\n\n${historyText}`;
      }
      const r = await invokeGemini(promptToSend);
      const t = extractLLMText(r) || '（結果なし）';
      // JSONを人間向けカード表示
      const jsonMatchForView = t && t.match(/\{[\s\S]*\}/);
      if (jsonMatchForView) {
        try {
          const obj = JSON.parse(jsonMatchForView[0]);
          const recipeObj = obj.recipe || obj;
          renderRecipeCard(pane, recipeObj, 'AI新規レシピ');
          if (obj.analysis) {
            const ana = document.createElement('div');
            ana.className = 'card';
            ana.style.padding = '12px';
            ana.style.marginTop = '8px';
            ana.innerHTML = `<h5>考察</h5><p style="white-space:pre-wrap;">${obj.analysis}</p>`;
            pane.appendChild(ana);
          }
        } catch (_) {
          pushMsg(pane, 'assistant', t);
        }
      } else {
        pushMsg(pane, 'assistant', t);
      }
      chatHistories[kind].push({ role: 'assistant', content: t });
      // 自動整形→適用（new タブのみ）
      if (kind === 'new') {
        try {
          const jsonMatch = t.match(/\{[\s\S]*\}/);
          const jsonText = jsonMatch ? jsonMatch[0] : t;
          const obj = JSON.parse(jsonText);
          localStorage.setItem('ai_generated_recipe', JSON.stringify(obj));
          // ビューへの反映/編集画面ボタンはカードに追加済み
        } catch (_) {}
      }
    }

    // ▼▼▼ 会話履歴を考慮してAIに質問するよう修正 ▼▼▼
    btnSend.addEventListener('click', async ()=>{
      const q = input.value.trim(); if(!q) return;

      const activeTabEl = document.querySelector('.ai-tab[aria-selected="true"]');
      const kind = activeTabEl.dataset.tab;
      const pane = panes[kind];
      const history = chatHistories[kind];
      
      pushMsg(pane,'user',q);
      history.push({ role: 'user', content: q });
      input.value='';

      // ステータス表示開始
      showStatusPopup('AI分析中...', 'AIが回答を生成しています', 'loading');

      try {
        setAIInputEnabled(false);
        const historyText = history.map(msg => {
            return `${msg.role === 'user' ? 'ユーザー' : 'アシスタント'}:\n${msg.content}`;
        }).join('\n\n');

        const initialPrompt = buildPrompts()[kind];
        const fullPrompt = `${initialPrompt}\n\n---\n上記は最初の指示です。以下はそれ以降の会話履歴です。文脈を踏まえて応答を続けてください。\n\n${historyText}`;

        const r = await invokeGemini(fullPrompt);
        const t = extractLLMText(r) || '（結果なし）';
        
        pushMsg(pane,'assistant',t);
        history.push({ role: 'assistant', content: t });
        
        // ステータス表示完了
        updateStatusPopup('完了', 'AI回答を生成しました', 'success');
        setTimeout(hideStatusPopup, 1500);
        
        // 新規レシピ提案の場合、送信ボタンを表示
        if (kind === 'advice' && t.includes('レシピ') && t.includes('材料')) {
          showNewRecipeSendButton(t);
        }
      } catch (error) {
        console.error('AI回答生成エラー:', error);
        updateStatusPopup('エラー', 'AI回答の生成に失敗しました', 'error');
        setTimeout(hideStatusPopup, 3000);
      } finally {
        setAIInputEnabled(true);
        if (input) input.value = '';
      }
    });

    input.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); btnSend.click(); }});

    // ===== ステータスポップアップ制御 =====
    function showStatusPopup(title, message, type = 'loading') {
      const popup = document.getElementById('statusPopup');
      const titleEl = popup.querySelector('.status-title');
      const messageEl = popup.querySelector('.status-message');
      const spinnerEl = popup.querySelector('.spinner');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // クラスをリセット
      popup.className = 'status-popup';
      if (type !== 'loading') {
        popup.classList.add(type);
        // 成功・エラー時はスピナーを非表示
        spinnerEl.style.display = 'none';
      } else {
        spinnerEl.style.display = 'block';
      }
      
      popup.style.display = 'flex';
    }
    
    function hideStatusPopup() {
      const popup = document.getElementById('statusPopup');
      popup.style.display = 'none';
    }
    
    function updateStatusPopup(title, message, type = 'loading') {
      const popup = document.getElementById('statusPopup');
      const titleEl = popup.querySelector('.status-title');
      const messageEl = popup.querySelector('.status-message');
      const spinnerEl = popup.querySelector('.spinner');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // クラスを更新
      popup.className = 'status-popup';
      if (type !== 'loading') {
        popup.classList.add(type);
        spinnerEl.style.display = 'none';
      } else {
        spinnerEl.style.display = 'block';
      }
    }

    // ===== 新規レシピ送信機能 =====
    function showNewRecipeSendButton(recipeText) {
      // 既存の送信ボタンを削除
      const existingBtn = document.getElementById('newRecipeSendBtn');
      if (existingBtn) existingBtn.remove();
      
      // 新規レシピ送信ボタンを作成
      const sendBtn = document.createElement('button');
      sendBtn.id = 'newRecipeSendBtn';
      sendBtn.className = 'ai-btn primary';
      sendBtn.innerHTML = '📝 新規レシピとして作成';
      sendBtn.style.marginTop = '10px';
      sendBtn.style.width = '100%';
      
      // ボタンをAIアドバイスパネルに追加
      const advicePane = panes.advice;
      if (advicePane) {
        advicePane.appendChild(sendBtn);
        
        // ボタンクリックイベント
        sendBtn.addEventListener('click', async () => {
          try {
            await createNewRecipeFromText(recipeText);
          } catch (error) {
            console.error('新規レシピ作成エラー:', error);
            updateStatusPopup('エラー', '新規レシピの作成に失敗しました', 'error');
            setTimeout(hideStatusPopup, 3000);
          }
        });
      }
    }
    
    async function createNewRecipeFromText(recipeText) {
      console.log('新規レシピ作成開始:', recipeText);
      
      // ステータス表示開始
      showStatusPopup('レシピ構造化中...', 'AIがレシピデータを整理しています', 'loading');
      
      try {
        // レシピテキストを構造化
        const structuredPrompt = `以下のレシピテキストを構造化されたJSON形式に変換してください：

${recipeText}

以下のJSON形式で回答してください（コメントや説明は含めず、JSONのみを返してください）：
{
  "title": "料理名",
  "description": "料理の説明",
  "servings": "人数",
  "ingredients": [
    {
      "item": "材料名",
      "quantity": "分量",
      "unit": "単位"
    }
  ],
  "steps": [
    "手順1",
    "手順2"
  ],
  "notes": "メモやコツ"
}`;

        updateStatusPopup('AI処理中...', 'レシピデータを構造化しています', 'loading');
        
        const result = await invokeGemini(structuredPrompt);
        const structuredRecipe = result || {};
        
        console.log('構造化されたレシピ:', structuredRecipe);
        
        if (!structuredRecipe.title || !structuredRecipe.ingredients || !structuredRecipe.steps) {
          throw new Error('レシピの構造化に失敗しました');
        }
        
        updateStatusPopup('ページ準備中...', '新規レシピ作成ページを開いています', 'loading');
        
        // 新規レシピ作成ページに遷移
        const recipeData = encodeURIComponent(JSON.stringify(structuredRecipe));
        window.open(`recipe_edit.html?newRecipe=${recipeData}`, '_blank');
        
        // 送信ボタンを削除
        const sendBtn = document.getElementById('newRecipeSendBtn');
        if (sendBtn) sendBtn.remove();
        
        // ステータス表示完了
        updateStatusPopup('完了', '新規レシピ作成ページを開きました！', 'success');
        setTimeout(hideStatusPopup, 2000);
        
      } catch (error) {
        console.error('新規レシピ作成エラー:', error);
        throw error; // エラーを上位に再スロー
      }
    }

    // ▼▼▼【ここから元に戻した箇所】▼▼▼
    // ===== 新規レシピ化（JSON + 単位正規化） =====
    btnSave.addEventListener('click', async ()=>{
      const schema = { type:"OBJECT", properties:{ title:{type:"STRING"}, category:{type:"STRING"}, tags:{type:"ARRAY",items:{type:"STRING"}}, notes:{type:"STRING"}, ingredients:{type:"ARRAY", items:{type:"OBJECT", properties:{ item:{type:"STRING"}, quantity:{type:"STRING"}, unit:{type:"STRING"} }, required:["item"]}}, steps:{type:"ARRAY",items:{type:"STRING"}} }, required:["title","category","tags","notes","ingredients","steps"] };
      
      // 新規レシピ化専用のプロンプトを作成
      const { title, ings, steps } = scrapeRecipe();
      const ingText = ings.map(i=>`- ${i.item} ${i.quantity||''} ${i.unit||''}`).join('\n');
      const stepText = steps.map((s,i)=> `${i+1}. ${s}`).join('\n');
      
      const recipePrompt = `以下のレシピを基に、改善された新レシピを作成してください：

# レシピ名
${title||'無題のレシピ'}

## 材料
${ingText}

## 手順
${stepText}

## 出力仕様
1. 上記レシピを改善し、新しいレシピを作成してください
2. 材料はg/mlを基本単位とし、単位省略不可
3. 同義単位は変換してください（tsp=5ml, tbsp=15ml, 小さじ=5ml, 大さじ=15ml）
4. 以下のJSON形式でのみ回答してください（マークダウン記号は使用しない）：

{
  "title": "改善されたレシピ名",
  "category": "カテゴリ",
  "tags": ["タグ1", "タグ2"],
  "notes": "レシピの説明やコツ",
  "ingredients": [
    {"item": "材料名", "quantity": "分量", "unit": "単位"}
  ],
  "steps": ["手順1", "手順2"]
}`;

      // 会話履歴（提案タブ）を考慮
      let promptWithHistory = recipePrompt;
      if (chatHistories.advice && chatHistories.advice.length){
        const historyText = chatHistories.advice.map(m=>`${m.role==='user'?'ユーザー':'アシスタント'}:\n${m.content}`).join('\n\n');
        promptWithHistory = `${recipePrompt}\n\n---\n以下はこれまでの会話履歴です。置き換え依頼や条件を必ず考慮して出力してください。\n\n${historyText}\n\n---\n出力は次のJSON形式：\n{\n  "recipe": {"title":"…","description":"…","servings":"…","ingredients":[{"item":"…","quantity":"…","unit":"…"}],"steps":["…","…"],"notes":"…"},\n  "analysis": "置き換えの理由・味・質感・安全の考察"\n}`;
      }
      const r = await invokeGemini(promptWithHistory, schema);
      const jsonText = extractLLMText(r);
      if (!jsonText){ alert('JSONを取得できませんでした。'); return; }
      try{
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        const cleanJsonText = jsonMatch ? jsonMatch[0] : jsonText;
        const parsed = JSON.parse(cleanJsonText);
        const obj = parsed.recipe || parsed;
        // 単位の軽い正規化（スプーン換算）
        const unitMap = { 'tsp':'ml', 'tbsp':'ml', '小さじ':'ml', '大さじ':'ml' };
        const toVol = (q,u)=>{ const n=Number(q); if(!Number.isFinite(n)) return q; if(u==='tsp'||u==='小さじ') return n*5; if(u==='tbsp'||u==='大さじ') return n*15; return n; };
        obj.ingredients = (obj.ingredients||[]).map(it=>{ const u=(it.unit||'').toLowerCase(); if(unitMap[u]) return { ...it, quantity:String(toVol(it.quantity,u)), unit:'ml' }; return it; });
        // 同じチャットライン（提案タブ）に人間向けカードで表示し、反映/編集ボタンを提供
        renderRecipeCard(panes.advice, obj, '新規レシピ化（AI）');
        if (parsed.analysis) {
          const ana = document.createElement('div');
          ana.className = 'card';
          ana.style.padding = '12px';
          ana.style.marginTop = '8px';
          ana.innerHTML = `<h5>考察</h5><p style="white-space:pre-wrap;">${parsed.analysis}</p>`;
          panes.advice.appendChild(ana);
        }
        localStorage.setItem('ai_generated_recipe', JSON.stringify(obj));
      }catch(e){
        console.error('JSON解析エラー:', e, '元のテキスト:', jsonText);
        alert('JSONの解析に失敗: '+ e.message + '\n\n取得されたテキスト: ' + jsonText.substring(0, 200) + '...');
      }
    });
    // ▲▲▲【ここまで元に戻した箇所】▲▲▲
  </script>

<script>
// ===== レシピ読み込み（URLの id から取得して表示） =====
(function(){
  try{
    const params = new URLSearchParams(location.search);
    const id = params.get('id');
    if(!id){
      alert('レシピIDがありません'); location.href='index.html'; return;
    }

    if(!window.sb && window.supabase){
      window.sb = window.supabase.createClient(
        "https://ctxyawinblwcbkovfsyj.supabase.co",
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN0eHlhd2luYmx3Y2Jrb3Zmc3lqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ5NzE3MzIsImV4cCI6MjA3MDU0NzczMn0.HMMoDl_LPz8uICruD_tzn75eUpU7rp3RZx_N8CEfO1Q"
      );
    }
    if(!window.sb){ console.error('Supabase not initialized'); return; }
    const sb = window.sb;
    
    // 言語コードから国旗を取得する関数
    const getFlagEmoji = (languageCode) => {
      const flagMap = {
        'fr': '🇫🇷', // フランス
        'it': '🇮🇹', // イタリア
        'ja': '🇯🇵', // 日本
        'zh': '🇨🇳', // 中国
        'es': '🇪🇸', // スペイン
        'de': '🇩🇪', // ドイツ
        'en': '🇺🇸'  // アメリカ（英語）
      };
      return flagMap[languageCode] || '🌐';
    };

    const titleEl = document.getElementById('recipeTitle');
    const metaEl  = document.getElementById('meta');
    const tagsEl  = document.getElementById('tags');
    const notesEl = document.getElementById('notes');
    const ingEl   = document.getElementById('ingredients');
    const stepsEl = document.getElementById('steps');
    const btnEdit   = document.querySelector('.js-edit');
    const btnDelete = document.querySelector('.js-delete');
    const btnBack   = document.querySelector('.js-back');
    const favBtn    = document.getElementById('favBtn');

    btnEdit?.addEventListener('click', ()=>{ location.href = `recipe_edit.html?id=${encodeURIComponent(id)}`; });
    btnBack?.addEventListener('click', ()=>{
      console.log('戻るボタンがクリックされました');
      location.href='index.html';
    });
    btnDelete?.addEventListener('click', async ()=>{
      if(!confirm('このレシピを削除しますか？（材料・手順は残る場合があります）')) return;
      try{
        // 削除前に現在のレシピのカテゴリーとタグを取得
        const { data: currentRecipe } = await sb.from('recipes').select('category, tags').eq('id', id).single();
        const deletedCategory = currentRecipe?.category;
        const deletedTags = Array.isArray(currentRecipe?.tags) ? currentRecipe.tags : [];
        
        // レシピを削除
        await sb.from('recipes').delete().eq('id', id);
        
        // カスタムカテゴリーの自動削除チェック
        if (deletedCategory) {
          await cleanupUnusedCategory(deletedCategory);
        }
        
        // タグの自動削除チェック
        if (deletedTags.length > 0) {
          await cleanupUnusedTags(deletedTags);
        }
        
        alert('削除しました'); 
        location.href = 'index.html';
      }catch(e){ 
        alert('削除に失敗: ' + (e.message||e)); 
      }
    });
    
    // 未使用カテゴリーの削除関数
    async function cleanupUnusedCategory(categoryName) {
      try {
        console.log('カテゴリー使用状況をチェック中:', categoryName);
        
        // 基本カテゴリーは削除しない
        const basicCategories = [
          'すべて', 'アミューズ', '前菜', 'ソース', 'スープ', 'パスタ', 
          '魚料理', '肉料理', 'メイン', 'デザート', 'パン', 'その他'
        ];
        
        if (basicCategories.includes(categoryName)) {
          console.log('基本カテゴリーなので削除をスキップ:', categoryName);
          return;
        }
        
        // 同じカテゴリーを使用している他のレシピがあるかチェック
        const { data: recipesWithCategory, error: checkError } = await sb
          .from('recipes')
          .select('id')
          .eq('category', categoryName);
        
        if (checkError) {
          console.error('カテゴリー使用状況チェックエラー:', checkError);
          return;
        }
        
        // 使用しているレシピが0件の場合、categoriesテーブルからも削除
        if (recipesWithCategory.length === 0) {
          console.log('未使用カテゴリーを削除中:', categoryName);
          
          const { error: deleteError } = await sb
            .from('categories')
            .delete()
            .eq('name', categoryName);
          
          if (deleteError) {
            console.error('カテゴリー削除エラー:', deleteError);
          } else {
            console.log('未使用カテゴリーを削除しました:', categoryName);
            
            // index.htmlに未使用カテゴリー削除の通知を送る
            localStorage.setItem('categoryDeleted', JSON.stringify({
              name: categoryName,
              timestamp: Date.now()
            }));
          }
        } else {
          console.log('カテゴリーは他のレシピで使用中:', categoryName, '使用数:', recipesWithCategory.length);
        }
        
      } catch (error) {
        console.error('カテゴリークリーンアップエラー:', error);
      }
    }

    // 未使用タグの削除関数
    async function cleanupUnusedTags(tagsToCheck) {
      if (!Array.isArray(tagsToCheck) || tagsToCheck.length === 0) {
        return;
      }
      
      try {
        console.log('未使用タグのクリーンアップを開始:', tagsToCheck);
        
        // 全レシピのタグを取得
        const { data: allRecipes, error: recipesError } = await sb
          .from('recipes')
          .select('tags')
          .not('tags', 'is', null);
        
        if (recipesError) {
          console.error('レシピ取得エラー:', recipesError);
          return;
        }
        
        // 使用されているタグを集計
        const usedTags = new Set();
        allRecipes.forEach(recipe => {
          if (Array.isArray(recipe.tags)) {
            recipe.tags.forEach(tag => usedTags.add(tag));
          }
        });
        
        // チェック対象のタグで使用されていないものを削除
        for (const tagName of tagsToCheck) {
          if (!usedTags.has(tagName)) {
            console.log('未使用タグを削除:', tagName);
            
            const { error: deleteError } = await sb
              .from('tags')
              .delete()
              .eq('name', tagName);
            
            if (deleteError) {
              console.error('タグ削除エラー:', tagName, deleteError);
            } else {
              console.log('未使用タグ削除成功:', tagName);
            }
          }
        }
        
      } catch (error) {
        console.error('未使用タグクリーンアップエラー:', error);
      }
    }

    function getClientId(){
      let cid = localStorage.getItem('client_id');
      if(!cid){ cid = (crypto?.randomUUID?.() || String(Math.random()).slice(2)); localStorage.setItem('client_id', cid); }
      return cid;
    }
    async function refreshFavState(){
      try{
        const { data } = await sb.from('favorites').select('id').eq('recipe_id', id).eq('client_id', getClientId()).limit(1);
        const on = !!(data && data.length);
        if(favBtn){
          favBtn.textContent = on ? '♥ お気に入り解除' : '♡ お気に入り';
          favBtn.dataset.active = on ? '1' : '0';
        }
      }catch(_){}
    }
    favBtn?.addEventListener('click', async ()=>{
      try{
        const cid = getClientId();
        const { data } = await sb.from('favorites').select('id').eq('recipe_id', id).eq('client_id', cid).limit(1);
        if(data && data.length){
          await sb.from('favorites').delete().eq('id', data[0].id);
        }else{
          await sb.from('favorites').insert({ recipe_id: id, client_id: cid });
        }
        await refreshFavState();
      }catch(e){ alert('お気に入り操作に失敗: ' + (e.message||e)); }
    });

    function esc(s){ return String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    // HTML形式のレシピを読み込む関数
    async function loadHTMLFormatRecipe(recipe) {
      console.log('HTML形式レシピの詳細読み込み:', recipe);
      
      // タイトルとメタ情報を設定
      titleEl.textContent = recipe.title || '無題のレシピ';
      const dt = recipe.updated_at || recipe.created_at;
      metaEl.textContent = dt ? `更新: ${new Date(dt).toLocaleString()}` : '';
      
      // カテゴリーとタグの表示
      const categoryDisplay = document.getElementById('categoryDisplay');
      const categoryText = document.getElementById('categoryText');
      const tagsDisplay = document.getElementById('tagsDisplay');
      const tagsContainer = document.getElementById('tagsContainer');
      
      if (recipe.category && recipe.category.trim()) {
        categoryText.textContent = recipe.category;
        categoryDisplay.style.display = 'block';
      } else {
        categoryDisplay.style.display = 'none';
      }
      
      if (recipe.tags && Array.isArray(recipe.tags) && recipe.tags.length > 0) {
        tagsContainer.innerHTML = '';
        recipe.tags.forEach(tag => {
          const tagEl = document.createElement('span');
          tagEl.className = 'tag';
          tagEl.textContent = tag;
          tagsContainer.appendChild(tagEl);
        });
        tagsDisplay.style.display = 'block';
      } else {
        tagsDisplay.style.display = 'none';
      }
      
      // 説明文をHTML形式で表示
      const notesEl = document.getElementById('notes');
      if (notesEl && recipe.notes) {
        notesEl.innerHTML = recipe.notes; // HTML形式の説明文をそのまま表示
      }
      
      // 材料をHTML形式で表示
      const ingredientsEl = document.getElementById('ingredients');
      if (ingredientsEl) {
        try {
          const { data: ingredients, error: ingredientsError } = await sb
            .from('recipe_ingredients')
            .select('*')
            .eq('recipe_id', recipe.id)
            .order('position');
          
          if (!ingredientsError && ingredients && ingredients.length > 0) {
            // HTML形式の材料がある場合はそれを使用
            const hasHTMLContent = ingredients.some(ing => ing.html_content);
            if (hasHTMLContent) {
              // 翻訳版と元の日本語版を分けて表示
              // 材料の総数から翻訳版の数を推定（通常は半分）
              const totalIngredients = ingredients.length;
              const translatedCount = Math.floor(totalIngredients / 2);
              const translatedIngredients = ingredients.filter(ing => ing.position <= translatedCount);
              const originalIngredients = ingredients.filter(ing => ing.position > translatedCount);
              
              const translatedTableHTML = `
                <div class="translated-section">
                  <h4>材料 (Ingredients)</h4>
                  <div style="overflow-x: auto; width: 100%;">
                    <table class="table">
                      <thead>
                        <tr>
                          <th>番号</th>
                          <th>材料名</th>
                          <th>分量</th>
                          <th>単位</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${translatedIngredients.map((ing, index) => ing.html_content || `
                          <tr>
                            <td>${index + 1}</td>
                            <td>${ing.item}</td>
                            <td>${ing.quantity}</td>
                            <td>${ing.unit}</td>
                          </tr>
                        `).join('')}
                      </tbody>
                    </table>
                  </div>
                </div>
              `;
              
              const originalTableHTML = `
                <div class="original-section">
                  <h5>元の材料</h5>
                  <div style="overflow-x: auto; width: 100%;">
                    <table class="table">
                      <thead>
                        <tr>
                          <th>番号</th>
                          <th>材料名</th>
                          <th>分量</th>
                          <th>単位</th>
                          <th>価格</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${originalIngredients.map((ing, index) => ing.html_content || `
                          <tr>
                            <td>${index + 1}</td>
                            <td>${ing.item}</td>
                            <td>${ing.quantity}</td>
                            <td>${ing.unit}</td>
                            <td>${ing.price || ''}</td>
                          </tr>
                        `).join('')}
                      </tbody>
                    </table>
                  </div>
                </div>
              `;
              
              ingredientsEl.innerHTML = translatedTableHTML + originalTableHTML;
            } else {
              // 通常の材料表示
              const tableHTML = `
                <div class="table">
                  <table>
                    <thead>
                      <tr>
                        <th>番号</th>
                        <th>材料名</th>
                        <th>分量</th>
                        <th>単位</th>
                        <th>price</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${ingredients.map(ing => `
                        <tr>
                          <td>${ing.position}</td>
                          <td>${ing.item}</td>
                          <td>${ing.quantity}</td>
                          <td>${ing.unit}</td>
                          <td>${ing.price || ''}</td>
                        </tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              `;
              ingredientsEl.innerHTML = tableHTML;
            }
          } else {
            ingredientsEl.innerHTML = '<div class="muted">未登録</div>';
          }
        } catch (error) {
          console.error('材料読み込みエラー:', error);
          ingredientsEl.innerHTML = '<div class="muted">読み込みエラー</div>';
        }
      }
      
      // 手順をHTML形式で表示
      const stepsEl = document.getElementById('steps');
      if (stepsEl) {
        try {
          const { data: steps, error: stepsError } = await sb
            .from('recipe_steps')
            .select('*')
            .eq('recipe_id', recipe.id)
            .order('position');
          
          if (!stepsError && steps && steps.length > 0) {
            // HTML形式の手順がある場合はそれを使用
            const hasHTMLContent = steps.some(step => step.html_content);
            if (hasHTMLContent) {
              // HTML形式の手順をそのまま表示
              const stepsHTML = steps.map(step => step.html_content || `
                <div class="step">
                  <span class="step-number">${step.position}.</span>
                  <span class="step-text">${step.instruction}</span>
                </div>
              `).join('');
              stepsEl.innerHTML = stepsHTML;
            } else {
              // 通常の手順表示
              const stepsHTML = steps.map(step => `
                <div class="step">
                  <span class="step-number">${step.position}.</span>
                  <span class="step-text">${step.instruction}</span>
                </div>
              `).join('');
              stepsEl.innerHTML = stepsHTML;
            }
          } else {
            stepsEl.innerHTML = '<div class="muted">未登録</div>';
          }
        } catch (error) {
          console.error('手順読み込みエラー:', error);
          stepsEl.innerHTML = '<div class="muted">読み込みエラー</div>';
        }
      }
      
      // 画像の表示
      if (recipe.image_url) {
        const imageContainer = document.getElementById('recipeImageContainer');
        const imageEl = document.getElementById('recipeImage');
        if (imageContainer && imageEl) {
          imageEl.src = recipe.image_url;
          imageContainer.style.display = 'block';
        }
      }
    }

    async function load(){
      
      const { data: recs, error } = await sb.from('recipes').select('*').eq('id', id).limit(1);
      if(error){ console.error(error); alert('レシピの取得に失敗しました'); return; }
      const r = recs?.[0];
      if(!r){ alert('レシピが見つかりません'); return; }

      titleEl.textContent = r.title || '無題のレシピ';
      
      // HTML形式のレシピかどうかチェック
      if (r.display_format === 'html') {
        console.log('HTML形式のレシピを読み込み中...');
        await loadHTMLFormatRecipe(r);
        return; // HTML形式の場合は早期リターン
      }
      
      // 翻訳タイトルの取得・表示
      try {
        console.log('翻訳データを取得中... recipe_id:', id);
        const { data: translations, error: translationError } = await sb
          .from('recipe_translations')
          .select('translated_title, language_code, html_content')
          .eq('recipe_id', id);
        
        console.log('翻訳取得結果:', { translations, translationError });
        
        // テーブルが存在しない場合のエラーハンドリング
        if (translationError) {
          if (translationError.code === 'PGRST116' || translationError.message.includes('relation "recipe_translations" does not exist')) {
            console.log('recipe_translationsテーブルが存在しません。翻訳機能をスキップします。');
            console.log('テーブルを作成するには、fix_recipe_translations_error.sqlを実行してください。');
          } else if (translationError.code === 'PGRST205' || translationError.message.includes('column') || translationError.status === 400) {
            console.log('recipe_translationsテーブルの構造に問題があります。翻訳機能をスキップします。');
            console.log('テーブル構造を確認してください。');
          } else {
            console.error('翻訳取得エラー:', translationError);
          }
        } else if (translations && translations.length > 0) {
          const translation = translations[0];
          console.log('表示する翻訳:', translation);
          const translatedTitleEl = document.getElementById('translatedTitle');
          if (translatedTitleEl) {
            // HTML形式の翻訳タイトルがある場合はそれを使用
            if (translation.html_content) {
              translatedTitleEl.innerHTML = translation.html_content;
            } else {
              // 通常の翻訳タイトル表示
              const flagEmoji = getFlagEmoji(translation.language_code);
              translatedTitleEl.innerHTML = `${translation.translated_title} <span class="flag-emoji">${flagEmoji}</span>`;
            }
            translatedTitleEl.style.display = 'block';
            console.log('翻訳タイトルを表示:', translation.translated_title);
          } else {
            console.error('translatedTitle要素が見つかりません');
          }
        } else {
          console.log('翻訳データがありません');
        }
      } catch (translationError) {
        console.error('翻訳取得エラー:', translationError);
        if (translationError.message && translationError.message.includes('recipe_translations')) {
          console.log('recipe_translationsテーブルが存在しない可能性があります。');
        }
      }
      
      const dt = r.updated_at || r.created_at;
      metaEl.textContent = dt ? `更新: ${new Date(dt).toLocaleString()}` : '';

      // カテゴリーとタグの表示
      const categoryDisplay = document.getElementById('categoryDisplay');
      const categoryText = document.getElementById('categoryText');
      const tagsDisplay = document.getElementById('tagsDisplay');
      const tagsContainer = document.getElementById('tagsContainer');
      
      // カテゴリー表示
      if (r.category && r.category.trim()) {
        categoryText.textContent = r.category;
        categoryDisplay.style.display = 'inline-block';
      } else {
        categoryDisplay.style.display = 'none';
      }
      
      // タグ表示（個別バッジ）
      const tags = Array.isArray(r.tags) ? r.tags : (r.tags ? String(r.tags).split(/[,\s]+/).filter(Boolean) : []);
      if (tags && tags.length > 0) {
        tagsContainer.innerHTML = tags.map(tag => 
          `<span style="background: #f3e5f5; color: #7b1fa2; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: 500; white-space: nowrap;">${esc(tag)}</span>`
        ).join('');
        tagsDisplay.style.display = 'block';
      } else {
        tagsDisplay.style.display = 'none';
      }

      tagsEl.innerHTML = (tags||[]).map(t=>`<span class="tag">${esc(t)}</span>`).join('');
      notesEl.textContent = r.notes || '';
      
      // source_url表示処理
      const sourceUrlSection = document.getElementById('sourceUrlSection');
      const sourceUrlLink = document.getElementById('sourceUrlLink');
      const sourceUrlText = document.getElementById('sourceUrlText');
      if (r.source_url && r.source_url.trim()) {
        sourceUrlLink.href = r.source_url;
        sourceUrlText.textContent = r.source_url;
        sourceUrlSection.style.display = 'block';
      } else {
        sourceUrlSection.style.display = 'none';
      }
      
      // レシピ画像の表示
      const recipeImageContainer = document.getElementById('recipeImageContainer');
      const recipeImage = document.getElementById('recipeImage');
      console.log('🔍 画像データ確認:', { 
        hasImageUrl: !!r.image_url, 
        imageUrlLength: r.image_url ? r.image_url.length : 0,
        imageUrlStart: r.image_url ? r.image_url.substring(0, 50) + '...' : 'none'
      });
      
      if (r.image_url && r.image_url.trim()) {
        recipeImage.src = r.image_url;
        recipeImageContainer.style.display = 'flex';
        console.log('📸 レシピ画像を表示しました');
      } else {
        recipeImageContainer.style.display = 'none';
        console.log('❌ 画像データがありません');
      }

      try{
        const { data: ings, error: e1 } = await sb.from('recipe_ingredients').select('*').eq('recipe_id', id).order('position', {ascending:true}).order('id', {ascending:true});
        if(!e1 && ings?.length){
          // 列名を日本語にマッピング
          const columnMapping = {
            'position': '番号',
            'item': '材料名',
            'quantity': '分量',
            'unit': '単位',
            'price': '価格',
            'html_content': 'HTML形式'
          };
          
          const cols = ['position', 'item', 'quantity', 'unit'].filter(k => ings[0].hasOwnProperty(k));
          const thead = `<thead><tr>${cols.map(c=>`<th>${esc(columnMapping[c] || c)}</th>`).join('')}</tr></thead>`;
          const tbody = `<tbody>${ings.map(row=>`<tr>${cols.map(c=>`<td>${esc(row[c])}</td>`).join('')}</tr>`).join('')}</tbody>`;
          ingEl.innerHTML = `<div style="overflow-x: auto; width: 100%;"><table class="table">${thead}${tbody}</table></div>`;
        }else{
          ingEl.innerHTML = '<div class="muted">未登録</div>';
        }
      }catch(_){
        ingEl.innerHTML = '<div class="muted">未登録</div>';
      }

      try{
        const { data: steps, error: e2 } = await sb.from('recipe_steps').select('*').eq('recipe_id', id).order('position', {ascending:true}).order('id', {ascending:true});
        if(!e2 && steps?.length){
          stepsEl.innerHTML = steps.map(s=>`<li>${esc(s.instruction || s.step || s.description || s.body || '')}</li>`).join('');
        }else{
          stepsEl.innerHTML = '<li class="muted">未登録</li>';
        }
      }catch(_){
        stepsEl.innerHTML = '<li class="muted">未登録</li>';
      }

      await refreshFavState();
    }


    load();
  }catch(e){
    console.error(e);
  }
})();


// 翻訳機能
let currentTranslatedData = null;

// 言語コードから国旗を取得する関数
const getFlagEmoji = (languageCode) => {
  const flagMap = {
    'fr': '🇫🇷', // フランス
    'it': '🇮🇹', // イタリア
    'ja': '🇯🇵', // 日本
    'zh': '🇨🇳', // 中国
    'es': '🇪🇸', // スペイン
    'de': '🇩🇪', // ドイツ
    'en': '🇺🇸'  // アメリカ（英語）
  };
  return flagMap[languageCode] || '🌐';
};

// 翻訳ポップアップの制御
function showTranslatePopup() {
  console.log('翻訳ポップアップを表示');
  document.getElementById('translatePopup').style.display = 'block';
}

function closeTranslatePopup() {
  document.getElementById('translatePopup').style.display = 'none';
}

function showTranslateLoading() {
  document.getElementById('translateLoading').style.display = 'block';
}

function hideTranslateLoading() {
  document.getElementById('translateLoading').style.display = 'none';
}

// 翻訳開始関数
async function startTranslation(language) {
  console.log('翻訳開始:', language);
  
  // ポップアップを閉じてローディングを表示
  closeTranslatePopup();
  showTranslateLoading();
  
  // レート制限回避のため少し待機
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  try {
    // 現在のレシピデータを収集
    const recipeData = {
      title: document.getElementById('recipeTitle').textContent,
      description: document.getElementById('notes')?.textContent || '',
      ingredients: Array.from(document.querySelectorAll('#ingredients .table tbody tr')).map(row => {
        const cells = row.querySelectorAll('td');
        return {
          position: cells[0]?.textContent || '',
          item: cells[1]?.textContent || '',
          quantity: cells[2]?.textContent || '',
          unit: cells[3]?.textContent || ''
        };
      }),
      steps: Array.from(document.querySelectorAll('#steps li')).map((step, index) => {
        const text = step.textContent || '';
        return { number: index + 1, text };
      })
    };
    
    console.log('収集したレシピデータ:', recipeData);
    console.log('説明文の長さ:', recipeData.description.length);
    console.log('材料数:', recipeData.ingredients.length);
    console.log('手順数:', recipeData.steps.length);
    console.log('手順データ:', recipeData.steps);
    
    // AI翻訳を実行
    const translatedData = await translateRecipe(recipeData, language);
    currentTranslatedData = translatedData;
    
    console.log('翻訳結果:', translatedData);
    
    console.log('翻訳材料数:', translatedData.ingredients ? translatedData.ingredients.length : 0);
    console.log('翻訳手順数:', translatedData.steps ? translatedData.steps.length : 0);
    
    // ローディングを非表示にして翻訳結果を表示
    hideTranslateLoading();
    showTranslatedResult(translatedData, language);
    
  } catch (error) {
    console.error('翻訳エラー:', error);
    hideTranslateLoading();
    
    let errorMessage = '翻訳に失敗しました: ' + error.message;
    if (error.message.includes('429')) {
      errorMessage = '翻訳APIの利用制限に達しました。しばらく時間をおいてから再度お試しください。';
    } else if (error.message.includes('API')) {
      errorMessage = '翻訳APIでエラーが発生しました。しばらく時間をおいてから再度お試しください。';
    }
    
    alert(errorMessage);
  }
}

// レシピ翻訳関数
async function translateRecipe(recipeData, targetLanguage) {
  const languageNames = {
    'fr': 'フランス語',
    'it': 'イタリア語',
    'zh': '中国語',
    'es': 'スペイン語',
    'de': 'ドイツ語',
    'en': '英語'
  };
  
  const languageName = languageNames[targetLanguage];
  
  const prompt = `以下のレシピを${languageName}に翻訳してください。料理名、材料、手順すべてを自然で適切な${languageName}に翻訳してください。

料理名: ${recipeData.title}
説明: ${recipeData.description}

材料:
${recipeData.ingredients.map(ing => `${ing.position}. ${ing.item} ${ing.quantity} ${ing.unit}`).join('\n')}

作り方:
${recipeData.steps.map(step => `${step.number}. ${step.text}`).join('\n')}

重要: 必ず以下のJSON形式のみで回答してください。説明や追加のテキストは一切含めないでください。

{
  "title": "翻訳された料理名",
  "description": "翻訳された説明",
  "ingredients": [
    {"position": "番号", "item": "材料名", "quantity": "分量", "unit": "単位"}
  ],
  "steps": [
    {"number": "番号", "text": "手順"}
  ]
}`;

  // SupabaseからAPIキーを取得
  const { data: apiKeys, error: apiError } = await sb.functions.invoke('get-api-keys', {
    body: { keyName: 'GEMINI_API_KEY' }
  });
  
  if (apiError || !apiKeys.success) {
    throw new Error('APIキーの取得に失敗しました');
  }

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKeys.apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.3,
        topK: 1,
        topP: 1,
        maxOutputTokens: 2000,
      }
    })
  });

  if (!response.ok) {
    throw new Error(`翻訳API エラー: ${response.status}`);
  }

  const data = await response.json();
  const translatedText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
  
  if (!translatedText) {
    throw new Error('翻訳結果が取得できませんでした');
  }

  console.log('翻訳レスポンス:', translatedText);

  try {
    // JSON形式の部分を抽出
    const jsonMatch = translatedText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      console.log('JSON形式で翻訳結果を解析:', jsonMatch[0]);
      const parsed = JSON.parse(jsonMatch[0]);
      console.log('解析された翻訳データ:', parsed);
      return parsed;
    } else {
      console.log('JSON形式ではないため、手動で構造化');
      // JSON形式でない場合は、手動で構造化
      const lines = translatedText.split('\n').filter(line => line.trim());
      const result = {
        title: lines[0] || '翻訳された料理名',
        description: lines.slice(1, 3).join(' ') || '翻訳された説明',
        ingredients: [],
        steps: []
      };
      
      // 材料と手順を抽出（簡易版）
      let currentSection = '';
      lines.forEach(line => {
        if (line.includes('材料') || line.includes('ingredients')) {
          currentSection = 'ingredients';
        } else if (line.includes('作り方') || line.includes('手順') || line.includes('steps')) {
          currentSection = 'steps';
        } else if (currentSection === 'ingredients' && /^\d+\./.test(line)) {
          const parts = line.split(/[\s\t]+/);
          result.ingredients.push({
            position: parts[0].replace('.', ''),
            item: parts.slice(1, -2).join(' '),
            quantity: parts[parts.length - 2] || '',
            unit: parts[parts.length - 1] || ''
          });
        } else if (currentSection === 'steps' && /^\d+\./.test(line)) {
          result.steps.push({
            number: line.match(/^\d+/)[0],
            text: line.replace(/^\d+\.\s*/, '')
          });
        }
      });
      
      return result;
    }
  } catch (parseError) {
    console.error('JSON解析エラー:', parseError);
    console.error('翻訳テキスト:', translatedText);
    
    // フォールバック: 基本的な構造を返す
    return {
      title: translatedText.split('\n')[0] || '翻訳された料理名',
      description: '翻訳された説明',
      ingredients: [],
      steps: []
    };
  }
}

// 翻訳結果表示
function showTranslatedResult(translatedData, language) {
  console.log('showTranslatedResult called with:', { translatedData, language });
  const flagEmoji = getFlagEmoji(language);
  
  // 翻訳タイトルを表示
  const translatedTitleEl = document.getElementById('translatedTitle');
  console.log('translatedTitleEl found:', !!translatedTitleEl);
  if (translatedTitleEl) {
    // 元のレシピタイトルを取得
    const originalTitle = document.getElementById('recipeTitle')?.textContent?.trim() || '';
    
    translatedTitleEl.innerHTML = `
      <span class="translated-text">${translatedData.title}</span>
      <span class="original-text">（${originalTitle}）</span>
      <span class="flag-emoji">${flagEmoji}</span>
    `;
    translatedTitleEl.style.display = 'block';
  }
  
  // 翻訳説明文を表示
  if (translatedData.description && translatedData.description.trim()) {
    const notesEl = document.getElementById('notes');
    if (notesEl) {
      const originalDescription = notesEl.textContent || '';
      notesEl.innerHTML = `
        <div class="translated-description">
          <div class="translated-text">${translatedData.description}</div>
          <div class="original-text">（${originalDescription}）</div>
        </div>
      `;
    }
  }
  
  // 翻訳材料を表示
  console.log('翻訳材料データ:', translatedData.ingredients);
  if (translatedData.ingredients && translatedData.ingredients.length > 0) {
    const ingredientsEl = document.getElementById('ingredients');
    console.log('ingredientsEl found:', !!ingredientsEl);
    if (ingredientsEl) {
      const originalIngredients = ingredientsEl.innerHTML;
      const translatedIngredientsHTML = `
        <div class="translated-section">
          <h4>材料 (Ingredients)</h4>
          <div style="overflow-x: auto; width: 100%;">
            <table class="table">
              <thead>
                <tr>
                  <th>番号</th>
                  <th>材料名</th>
                  <th>分量</th>
                  <th>単位</th>
                </tr>
              </thead>
              <tbody>
                ${translatedData.ingredients.map(ing => {
                  const position = ing.position || '';
                  const item = ing.item || '';
                  const quantity = ing.quantity || '';
                  const unit = ing.unit || '';
                  return `
                    <tr>
                      <td>${position === 'false' ? '' : position}</td>
                      <td>${item === 'false' ? '' : item}</td>
                      <td>${quantity === 'false' ? '' : quantity}</td>
                      <td>${unit === 'false' ? '' : unit}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>
          <div class="original-section">
            <h5>元の材料</h5>
            ${originalIngredients}
          </div>
        </div>
      `;
      ingredientsEl.innerHTML = translatedIngredientsHTML;
    }
  }
  
  // 翻訳手順を表示
  console.log('翻訳手順データ:', translatedData.steps);
  if (translatedData.steps && translatedData.steps.length > 0) {
    const stepsEl = document.getElementById('steps');
    console.log('stepsEl found:', !!stepsEl);
    if (stepsEl) {
      const originalSteps = stepsEl.innerHTML;
      const translatedStepsHTML = `
        <div class="translated-section">
          <h4>作り方 (Instructions)</h4>
          <ol>
            ${translatedData.steps.map(step => {
              const instruction = step.instruction || step.text || '';
              return `<li>${instruction === 'false' ? '' : instruction}</li>`;
            }).join('')}
          </ol>
          <div class="original-section">
            <h5>元の作り方</h5>
            ${originalSteps}
          </div>
        </div>
      `;
      stepsEl.innerHTML = translatedStepsHTML;
    }
  }
  
  // 翻訳完了 - 手動保存を可能にするため、自動保存はしない
  console.log('翻訳表示完了。手動で保存ボタンを使用してください。');
}

// 翻訳データと元の日本語を分離して保存（新しいテーブル構造）
async function saveCombinedRecipe(translatedData, language) {
  const currentRecipeId = new URLSearchParams(window.location.search).get('i');
  
  // 元のレシピデータを取得
  const originalTitle = document.getElementById('recipeTitle')?.textContent?.trim() || '';
  const originalDescription = document.getElementById('notes')?.textContent?.trim() || '';
  
  // 元の材料データを取得
  const originalIngredients = Array.from(document.querySelectorAll('#ingredients .table tbody tr')).map(row => {
    const cells = row.querySelectorAll('td');
    return {
      position: cells[0]?.textContent || '',
      item: cells[1]?.textContent || '',
      quantity: cells[2]?.textContent || '',
      unit: cells[3]?.textContent || ''
    };
  });
  
  // 元の手順データを取得
  const originalSteps = Array.from(document.querySelectorAll('#steps .step')).map(step => {
    const number = step.querySelector('.step-number')?.textContent || '';
    const text = step.querySelector('.step-text')?.textContent || '';
    return { number, text };
  });
  
  // 翻訳レシピメインデータを作成
  const translationRecipeData = {
    original_recipe_id: currentRecipeId,
    translated_title: translatedData.title,
    original_title: originalTitle,
    translated_description: translatedData.description,
    original_description: originalDescription,
    language_code: language,
    category: '翻訳レシピ',
    tags: ['翻訳', '多言語'],
    servings: 4
  };
  
  console.log('翻訳レシピデータ:', translationRecipeData);
  
  // 翻訳レシピを保存
  const { data: translationResult, error: translationError } = await sb
    .from('translation_recipes')
    .insert(translationRecipeData)
    .select()
    .single();
    
  if (translationError) {
    console.error('翻訳レシピ保存エラー:', translationError);
    // フォールバック: 既存のテーブル構造を使用
    await saveCombinedRecipeFallback(translatedData, language, originalTitle, originalDescription, originalIngredients, originalSteps);
    return;
  }
  
  const translationRecipeId = translationResult.id;
  
  // 翻訳材料を保存
  if (translatedData.ingredients && translatedData.ingredients.length > 0) {
    try {
      const translationIngredients = translatedData.ingredients.map((ing, index) => ({
        translation_recipe_id: translationRecipeId,
        position: index + 1,
        translated_item: ing.item || '',
        original_item: originalIngredients[index]?.item || '',
        quantity: ing.quantity || originalIngredients[index]?.quantity || '',
        unit: ing.unit || originalIngredients[index]?.unit || '',
        price: null
      }));
      
      const { error: ingredientsError } = await sb
        .from('translation_recipe_ingredients')
        .insert(translationIngredients);
        
      if (ingredientsError) {
        console.warn('翻訳材料保存エラー（スキップ）:', ingredientsError.message);
      }
    } catch (error) {
      console.warn('翻訳材料保存でエラー（スキップ）:', error);
    }
  }
  
  // 翻訳手順を保存
  if (translatedData.steps && translatedData.steps.length > 0) {
    try {
      const translationSteps = translatedData.steps.map((step, index) => ({
        translation_recipe_id: translationRecipeId,
        position: index + 1,
        translated_instruction: step.text || '',
        original_instruction: originalSteps[index]?.text || ''
      }));
      
      const { error: stepsError } = await sb
        .from('translation_recipe_steps')
        .insert(translationSteps);
        
      if (stepsError) {
        console.warn('翻訳手順保存エラー（スキップ）:', stepsError.message);
      }
    } catch (error) {
      console.warn('翻訳手順保存でエラー（スキップ）:', error);
    }
  }
}

// フォールバック: 既存のテーブル構造を使用
async function saveCombinedRecipeFallback(translatedData, language, originalTitle, originalDescription, originalIngredients, originalSteps) {
  console.log('フォールバック: 既存のテーブル構造を使用');
  
  // 既存のテーブル構造で保存
  const combinedRecipeData = {
    title: `${translatedData.title} （${originalTitle}）`,
    notes: `翻訳版:\n${translatedData.description}\n\n元の日本語版:\n${originalDescription}`,
    category: '翻訳レシピ',
    tags: ['翻訳', '多言語'],
    servings: 4
  };
  
  const { data: recipeResult, error: recipeError } = await sb
    .from('recipes')
    .insert(combinedRecipeData)
    .select()
    .single();
    
  if (recipeError) {
    throw new Error('レシピ保存エラー: ' + recipeError.message);
  }
  
  const newRecipeId = recipeResult.id;
  
  // 材料と手順の保存（既存の構造）
  // ... 既存のコードをそのまま使用
}

// 表示形式そのまま保存（HTML形式）
async function saveDisplayFormatRecipe(translatedData, language) {
  const currentRecipeId = new URLSearchParams(window.location.search).get('i');
  
  // 元のレシピデータを取得
  const originalTitle = document.getElementById('recipeTitle')?.textContent?.trim() || '';
  const originalDescription = document.getElementById('notes')?.textContent?.trim() || '';
  
  // 現在の表示されているHTMLを取得
  const translatedTitleHTML = document.getElementById('translatedTitle')?.innerHTML || '';
  const notesHTML = document.getElementById('notes')?.innerHTML || '';
  const ingredientsHTML = document.getElementById('ingredients')?.innerHTML || '';
  const stepsHTML = document.getElementById('steps')?.innerHTML || '';
  
  // 表示形式そのままのレシピデータを作成
  const displayFormatData = {
    title: `${translatedData.title} （${originalTitle}）`,
    notes: notesHTML, // 翻訳表示されたHTMLをそのまま保存
    category: '翻訳レシピ',
    tags: ['翻訳', '多言語', 'HTML形式'],
    servings: 4,
    display_format: 'html', // HTML形式であることを示すフラグ
    language_code: language,
    original_recipe_id: currentRecipeId
  };
  
  console.log('表示形式レシピデータ:', displayFormatData);
  
  // レシピを保存
  const { data: recipeResult, error: recipeError } = await sb
    .from('recipes')
    .insert(displayFormatData)
    .select()
    .single();
    
  if (recipeError) {
    throw new Error('レシピ保存エラー: ' + recipeError.message);
  }
  
  const newRecipeId = recipeResult.id;
  
  // 材料をHTML形式で保存（翻訳版と元の日本語版の両方）
  if (ingredientsHTML) {
    try {
      // 翻訳版の材料テーブルから各行を抽出
      const translatedIngredientRows = Array.from(document.querySelectorAll('#ingredients .translated-section .table tbody tr'));
      const originalIngredientRows = Array.from(document.querySelectorAll('#ingredients .original-section .table tbody tr'));
      
      // 翻訳版の材料を保存
      const translatedIngredientsData = translatedIngredientRows.map((row, index) => {
        const cells = row.querySelectorAll('td');
        return {
          recipe_id: newRecipeId,
          position: index + 1,
          item: cells[1]?.textContent || '',
          quantity: cells[2]?.textContent || '',
          unit: cells[3]?.textContent || '',
          price: null,
          html_content: row.outerHTML // HTML形式も保存
        };
      });
      
      // 元の日本語版の材料を保存（位置をずらす）
      const originalIngredientsData = originalIngredientRows.map((row, index) => {
        const cells = row.querySelectorAll('td');
        return {
          recipe_id: newRecipeId,
          position: translatedIngredientRows.length + index + 1,
          item: cells[1]?.textContent || '',
          quantity: cells[2]?.textContent || '',
          unit: cells[3]?.textContent || '',
          price: cells[4]?.textContent || null,
          html_content: row.outerHTML // HTML形式も保存
        };
      });
      
      // 両方の材料データを結合して保存
      const allIngredientsData = [...translatedIngredientsData, ...originalIngredientsData];
      
      const { error: ingredientsError } = await sb
        .from('recipe_ingredients')
        .insert(allIngredientsData);
        
      if (ingredientsError) {
        console.warn('材料保存エラー（スキップ）:', ingredientsError.message);
      }
    } catch (error) {
      console.warn('材料保存でエラー（スキップ）:', error);
    }
  }
  
  // 手順をHTML形式で保存（翻訳版と元の日本語版の両方）
  if (stepsHTML) {
    try {
      // 翻訳版の手順から各ステップを抽出
      const translatedStepElements = Array.from(document.querySelectorAll('#steps .translated-section ol li'));
      const originalStepElements = Array.from(document.querySelectorAll('#steps .original-section ol li'));
      
      // 翻訳版の手順を保存
      const translatedStepsData = translatedStepElements.map((step, index) => {
        return {
          recipe_id: newRecipeId,
          position: index + 1,
          instruction: step.textContent || '',
          html_content: step.outerHTML // HTML形式も保存
        };
      });
      
      // 元の日本語版の手順を保存（位置をずらす）
      const originalStepsData = originalStepElements.map((step, index) => {
        return {
          recipe_id: newRecipeId,
          position: translatedStepElements.length + index + 1,
          instruction: step.textContent || '',
          html_content: step.outerHTML // HTML形式も保存
        };
      });
      
      // 両方の手順データを結合して保存
      const allStepsData = [...translatedStepsData, ...originalStepsData];
      
      const { error: stepsError } = await sb
        .from('recipe_steps')
        .insert(allStepsData);
        
      if (stepsError) {
        console.warn('手順保存エラー（スキップ）:', stepsError.message);
      }
    } catch (error) {
      console.warn('手順保存でエラー（スキップ）:', error);
    }
  }
  
  // 翻訳タイトルも保存
  if (translatedTitleHTML) {
    try {
      await sb.from('recipe_translations').insert({
        recipe_id: newRecipeId,
        language_code: language,
        translated_title: translatedData.title,
        html_content: translatedTitleHTML // HTML形式も保存
      });
    } catch (error) {
      console.warn('翻訳タイトル保存エラー（スキップ）:', error);
    }
  }
}

// 翻訳タイトルのみ保存
async function saveTranslatedTitle(translatedTitle, language) {
  const currentRecipeId = new URLSearchParams(window.location.search).get('i');
  
  if (!currentRecipeId) {
    throw new Error('レシピIDが見つかりません');
  }
  
  try {
    // 既存の翻訳を削除して新しい翻訳を挿入
    await sb.from('recipe_translations').delete().eq('recipe_id', currentRecipeId);
    await sb.from('recipe_translations').insert({
      recipe_id: currentRecipeId,
      language_code: language,
      translated_title: translatedTitle
    });
  } catch (error) {
    console.error('翻訳タイトル保存エラー:', error);
    throw error;
  }
}

// 翻訳レシピ保存関数
async function saveTranslatedRecipe(translatedData, saveBoth = false) {
  const currentRecipeId = new URLSearchParams(window.location.search).get('i');
  
  // 翻訳版のレシピデータを作成
  const recipeData = {
    title: translatedData.title,
    notes: translatedData.description, // descriptionではなくnotesを使用
    category: '翻訳レシピ', // カテゴリーを設定
    tags: ['翻訳'],
    servings: 4 // デフォルト値
  };
  
  // レシピを保存
  const { data: recipeResult, error: recipeError } = await sb
    .from('recipes')
    .insert(recipeData)
    .select()
    .single();
    
  if (recipeError) {
    throw new Error('レシピ保存エラー: ' + recipeError.message);
  }
  
  const newRecipeId = recipeResult.id;
  
  // 材料を保存
  if (translatedData.ingredients && translatedData.ingredients.length > 0) {
    try {
      const ingredientsData = translatedData.ingredients.map((ing, index) => ({
        recipe_id: newRecipeId,
        position: ing.position || (index + 1),
        item: ing.item || '',
        quantity: ing.quantity || '',
        unit: ing.unit || '',
        price: null // 翻訳レシピでは価格は設定しない
      }));
      
      const { error: ingredientsError } = await sb
        .from('recipe_ingredients')
        .insert(ingredientsData);
        
      if (ingredientsError) {
        console.warn('材料保存エラー（スキップ）:', ingredientsError.message);
        console.warn('材料データ:', ingredientsData);
        // 材料保存エラーは警告として記録するが、処理を続行
      }
    } catch (error) {
      console.warn('材料保存でエラー（スキップ）:', error);
    }
  }
  
  // 手順を保存
  if (translatedData.steps && translatedData.steps.length > 0) {
    try {
      const stepsData = translatedData.steps.map((step, index) => ({
        recipe_id: newRecipeId,
        position: step.number || (index + 1),
        instruction: step.text || '' // textではなくinstructionを使用
      }));
      
      const { error: stepsError } = await sb
        .from('recipe_steps')
        .insert(stepsData);
        
      if (stepsError) {
        console.warn('手順保存エラー（スキップ）:', stepsError.message);
        console.warn('手順データ:', stepsData);
        // 手順保存エラーは警告として記録するが、処理を続行
      }
    } catch (error) {
      console.warn('手順保存でエラー（スキップ）:', error);
    }
  }
  
  // 元のレシピの翻訳タイトルも更新（saveBothの場合）
  if (saveBoth && currentRecipeId) {
    try {
      const language = document.getElementById('translateLanguage')?.value || 'fr';
      
      // 既存の翻訳を削除して新しい翻訳を挿入
      await sb.from('recipe_translations').delete().eq('recipe_id', currentRecipeId);
      await sb.from('recipe_translations').insert({
        recipe_id: currentRecipeId,
        language_code: language,
        translated_title: translatedData.title
      });
    } catch (error) {
      console.warn('翻訳タイトル保存エラー（スキップ）:', error);
      // 翻訳タイトル保存エラーは警告として記録するが、処理を続行
    }
  }
}
</script>
</body>
</html>